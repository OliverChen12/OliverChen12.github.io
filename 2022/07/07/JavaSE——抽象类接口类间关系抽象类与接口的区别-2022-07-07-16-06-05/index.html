<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>JavaSE——抽象类||接口||类间关系||抽象类与接口的区别 | Hexo</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">舰船主页</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">舰船留言箱</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">博士の文章</span></a></li><li class="navItem"><a class="navBlock" href="/valine/"><span class="navItemTitle">建设中...</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>JavaSE——抽象类||接口||类间关系||抽象类与接口的区别</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-07-07T08:06:05.904Z" id="date"> 2022-07-07</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-07-09T04:24:44.173Z" id="updated"> 2022-07-09</time></div></span><br><span>Word Count: <div class="control">4.4k</div></span><br><span>Read Time: <div class="control">17 min</div></span></div></div><hr><div id="post-content"><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>第一：抽象类怎么定义？在class前添加abstract关键字就行了。<br>        第二：抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。<br>        第三：final和abstract不能联合使用，这两个关键字是对立的。<br>        第四：抽象类的子类可以是抽象类。也可以是非抽象类。<br>        第五：抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。<br>        第六：抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。<br>        第七：抽象方法怎么定义？<br>            public abstract void doSome();<br>        第八（**<em><strong>五颗星）：</strong>一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖&#x2F;重写&#x2F;实现。</em>*</p>
<img src="https://s2.loli.net/2022/07/07/8WmkzR2wETxQcKN.png"/>
上图为对抽象类的理解

<pre><code>面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。
        不对，错误的。
        Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们
        都不是抽象方法，例如：
            public native int hashCode();
            这个方法底层调用了C++写的动态链接库程序。
            前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	抽象类：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	1、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	2、重要结论：重要结论五颗星*****（必须记住）</span><br><span class="hljs-comment">	一个非抽象的类继承抽象类，必须将抽象类中的抽象方法实现了。</span><br><span class="hljs-comment">	这是java语法上强行规定的，必须的，不然编译器就报错了。</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">	这里的覆盖或者说重写，也可以叫做实现。（对抽象的实现。）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractTest02</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-comment">// 能不能使用多态?</span><br>		<span class="hljs-comment">// 父类型引用指向子类型对象。</span><br>		<span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();  <span class="hljs-comment">// 向上转型。（自动类型转换）</span><br><br>		<span class="hljs-comment">// 这就是面向抽象编程。</span><br>		<span class="hljs-comment">// 以后你都是调用的a.XXXX</span><br>		<span class="hljs-comment">// a的类型是Animal，Animal是抽象的</span><br>		<span class="hljs-comment">// 面向抽象编程，不要面向具体编程，降低程序的耦合度，提高程序的扩展力。</span><br>		<span class="hljs-comment">// 这种编程思想符合OCP原则。</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			分析以下：</span><br><span class="hljs-comment">				编译的时候这个move()方法是谁的？</span><br><span class="hljs-comment">				运行的时候这个move()方法又是谁的？</span><br><span class="hljs-comment">		*/</span><br>		a.move();<br><br>		<span class="hljs-comment">// 多态（当对多态不是很理解的时候，以后写代码能用多态就用多态。慢慢就理解了。）</span><br>		<span class="hljs-type">Animal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>		x.move();<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 动物类（抽象类）</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>	<span class="hljs-comment">// 抽象方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 子类（非抽象的）</span><br><span class="hljs-comment">// 错误: Bird不是抽象的, 并且未覆盖Animal中的抽象方法move()</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class Bird extends Animal&#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>	<span class="hljs-comment">// 需要将从父类中继承过来的抽象方法进行覆盖/重写，或者也可以叫做“实现”。</span><br>	<span class="hljs-comment">// 把抽象的方法实现了。</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;鸟儿在飞翔！&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;猫在走猫步！&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果Bird是抽象类的话，那么这个Animal中继承过来的抽象方法也可以不去重写/覆盖/实现。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">abstract class Bird extends Animal&#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br>	<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	有些内容不要死记硬背，讲讲道理。</span><br><span class="hljs-comment">	分析：</span><br><span class="hljs-comment">		Animal是父类，并且是 抽象的。</span><br><span class="hljs-comment">		Animal这个抽象类中有一个抽象方法move。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		Bird是子类，并且是 非抽象的。</span><br><span class="hljs-comment">		Bird继承Animal之后，会将抽象方法继承过来。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的基础语法"><a href="#接口的基础语法" class="headerlink" title="接口的基础语法"></a>接口的基础语法</h3><p>1、接口是一种“引用数据类型”。<br>        2、接口是完全抽象的。<br>        3、接口怎么定义：[修饰符列表] interface 接口名{}<br>        4、接口支持多继承。<br>        5、接口中只有常量+抽象方法。<br>        6、接口中所有的元素都是public修饰的<br>        7、接口中抽象方法的public abstract可以省略。<br>        8、接口中常量的public static final可以省略。<br>        9、接口中方法不能有方法体。<br>        10、<strong>一个非抽象的类，实现接口的时候，必须将接口中所有方法加以实现。</strong><br>        11、<strong>一个类可以实现多个接口</strong>。<br>        12、extends和implements可以共存，extends在前，implements在后。<br>        13、使用接口，写代码的时候，可以使用多态（父类型引用指向子类型对象）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	接口的基础语法：</span><br><span class="hljs-comment">		1、类和类之间叫做继承，类和接口之间叫做实现。</span><br><span class="hljs-comment">		别多想：你仍然可以将&quot;实现&quot;看做“继承”。</span><br><span class="hljs-comment">		继承使用extends关键字完成。</span><br><span class="hljs-comment">		实现使用implements关键字完成。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		2、五颗星（*****）：当一个非抽象的类实现接口的话，必须将接口中所有的</span><br><span class="hljs-comment">		抽象方法全部实现（覆盖、重写）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-comment">//错误: MyMath是抽象的; 无法实例化</span><br>		<span class="hljs-comment">//new MyMath();</span><br><br>		<span class="hljs-comment">// 能使用多态吗？可以。</span><br>		<span class="hljs-comment">//Animal a = new Cat();</span><br><br>		<span class="hljs-comment">// 父类型的引用指向子类型的对象</span><br>		<span class="hljs-type">MyMath</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMathImpl</span>();<br>		<span class="hljs-comment">// 调用接口里面的方法（面向接口编程。）</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> mm.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>		System.out.println(result1);<br><br>		<span class="hljs-type">int</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> mm.sub(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>);<br>		System.out.println(result2);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 特殊的抽象类，完全抽象的，叫做接口。</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMath</span>&#123;<br>	<span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><br><span class="hljs-comment">// 这样没问题</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">abstract class MyMathImpl implements MyMath &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 编写一个类（这个类是一个“非抽象”的类）</span><br><span class="hljs-comment">// 这个类的名字是随意的。</span><br><span class="hljs-comment">//错误: MyMathImpl不是抽象的, 并且未覆盖MyMath中的抽象方法sub(int,int)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class MyMathImpl implements MyMath &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//修正</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMathImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyMath</span> &#123;<br><br>	<span class="hljs-comment">//错误：正在尝试分配更低的访问权限; 以前为public</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	int sum(int a, int b)&#123;</span><br><span class="hljs-comment">		return a + b;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">	*/</span><br><br>	<span class="hljs-comment">// 重写/覆盖/实现 接口中的方法（通常叫做实现。）</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>		<span class="hljs-keyword">return</span> a + b;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>		<span class="hljs-keyword">return</span> a - b;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		对于计算机来说，一个机箱上有多个接口，一个接口是接键盘的，</span><br><span class="hljs-comment">		一个接口是接鼠标的，一个接口是接电源的，一个接口是接显示器的.....</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	重点（五颗星*****）：一个类可以同时实现多个接口。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	这种机制弥补了java中的哪个缺陷？</span><br><span class="hljs-comment">		java中类和类只支持单继承。实际上单继承是为了简单而出现的，现实世界中</span><br><span class="hljs-comment">		存在多继承，java中的接口弥补了单继承带来的缺陷。</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	接口A和接口B虽然没有继承关系，但是写代码的时候，可以互转。</span><br><span class="hljs-comment">	编译器没意见。但是运行时可能出现：ClassCastException</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	之前有一个结论：</span><br><span class="hljs-comment">		无论向上转型还是向下转型，两种类型之间必须要有继承关系，</span><br><span class="hljs-comment">		没有继承关系编译器会报错。（这句话不适用在接口方面。）</span><br><span class="hljs-comment">		最终实际上和之前还是一样，需要加：instanceof运算符进行判断。</span><br><span class="hljs-comment">		向下转型养成好习惯。转型之前先if+instanceof进行判断。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-comment">// 多态该怎么用呢？</span><br>		<span class="hljs-comment">// 都是父类型引用指向子类型对象</span><br>		<span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">D</span>();<br>		<span class="hljs-comment">//a.m2(); // 编译报错。A接口中没有m2()方法。</span><br>		<span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">D</span>();<br>		<span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">D</span>();<br><br>		<span class="hljs-comment">// 这个编译没问题，运行也没问题。</span><br>		<span class="hljs-comment">// 调用其他接口中的方法，你需要转型（接口转型。）</span><br>		<span class="hljs-type">B</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> (B)a;<br>		b2.m2();<br><br>		<span class="hljs-comment">// 直接向下转型为D可以吗？可以</span><br>		<span class="hljs-type">D</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (D)a;<br>		d.m2();<br><br>		<span class="hljs-type">M</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">E</span>();<br>		<span class="hljs-comment">// 经过测试：接口和接口之间在进行强制类型转换的时候，没有继承关系，也可以强转。</span><br>		<span class="hljs-comment">// 但是一定要注意，运行时可能会出现ClassCastException异常。</span><br>		<span class="hljs-comment">// 编译没问题，运行有问题。</span><br>		<span class="hljs-comment">//K k = (K)m;</span><br>		<span class="hljs-keyword">if</span>(m <span class="hljs-keyword">instanceof</span> K)&#123;<br>			<span class="hljs-type">K</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> (K)m;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">K</span>&#123;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">M</span>&#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">M</span>&#123;<br>&#125;<br><br><span class="hljs-comment">// --------------------------------------------------------------------</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">X</span>&#123;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Y</span>&#123;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Z</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">X</span>,Y&#123; <span class="hljs-comment">//接口和接口支持多继承。</span><br>&#125;<br><br><span class="hljs-comment">//------------------------------------------------------------------</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span>&#123;<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span>&#123;<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现多个接口，其实就类似于多继承。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B,C&#123;<br>	<span class="hljs-comment">// 实现A接口的m1()</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span>&#123;<br>		<br>	&#125;<br>	<span class="hljs-comment">// 实现B接口中的m2()</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;m2 ....&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">// 实现接口C中的m3()</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span>&#123;<br>	<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>以下为继承与实现同时存在时的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	继承和实现都存在的话，代码应该怎么写？</span><br><span class="hljs-comment">		extends 关键字在前。</span><br><span class="hljs-comment">		implements 关键字在后。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test04</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-comment">// 创建对象（表面看Animal类没起作用！）</span><br>		<span class="hljs-type">Flyable</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(); <span class="hljs-comment">//多态。</span><br>		f.fly();<br><br>		<span class="hljs-comment">// 同一个接口</span><br>		<span class="hljs-type">Flyable</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>();<br>		<span class="hljs-comment">// 调用同一个fly()方法，最后的执行效果不同。</span><br>		f2.fly();<br><br>		<span class="hljs-type">Flyable</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fish</span>();<br>		f3.fly();<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 动物类：父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 可飞翔的接口（是一对翅膀）</span><br><span class="hljs-comment">// 能插拔的就是接口。（没有接口你怎么插拔。）</span><br><span class="hljs-comment">// 内存条插到主板上，他们之间有接口。内存条可以更换。</span><br><span class="hljs-comment">// 接口通常提取的是行为动作。</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span>&#123;<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 动物类子类：猫类</span><br><span class="hljs-comment">// Flyable是一个接口，是一对翅膀的接口，通过接口插到猫身上，让猫变的可以飞翔。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;飞猫起飞，翱翔太空的一只猫，很神奇，我想做一只猫！！&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 蛇类，如果你不想让它飞，可以不实现Flyable接口</span><br><span class="hljs-comment">// 没有实现这个接口表示你没有翅膀，没有给你插翅膀，你肯定不能飞。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>&#125;<br><br><span class="hljs-comment">// 想飞就插翅膀这个接口。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;我是一只会飞的猪！！！&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 鱼（默认实际上是存在继承的，默认继承Object。）</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class Fish extends Object implements Flyable&#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fish</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span>&#123; <span class="hljs-comment">//没写extends，也是有的，默认继承Object。</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;我是六眼飞鱼（流言蜚语）！！！&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="接口在开发中的作用"><a href="#接口在开发中的作用" class="headerlink" title="接口在开发中的作用"></a>接口在开发中的作用</h3><p>注意：接口在开发中的作用，类似于多态在开发中的作用。</p>
<p>多态：面向抽象编程，不要面向具体编程。降低程序的耦合度。提高程序的扩展力。<br>&#x2F;*<br>public class Master{<br>                public void feed(Dog d){}<br>                public void feed(Cat c){}<br>                &#x2F;&#x2F;假设又要养其它的宠物，那么这个时候需要再加1个方法。（需要修改代码了）<br>                &#x2F;&#x2F;这样扩展力太差了，违背了OCP原则（对扩展开放，对修改关闭。）<br>            }<br>            *&#x2F;</p>
<p>public class Master{<br>                public void feed(Animal a){<br>                    &#x2F;&#x2F; 面向Animal父类编程，父类是比子类更抽象的。<br>                    &#x2F;&#x2F;所以我们叫做面向抽象编程，不要面向具体编程。<br>                    &#x2F;&#x2F;这样程序的扩展力就强。<br>                }<br>            }</p>
<p>接口在开发中的作用？<br>            接口是不是完全的？是。<br>            而我们以后正好要求，面向抽象编程。<br>            面向抽象编程这句话以后可以修改为：面向接口编程。<br>            有了接口就有了可插拔。可插拔表示扩展力很强。不是焊接死的。</p>
<p>主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新<br>            买一个换下来。这叫做高扩展性。（低耦合度。）</p>
<p>接口在现实世界中是不是到处都是呢？<br>                螺栓和螺母之间有接口<br>                灯泡和灯口之间有接口<br>                笔记本电脑和键盘之间有接口（usb接口，usb接口是不是某个计算机协会制定的协议&#x2F;规范。）<br>                接口有什么用？扩展性好。可插拔。</p>
<p>接口是一个抽象的概念。</p>
<p>分析：<br>                中午去饭馆吃饭，这个过程中有接口吗？</p>
<p>接口是抽象的。	</p>
<p>菜单是一个接口。（菜单上有一个抽象的照片：西红柿炒鸡蛋）</p>
<p>谁面向接口调用。（顾客面向菜单点菜，调用接口。）</p>
<p>谁负责实现这个接口。（后台的厨师负责把西红柿鸡蛋做好！是接口的实现者。）</p>
<p>这个接口有什么用呢？<br>这个饭馆的“菜单”，让“顾客”和“后厨”解耦合了。<br>顾客不用找后厨，后厨不用找顾客。他们之间完全依靠这个抽象的菜单沟通。</p>
<p>总结一句话：三个字“<strong>解耦合</strong>”<br>                <strong>面向接口编程，可以降低程序的耦合度，提高程序的扩展力。符合OCP开发原则。</strong><br>            接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度。）</p>
<p>接口可以解耦合，解开的是谁和谁的耦合！！！<br>                任何一个接口都有调用者和实现者。<br>                接口可以将调用者和实现者解耦合。<br>                调用者面向接口调用。<br>                实现者面向接口编写实现。</p>
<h2 id="类型和类型之间的关系："><a href="#类型和类型之间的关系：" class="headerlink" title="类型和类型之间的关系："></a>类型和类型之间的关系：</h2><p>is a（继承）、has a（关联）、like a（实现）</p>
<p>is a：<br>                Cat is a Animal（猫是一个动物）<br>                凡是能够满足is a的表示“继承关系”<br>                A extends B</p>
<p>has a：<br>                I has a Pen（我有一支笔）<br>                凡是能够满足has a关系的表示“关联关系”<br>                关联关系通常以“属性”的形式存在。<br>                A{<br>                    B b;<br>                }</p>
<p>like a:<br>                Cooker like a FoodMenu（厨师像一个菜单一样）<br>                凡是能够满足like a关系的表示“实现关系”<br>                实现关系通常是：类实现接口。<br>                A implements B</p>
<h2 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h2><p>在这里我们只说一下抽象类和接口在语法上的区别。<br>至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会&#x2F;学习。</p>
<pre><code>    抽象类是半抽象的。
    接口是完全抽象的。

    抽象类中有构造方法。
    接口中没有构造方法。

    接口和接口之间支持多继承。
    类和类之间只能单继承。

    一个类可以同时实现多个接口。
    一个抽象类只能继承一个类（单继承）。

    接口中只允许出现常量和抽象方法。
    
</code></pre>
<p>以后接口使用的比抽象类多。一般抽象类使用的还是少。<br>接口一般都是对“行为”的抽象。</p>
<p>接口在开发中的实现举例：</p>
<p>AmericCooker.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//西餐厨师</span><br><span class="hljs-comment">// 实现菜单上的菜</span><br><span class="hljs-comment">// 厨师是接口的实现者。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AmericCooker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FoodMenu</span>&#123;<br><br>	<span class="hljs-comment">// 西红柿炒蛋</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shiZiChaoJiDan</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;西餐师傅做的西红柿炒鸡蛋！&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// 鱼香肉丝</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yuXiangRouSi</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;西餐师傅做的鱼香肉丝！&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ChinaCooker.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//中餐厨师</span><br><span class="hljs-comment">// 实现菜单上的菜</span><br><span class="hljs-comment">// 厨师是接口的实现者。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaCooker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FoodMenu</span>&#123;<br><br>	<span class="hljs-comment">// 西红柿炒蛋</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shiZiChaoJiDan</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;中餐师傅做的西红柿炒鸡蛋，东北口味！&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// 鱼香肉丝</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yuXiangRouSi</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;中餐师傅做的鱼香肉丝，东北口味！&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>FoodMenu.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	接口：菜单，抽象的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FoodMenu</span>&#123;<br><br>	<span class="hljs-comment">// 西红柿炒蛋</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">shiZiChaoJiDan</span><span class="hljs-params">()</span>;<br><br>	<span class="hljs-comment">// 鱼香肉丝</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">yuXiangRouSi</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Customer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 顾客</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;<br>	<span class="hljs-comment">// 顾客手里有一个菜单</span><br>	<span class="hljs-comment">// Customer has a FoodMenu!（这句话什么意思：顾客有一个菜单）</span><br>	<span class="hljs-comment">// 记住：以后凡是能够使用 has a 来描述的，统一以属性的方式存在。</span><br>	<span class="hljs-comment">// 实例变量，属性</span><br>	<span class="hljs-comment">// 面向抽象编程，面向接口编程。降低程序的耦合度，提高程序的扩展力。</span><br>	<span class="hljs-keyword">private</span> FoodMenu foodMenu; <br>	<br>	<span class="hljs-comment">// 如果以下这样写，就表示写死了（焊接了。没有可插拔了。）</span><br>	<span class="hljs-comment">// 中餐厨师</span><br>	<span class="hljs-comment">//ChinaCooker cc;</span><br><br>	<span class="hljs-comment">// 西餐厨师</span><br>	<span class="hljs-comment">//AmericCooker ac</span><br><br>	<span class="hljs-comment">// 构造方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">()</span>&#123;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">(FoodMenu foodMenu)</span>&#123;<br>		<span class="hljs-built_in">this</span>.foodMenu = foodMenu;<br>	&#125;<br><br>	<span class="hljs-comment">// setter and getter</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFoodMenu</span><span class="hljs-params">(FoodMenu foodMenu)</span>&#123;<br>		<span class="hljs-built_in">this</span>.foodMenu = foodMenu;<br>	&#125;<br>	<span class="hljs-keyword">public</span> FoodMenu <span class="hljs-title function_">getFoodMenu</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> foodMenu;<br>	&#125;<br><br>	<span class="hljs-comment">// 提供一个点菜的方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">order</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-comment">// 先拿到菜单才能点菜</span><br>		<span class="hljs-comment">// 调用get方法拿菜单。</span><br>		<span class="hljs-comment">//FoodMenu fm = this.getFoodMenu();</span><br>		<span class="hljs-comment">// 也可以不调用get方法，因为在本类中私有的属性是可以访问</span><br>		foodMenu.shiZiChaoJiDan();<br>		foodMenu.yuXiangRouSi();<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	Cat is a Animal，但凡满足is a的表示都可以设置为继承。</span><br><span class="hljs-comment">	Customer has a FoodMenu，但凡是满足has a的表示都以属性的形式存在。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class Address&#123;</span><br><span class="hljs-comment">	String city;</span><br><span class="hljs-comment">	String street;</span><br><span class="hljs-comment">	String zipcode;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">class User&#123;</span><br><span class="hljs-comment">	int id;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	// 和这个一样。</span><br><span class="hljs-comment">	// String是一个类。</span><br><span class="hljs-comment">	// name是变量名。</span><br><span class="hljs-comment">	// name是一个引用。</span><br><span class="hljs-comment">	String name;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	// Address是一个类名。</span><br><span class="hljs-comment">	// 这就是一个变量。</span><br><span class="hljs-comment">	// 实例变量。</span><br><span class="hljs-comment">	Address addr; // addr是一个引用。是一个变量。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	public static void main(String[] args)&#123;</span><br><span class="hljs-comment">		// 局部变量</span><br><span class="hljs-comment">		//Address addr;</span><br><span class="hljs-comment">		//addr = new Address();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		// 合并。</span><br><span class="hljs-comment">		Address addr = new Address();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		User u = new User();</span><br><span class="hljs-comment">		u.id = 100;</span><br><span class="hljs-comment">		u.name = &quot;zhangsan&quot;;</span><br><span class="hljs-comment">		u.addr = new Address();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		System.out.println(u.addr.city); // null</span><br><span class="hljs-comment">		System.out.println(u.addr.street); // null</span><br><span class="hljs-comment">		System.out.println(u.addr.zipcode); // null</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">//“自己”类</span><br><span class="hljs-comment">// MySelf has a Friend;</span><br><span class="hljs-comment">class MySelf&#123;</span><br><span class="hljs-comment">	// 你这个对象，应该有一个朋友对象的电话号码。</span><br><span class="hljs-comment">	// 电话号码就是一个对象的内存地址。联系你朋友的时候，打电话。</span><br><span class="hljs-comment">	// f是一个引用。f默认值是null，是null表示，你没有朋友。</span><br><span class="hljs-comment">	Friend f;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	public MySelf()&#123;</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">	//通过构造方法能不能给你一个朋友对象。</span><br><span class="hljs-comment">	public MySelf(Friend f)&#123;</span><br><span class="hljs-comment">		this.f = f;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	public static void main(String[] args)&#123;</span><br><span class="hljs-comment">		// 创建朋友对象</span><br><span class="hljs-comment">		Friend f = new Friend(); //朋友对象有了</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		// 创建对象的同时交朋友。</span><br><span class="hljs-comment">		MySelf m2 = new MySelf(f);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		// 创建自己对象</span><br><span class="hljs-comment">		// 目前还没有交朋友。</span><br><span class="hljs-comment">		MySelf m = new MySelf(); //自己对象</span><br><span class="hljs-comment">		// 交朋友</span><br><span class="hljs-comment">		m.f = f; // 把朋友的地址给了你。</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// “朋友”类</span><br><span class="hljs-comment">class Friend&#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>Test.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br>		<span class="hljs-comment">// 创建厨师对象</span><br>		<span class="hljs-comment">//FoodMenu cooker1 = new ChinaCooker();</span><br>		<span class="hljs-type">FoodMenu</span> <span class="hljs-variable">cooker1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmericCooker</span>();<br><br>		<span class="hljs-comment">// 创建顾客对象</span><br>		<span class="hljs-type">Customer</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(cooker1);<br><br>		<span class="hljs-comment">// 顾客点菜</span><br>		customer.order();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/07/11/JavaSE%E2%80%94%E2%80%94%E5%8C%85%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90toStringequalsfinalizehashCode-2022-07-11-16-46-22/">← Next JavaSE——包||访问控制权限||toString||equals||finalize||hashCode</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/05/02/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%9710-java10/">Java学习日志10 Prev →</a></div></div></div><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Oliver Chen</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">接口的基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">接口在开发中的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">类型和类型之间的关系：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">抽象类和接口有什么区别？</span></a></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">懒得备案</a></nobr><nobr><span class="text-title">©</span><span class="text-content">1970 to 2023</span></nobr><br><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'VXJpDLBtIuAgtIMNqazuy0eY-gzGzoHsz'
 , appKey: 'wzl7lI6VNnLw8deYXvRaTgOc' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>