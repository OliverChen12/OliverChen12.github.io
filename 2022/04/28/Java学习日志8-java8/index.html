<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Java学习日志8 | Hexo</title><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var config = {"root":"/","path":"search.json"}</script><script src="//unpkg.com/mermaid@8.13.5/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">舰船主页</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">舰船留言箱</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">博士の文章</span></a></li><li class="navItem"><a class="navBlock" href="/valine/"><span class="navItemTitle">建设中...</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>Java学习日志8</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-04-28T08:55:12.354Z" id="date"> 2022-04-28</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-04-28T14:17:25.699Z" id="updated"> 2022-04-28</time></div></span><br><span>Word Count: <div class="control">3.4k</div></span><br><span>Read Time: <div class="control">12 min</div></span></div></div><hr><div id="post-content"><h2 id="继承-下"><a href="#继承-下" class="headerlink" title="继承(下)"></a>继承(下)</h2><p>在实际开发中，满足什么条件的时候，我可以使用继承呢？<br>        凡是采用“is a”能描述的，都可以继承。<br>        例如：<br>            Cat is a Animal：猫是一个动物<br>            Dog is a Animal：狗是一个动物<br>            CreditAccount is a Account：信用卡账户是一个银行账户<br>            ….</p>
<p>假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够使用is a来描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;<br>	String name; <span class="hljs-comment">// 名字</span><br>	<span class="hljs-comment">// setter and getter</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>&#123;<br>	String name; <span class="hljs-comment">// 名字</span><br>	<span class="hljs-comment">// setter and getter</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Customer</span>&#123;<br>			<br>&#125;<br><br></code></pre></td></tr></table></figure>


<p>以上的继承就属于很失败的。因为：Product is a Customer，是有违伦理的。</p>
<h2 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h2><p>2.1、什么时候考虑使用方法覆盖？<br>        父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。</p>
<p>2.2、什么条件满足的时候构成方法覆盖？<br>        第一：有<strong>继承关系</strong>的两个类<br>        第二：具有<strong>相同方法名</strong>、<strong>返回值类型</strong>、<strong>形式参数列表</strong><br>        第三：<strong>访问权限不能更低</strong>。<br>        第四：<strong>抛出异常不能更多</strong>。</p>
<p>2.3、关于Object类中toString()方法的覆盖？<br>        toString()方法存在的作用就是：将java对象转换成字符串形式。<br>        大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()<br>        方法输出的是一个java对象的内存地址。<br>至于toString()方法具体怎么进行覆盖？<br>            格式可以自己定义，或者听需求的。（听项目要求的。）</p>
<p>2.4、方法重载和方法覆盖有什么区别？</p>
<ul>
<li><p><strong>方法重载发生在同一个类当中</strong>。</p>
</li>
<li><p><strong>方法覆盖是发生在具有继承关系的父子类之间</strong>。</p>
</li>
<li><p>方法重载是一个类中，方法名相同，参数列表不同。</p>
</li>
<li><p>方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：<strong>方法名一致、参数列表一致、返回值类型一致</strong>。</p>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> OliverChen</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverrideTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Animals.doSomething();<br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>        b.move();<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        c.move();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animals</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span><br>    &#123;<br>        O.p(<span class="hljs-string">&quot;Do something!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span><br>    &#123;<br>        O.p(<span class="hljs-string">&quot;动物在移动!!!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animals</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span><br>    &#123;<br>        O.p(<span class="hljs-string">&quot;鸟儿在飞翔！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animals</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span><br>    &#123;<br>        O.p(<span class="hljs-string">&quot;猫在走猫步！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="多态（非常重要"><a href="#多态（非常重要" class="headerlink" title="多态（非常重要!!!)"></a>多态（非常重要!!!)</h2><h3 id="向上转型、向下转型与instanceof运算符"><a href="#向上转型、向下转型与instanceof运算符" class="headerlink" title="向上转型、向下转型与instanceof运算符"></a>向上转型、向下转型与instanceof运算符</h3><p><strong>两种类型间必须有继承关系！！！</strong></p>
<p>向上转型：子—&gt;父 (upcasting)<br>            又被称为自动类型转换：Animal a &#x3D; new Cat();</p>
<p>向下转型：父—&gt;子 (downcasting)<br>又被称为强制类型转换：Cat c &#x3D; (Cat)a; 需要添加强制类型转换符。</p>
<p>什么时候需要向下转型？<br>需要调用或者执行子类对象中特有的方法。必须进行向下转型，才可以调用。</p>
<p>向下转型有风险吗？<br>容易出现ClassCastException（类型转换异常）</p>
<p>怎么避免这个风险？<br>instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象是否为某一种类型。<br><strong>养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。</strong><br>不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。</p>
<p>代码示例：（<strong>非常重要的示例！！！</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span>&#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br>		<span class="hljs-type">Animal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>		a1.move(); <span class="hljs-comment">//动物在移动！！！</span><br><br>		<span class="hljs-type">Cat</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>		c1.move(); <span class="hljs-comment">//cat走猫步！</span><br><br>		<span class="hljs-type">Bird</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>		b1.move(); <span class="hljs-comment">//鸟儿在飞翔！！！</span><br><br>		<span class="hljs-comment">// 代码可以这样写吗？</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			1、Animal和Cat之间有继承关系吗？有的。</span><br><span class="hljs-comment">			2、Animal是父类，Cat是子类。</span><br><span class="hljs-comment">			3、Cat is a Animal，这句话能不能说通？能。</span><br><span class="hljs-comment">			4、经过测试得知java中支持这样的一个语法：</span><br><span class="hljs-comment">				父类型的引用允许指向子类型的对象。</span><br><span class="hljs-comment">				Animal a2 = new Cat();</span><br><span class="hljs-comment">				a2就是父类型的引用。</span><br><span class="hljs-comment">				new Cat()是一个子类型的对象。</span><br><span class="hljs-comment">				允许a2这个父类型引用指向子类型的对象。</span><br><span class="hljs-comment">		*/</span><br>		<span class="hljs-type">Animal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>		<span class="hljs-type">Animal</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br><br>		<span class="hljs-comment">// 没有继承关系的两个类型之间存在转型吗？</span><br>		<span class="hljs-comment">// 错误: 不兼容的类型: Dog无法转换为Animal</span><br>		<span class="hljs-comment">// Animal a4 = new Dog();</span><br><br>		<span class="hljs-comment">// 调用a2的move()方法</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			什么是多态？</span><br><span class="hljs-comment">				多种形态，多种状态。</span><br><span class="hljs-comment">			分析：a2.move();</span><br><span class="hljs-comment">				java程序分为编译阶段和运行阶段。</span><br><span class="hljs-comment">				先来分析编译阶段：</span><br><span class="hljs-comment">					对于编译器来说，编译器只知道a2的类型是Animal，</span><br><span class="hljs-comment">					所以编译器在检查语法的时候，会去Animal.class</span><br><span class="hljs-comment">					字节码文件中找move()方法，找到了，绑定上move()</span><br><span class="hljs-comment">					方法，编译通过，静态绑定成功。（编译阶段属于静态绑定。）</span><br><span class="hljs-comment">				再来分析运行阶段：</span><br><span class="hljs-comment">					运行阶段的时候，实际上在堆内存中创建的java对象是</span><br><span class="hljs-comment">					Cat对象，所以move的时候，真正参与move的对象是一只猫，</span><br><span class="hljs-comment">					所以运行阶段会动态执行Cat对象的move()方法。这个过程</span><br><span class="hljs-comment">					属于运行阶段绑定。（运行阶段绑定属于动态绑定。）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">			多态表示多种形态：</span><br><span class="hljs-comment">				编译的时候一种形态。</span><br><span class="hljs-comment">				运行的时候另一种形态。</span><br><span class="hljs-comment">		*/</span><br>		a2.move(); <span class="hljs-comment">//cat走猫步！</span><br>		<br>		<span class="hljs-comment">// 调用a3的move()方法</span><br>		a3.move(); <span class="hljs-comment">//鸟儿在飞翔！！！</span><br><br>		<span class="hljs-comment">// ======================================================================</span><br>		<span class="hljs-type">Animal</span> <span class="hljs-variable">a5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(); <span class="hljs-comment">// 底层对象是一只猫。</span><br><br>		<span class="hljs-comment">// 分析这个程序能否编译和运行呢？</span><br>		<span class="hljs-comment">// 分析程序一定要分析编译阶段的静态绑定和运行阶段的动态绑定。</span><br>		<span class="hljs-comment">// 只有编译通过的代码才能运行。没有编译，根本轮不到运行。</span><br>		<span class="hljs-comment">// 错误: 找不到符号</span><br>		<span class="hljs-comment">// why??? 因为编译器只知道a5的类型是Animal，去Animal.class文件中找catchMouse()方法</span><br>		<span class="hljs-comment">// 结果没有找到，所以静态绑定失败，编译报错。无法运行。（语法不合法。）</span><br>		<span class="hljs-comment">//a5.catchMouse(); </span><br>		<br>		<span class="hljs-comment">// 假设代码写到了这里，我非要调用catchMouse()方法怎么办？</span><br>		<span class="hljs-comment">// 这个时候就必须使用“向下转型”了。（强制类型转换）</span><br>		<span class="hljs-comment">// 以下这行代码为啥没报错？？？？</span><br>		<span class="hljs-comment">// 因为a5是Animal类型，转成Cat，Animal和Cat之间存在继承关系。所以没报错。</span><br>		<span class="hljs-type">Cat</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (Cat)a5;<br>		x.catchMouse(); <span class="hljs-comment">//猫正在抓老鼠！！！！</span><br><br>		<span class="hljs-comment">// 向下转型有风险吗？</span><br>		<span class="hljs-type">Animal</span> <span class="hljs-variable">a6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>(); <span class="hljs-comment">//表面上a6是一个Animal，运行的时候实际上是一只鸟儿。</span><br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">			分析以下程序，编译报错还是运行报错？？？</span><br><span class="hljs-comment">				编译器检测到a6这个引用是Animal类型，</span><br><span class="hljs-comment">				而Animal和Cat之间存在继承关系，所以可以向下转型。</span><br><span class="hljs-comment">				编译没毛病。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">				运行阶段，堆内存实际创建的对象是：Bird对象。</span><br><span class="hljs-comment">				在实际运行过程中，拿着Bird对象转换成Cat对象</span><br><span class="hljs-comment">				就不行了。因为Bird和Cat之间没有继承关系。</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			运行是出现异常，这个异常和空指针异常一样非常重要，也非常经典：</span><br><span class="hljs-comment">				java.lang.ClassCastException：类型转换异常。</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			java.lang.NullPointerException：空指针异常。这个也非常重要。</span><br><span class="hljs-comment">		*/</span><br>		<span class="hljs-comment">//Cat y = (Cat)a6;</span><br>		<span class="hljs-comment">//y.catchMouse();</span><br><br>		<span class="hljs-comment">// 怎么避免ClassCastException异常的发生？？？</span><br>		<span class="hljs-comment">/*	</span><br><span class="hljs-comment">			新的内容，运算符：</span><br><span class="hljs-comment">				instanceof （运行阶段动态判断）</span><br><span class="hljs-comment">			第一：instanceof可以在运行阶段动态判断引用指向的对象的类型。</span><br><span class="hljs-comment">			第二：instanceof的语法：</span><br><span class="hljs-comment">				(引用 instanceof 类型)</span><br><span class="hljs-comment">			第三：instanceof运算符的运算结果只能是：true/false</span><br><span class="hljs-comment">			第四：c是一个引用，c变量保存了内存地址指向了堆中的对象。</span><br><span class="hljs-comment">				假设(c instanceof Cat)为true表示:</span><br><span class="hljs-comment">					c引用指向的堆内存中的java对象是一个Cat。</span><br><span class="hljs-comment">				假设(c instanceof Cat)为false表示:</span><br><span class="hljs-comment">					c引用指向的堆内存中的java对象不是一个Cat。</span><br><span class="hljs-comment">			</span><br><span class="hljs-comment">			程序员要养成一个好习惯：</span><br><span class="hljs-comment">				任何时候，任何地点，对类型进行向下转型时，一定要使用</span><br><span class="hljs-comment">				instanceof 运算符进行判断。（java规范中要求的。）</span><br><span class="hljs-comment">				这样可以很好的避免：ClassCastException</span><br><span class="hljs-comment">		*/</span><br>		System.out.println(a6 <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">//false</span><br><br>		<span class="hljs-keyword">if</span>(a6 <span class="hljs-keyword">instanceof</span> Cat)&#123; <span class="hljs-comment">// 如果a6是一只Cat</span><br>			<span class="hljs-type">Cat</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (Cat)a6;  <span class="hljs-comment">// 再进行强制类型转换</span><br>			y.catchMouse();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h3><p>多种形态，多种状态，编译和运行有两个不同的状态。<br>        编译期叫做静态绑定。<br>        运行期叫做动态绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>		<span class="hljs-comment">// 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法</span><br>		<span class="hljs-comment">// 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关</span><br>		<span class="hljs-comment">// 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。</span><br>		a.move();<br></code></pre></td></tr></table></figure>

<h2 id="多态在开发中的应用（非常重要！！！）"><a href="#多态在开发中的应用（非常重要！！！）" class="headerlink" title="多态在开发中的应用（非常重要！！！）"></a>多态在开发中的应用（非常重要！！！）</h2><p>多态在开发中的作用是：<br>        <strong>降低程序的耦合度，提高程序的扩展力。</strong></p>
<p><strong>代码示例（非常重要！！！！！！！）</strong></p>
<h4 id="Master-java："><a href="#Master-java：" class="headerlink" title="Master.java："></a>Master.java：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 主人类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Master</span>&#123;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	// 假设主人起初的时候只是喜欢养宠物狗狗</span><br><span class="hljs-comment">	// 喂养宠物狗狗</span><br><span class="hljs-comment">	public void feed(Dog d)&#123;</span><br><span class="hljs-comment">		d.eat();</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	// 由于新的需求产生，导致我们“不得不”去修改Master这个类的代码</span><br><span class="hljs-comment">	public void feed(Cat c)&#123;</span><br><span class="hljs-comment">		c.eat();</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">	*/</span><br>	<br>	<span class="hljs-comment">// 能不能让Master主人这个类以后不再修改了。</span><br>	<span class="hljs-comment">// 即使主人又喜欢养其它宠物了，Master也不需要修改。</span><br>	<span class="hljs-comment">// 这个时候就需要使用：多态机制。</span><br>	<span class="hljs-comment">// 最好不要写具体的宠物类型，这样会影响程序的扩展性。</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">feed</span><span class="hljs-params">(Pet pet)</span>&#123; <br>		<span class="hljs-comment">// 编译的时候，编译器发现pet是Pet类，会去Pet类中找eat()方法，结果找到了，编译通过</span><br>		<span class="hljs-comment">// 运行的时候，底层实际的对象是什么，就自动调用到该实际对象对应的eat()方法上。</span><br>		<span class="hljs-comment">// 这就是多态的使用。</span><br>		pet.eat();<br>	&#125;<br><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	注意这里的分析：</span><br><span class="hljs-comment">		主人起初的时候只喜欢养宠物狗狗</span><br><span class="hljs-comment">		随着时间的推移，主人又喜欢上养“猫咪”</span><br><span class="hljs-comment">		在实际的开发中这就表示客户产生了新的需求。</span><br><span class="hljs-comment">		作为软件的开发人员来说，必须满足客户的需求。</span><br><span class="hljs-comment">		我们怎么去满足客户的需求呢？</span><br><span class="hljs-comment">			在不使用多态机制的前提下，目前我们只能在Master类中添加一个新的方法。</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	思考：软件在扩展新需求过程当中，修改Master这个类有什么问题？</span><br><span class="hljs-comment">		一定要记住：软件在扩展过程当中，修改的越少越好。</span><br><span class="hljs-comment">		修改的越多，你的系统当前的稳定性就越差，未知的风险就越多。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		其实这里涉及到一个软件的开发原则：</span><br><span class="hljs-comment">			软件开发原则有七大原则（不属于java，这个开发原则属于整个软件业）：</span><br><span class="hljs-comment">				其中有一条最基本的原则：OCP（开闭原则）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		什么是开闭原则？</span><br><span class="hljs-comment">			对扩展开放（你可以额外添加，没问题），对修改关闭（最好很少的修改现有程序）。</span><br><span class="hljs-comment">			在软件的扩展过程当中，修改的越少越好。</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	高手开发项目不是仅仅为了实现客户的需求，还需要考虑软件的扩展性。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	什么是软件扩展性？</span><br><span class="hljs-comment">		假设电脑中的内存条部件坏了，我们可以买一个新的插上，直接使用。</span><br><span class="hljs-comment">		这个电脑的设计就考虑了“扩展性”。内存条的扩展性很好。</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。</span><br><span class="hljs-comment">	因为面向具体编程会让软件的扩展力很差。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">// 所有宠物的父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span>&#123;<br><br>	<span class="hljs-comment">// 吃的行为（这个方法可以不给具体的实现。）</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>	<br>	&#125;<br><br><br>&#125;<br><br><br><span class="hljs-comment">// 宠物狗狗类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pet</span>&#123;<br>	<span class="hljs-comment">// 吃</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;狗狗喜欢啃骨头，吃的很香。&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pet</span>&#123;<br><br>	<span class="hljs-comment">// 吃</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;猫咪喜欢吃鱼，吃的很香！！！&quot;</span>);<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="Test-java"><a href="#Test-java" class="headerlink" title="Test.java:"></a>Test.java:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	测试多态在开发中的作用</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-comment">// 创建主人对象</span><br>		<span class="hljs-type">Master</span> <span class="hljs-variable">zhangsan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Master</span>();<br>		<span class="hljs-comment">// 创建宠物对象</span><br>		<span class="hljs-type">Dog</span> <span class="hljs-variable">zangAo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>		<span class="hljs-comment">// 主人喂</span><br>		zhangsan.feed(zangAo);<br>		<span class="hljs-comment">// 创建宠物对象</span><br>		<span class="hljs-type">Cat</span> <span class="hljs-variable">xiaoHua</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>		<span class="hljs-comment">// 主人喂</span><br>		zhangsan.feed(xiaoHua);<br>		<span class="hljs-comment">// 创建宠物对象</span><br>		<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h2><p>面向对象的三大特征：<br>封装、继承、多态<br>真的是一环扣一环。</p>
<p>有了封装，有了这种整体的概念之后。<br>        对象和对象之间产生了继承。<br>        有了继承之后，才有了方法的覆盖和多态。</p>
<p>这里提到了一个软件开发原则：<br>        七大原则最基本的原则：OCP（对扩展开放，对修改关闭）<br>        <strong>目的是：降低程序耦合度，提高程序扩展力。<br>        面向抽象编程，不建议面向具体编程。</strong></p>
<p>私有方法无法覆盖。</p>
<p>方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。（这是因为方法覆盖通常和多态联合起来）</p>
<p>总结两句话：<br>        <strong>私有不能覆盖。<br>静态不谈覆盖。</strong></p>
<p>在方法覆盖中，关于方法的返回值类型。<br>        什么条件满足之后，会构成方法的覆盖呢？<br>            1、发生<strong>具有继承关系</strong>的两个类之间。<br>            2、<strong>父类中的方法和子类重写之后的方法</strong>：<strong>具有相同的方法名、相同的形式参数列表、相同的返回值类型</strong>。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/04/29/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%979-java9/">← Next Java学习日志9</a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/04/27/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%977-java7/">Java学习日志7 Prev →</a></div></div></div><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="index">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Oliver Chen</a></h1><div id="description"></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-%E4%B8%8B"><span class="toc-number">1.</span> <span class="toc-text">继承(下)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96"><span class="toc-number">2.</span> <span class="toc-text">方法覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81"><span class="toc-number">3.</span> <span class="toc-text">多态（非常重要!!!)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E3%80%81%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E4%B8%8Einstanceof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">向上转型、向下转型与instanceof运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.</span> <span class="toc-text">多态的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">多态在开发中的应用（非常重要！！！）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Master-java%EF%BC%9A"><span class="toc-number">4.0.1.</span> <span class="toc-text">Master.java：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Test-java"><span class="toc-number">4.0.2.</span> <span class="toc-text">Test.java:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85"><span class="toc-number">5.</span> <span class="toc-text">一些补充</span></a></li></ol></div></div></div><footer><nobr><span class="text-title">ICP</span><a class="text-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">懒得备案</a></nobr><nobr><span class="text-title">©</span><span class="text-content">1970 to 2023</span></nobr><br><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'VXJpDLBtIuAgtIMNqazuy0eY-gzGzoHsz'
 , appKey: 'wzl7lI6VNnLw8deYXvRaTgOc' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>