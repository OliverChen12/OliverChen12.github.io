[{"title":"2022.3.13 周末日志！","url":"/2022/03/13/2022313%20%E5%91%A8%E6%9C%AB%E6%97%A5%E5%BF%97%EF%BC%81-2022313diary/","content":"好几天没写日志了，原因是这个周末实在是过于充实，今早终于抽出时间跟各位分享下快乐周末了！\n这就是4K的力量吗？周五拷给了室友地平线5，在不插电的情况下把画质拉满，分辨率调4K，具体画面如下\n\n可能图片里的画质被压缩了，不过现场看的感觉真的是视听盛宴级别！（虽然只有10fps）微软NB！\n神奇的选修课周六上午去上了GaN老师的选修课《原来如此，如何像科学家一样思考》，真的很有意思！一整个上午我甚至都没掏出来过手机。老师举了很多生动的例子，比如下题：\n如何用四条直线连接以下9个圆？\n\n答案是：\n\n用三条呢？\n答案是：\n\n这简直太发散思维了，有趣！\n老师还讲解了如何正确地，怀疑地对待专家的意见：1.当真正的专家意见一致时，普通人不能毫无疑问地坚持相反的意见；2.当专家的意见不一致时，普通人不能毫无疑问地相信任何一个观点；3.专家都认为没有充分的理由表明正确的意见存在时，普通人最好别轻易下判断。\n老师还送了我们两本书，据说是很有意思的故事型自传，下周抽时间一定会读的!\n\n国际象棋初体验！昨晚和阿远两人下国际象棋，都是第一次下所以是菜鸡互啄，最后我3：1取胜！不过最后吸引到了一位国际象棋大佬，跟我下了一盘。。**完全被虐了&#x2F;(ㄒoㄒ)&#x2F;~~**，还是得多加练习啊！\n\n雨夹雪昨晚从图书馆出来时雪好大！随手拍了一张纪念一下！\n\n后记今天下午去搞年度项目，真的是好充实的周末，可惜不能出校，今天还要去做核酸。。今早看了吉林省新增，一天1412例。。太恐怖了！感觉都快赶上当年的武汉了！愿疫情早日结束吧😫\n\n","categories":["所感"]},{"title":"2022.3.7  日志","url":"/2022/03/07/202237%20%20%E6%97%A5%E5%BF%97-202237diary/","content":"集合论好难！今天集合论学了映射的合成以及一大堆映射的性质。好难！各种映射套来套去的好容易懵掉，满射的那道练习题还完全没有理解，今晚复习下课堂笔记吧。。\n奇怪的决策增加了！上专业解读课之前，听到计算学院的老师说大一下有可能不细分专业（就像20级的前辈一样），等到大二上再进行细分。。这样看来可能又要多卷一个学期了，啊啊😫\n压力↑↑今天听说两个可爱的室友在先修考试中分别过了80和90。。意味着都不用交作业。而且90那位不用参加期中考试。好强！先修课考试的难度可是要大于期末考试的，真的好强！只不过我听了之后感到压力又增添了几分。。&#x2F;(ㄒoㄒ)&#x2F;~~\n意料之外的事（关于Blog）准备上传一些图片作为备图时，突然收到了服务器的警告，说是内存不够用。。看来只能再精挑细选一下才能上传了。\n图书盲盒活动为了下学期一整个学期的图书馆座位，今早真是豁出老命了。学校图书馆新开了个借书活动，每半个月有一期，今天是第一期的第一天，如果参与三期就能获得下学期自选图书馆座位（持续时间一学期）今早上早十之前特意去了趟图书馆，竟然只剩下两本了！！正准备拿一本时意识到没带校园卡！所以我飞奔到寝室取校园卡。当然也飞奔了回来。。还好拿卡去了之后取到了书，不过真的好累。跑完之后差点🤮了出来（还好没吃早饭），不过，这一切是值得的！（还是好缺乏锻炼啊w(ﾟДﾟ)w）\n","categories":["所感"]},{"title":"2022.3.22 日志！","url":"/2022/03/22/2022322%20%E6%97%A5%E5%BF%97%EF%BC%81-2022322%E6%97%A5%E5%BF%97/","content":"好久没更新了，主要还是因为最近好多事情都赶到一块去了，今天抽出点时间（主要还是因为吉吉的不断催更）记录下这周的生活。\n国际象棋！上周末还是跟远远久违地下了国际象棋，感觉还是好难！不过确实很有意思，我俩都是刚刚会规则的那种水平，所以对局就变得更有意思了！\n\n零食！之前在拼爹爹上看到了大减价的百亿补贴零食，一不小心就买了好多。。感觉吃完这些又要胖了QAQ（不过真的很便宜！），这周末准备去跟阿远打羽毛球，还是经常锻炼一下吧！\n\n摔断的笔尖(′д｀ )…彡…彡今天拿pencil写字时手滑掉地上，再捡起来时就已经成这样了。。\n\n无奈只能下单笔尖了。。一次还必须得买4个？！在表白墙上找找拼单吧。希望能找到。。\n\n广告位更新！应某人的要求，广告位终于招到广告啦！（bushi），现在广告位有我和吉吉的直播间哦O(∩_∩)O\n歌曲分享今天spotify给我推了一首《say something》，已经单曲循环一下午+一晚上了，真的很好听，感情深沉且唯美，推荐！\nSay Something\n后记今天差不多就这样，刚刚复习完物理笔记，接下来准备复习物理习题了。不过今晚应该是来不及了，因为还要预习明天的集合论图论和微积分。。不过总的来说，上网课还是很舒服的，至少上食堂吃饭不用排队了O(∩_∩)O，还是希望疫情早点结束，速速解封！\n","categories":["所感"]},{"title":"2022.3.9 日志","url":"/2022/03/09/202239%20%E6%97%A5%E5%BF%97-202239diary/","content":"集合论┭┮﹏┭┮今天的集合论依旧很绕，尤其是可逆映射那里，费了好大的劲才搞懂相关的习题。而且课表上5月中旬集合论图论就会结课，一个月之后才会期末考试，怕不是都要忘光了&#x2F;(ㄒoㄒ)&#x2F;~~\n三星平板，好神奇！\n今天跟室友们尝试了一下hxd硕硕鼠鼠的Tab S8+ Dex模式，我愿称之为最像电脑的平板（说的就是你IPad）其整合了MacOS的启动台，Linux的内核，以及各种Windows上的快捷操作！上面这张要素过多的图就是出自这台平板\n最酷的是它竟然能同时分别运行平板上的系统和外接显示器上的DEX系统！Amazing！\n\n当使用Dex模式留言时，意外的发现竟然被识别成了Linux，好酷！这就是生产力吗？i了i了，反观Ipad外接显示屏后那惨不忍睹的操作方式，三星果然是国际大厂，要是软件生态好一点，芯片（8gen1快爬）好一点就完美了！\n\n上图为卷王室友的桌面屏幕（bushi）\n电脑噪音最近有点大，真的需要去清清灰了，最近抽时间去一趟吧\n寝室周五还可能回去吃浙江菜，期待(☆▽☆)\n","categories":["所感"]},{"title":"2022.3.8 日志","url":"/2022/03/08/202238%20%E6%97%A5%E5%BF%97-202238diary/","content":"电脑关机，准备睡觉之前才突然想起来没写日志，赶快补上！\n今天好快乐！压力清零！今天去泡澡+搓澡+汗蒸啦，和hxd室友们一起去真的很爽！还恰了羊肉串，还进行了奇妙探险！感觉半个月的疲惫都被一扫而空啦！以后每半个月都要去一次！（不是每周一次是因为真的有点贵。。洗澡+搓澡要58块😫）\n分享一首好歌今早在食堂吃饭前刷到的，第一次听的时候眼泪唰地就掉下来了，真的让我想起了之前经历过的种种，而且翠花唱的非常好听！绝对值得收藏！\n《如果》 ——翠花不太翠https://www.bilibili.com/video/BV1sy4y187Vu?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click\n以下为我最喜欢的歌词摘录：\n如果有如果我和你迎面如果有如果告知再下咽那个怯懦的我用尽全力的我这次不会藏躲我想了很多要说如果能有如果是否未来的自己也在后悔现在如我经历的所有选择平淡或起承转合如果没有如果我愿成为你唯一的烛火\n周三，我将如何度过你！明天就是最累的一天——周三！但是今天真的很放松，明天加油吧！\n这回真的应该去睡觉了！各位晚安！！\n","categories":["所感"]},{"title":"JUC—— java线程","url":"/2022/09/16/JUC%E2%80%94%E2%80%94%20java%E7%BA%BF%E7%A8%8B-jucjava-xian-cheng/","content":"java线程3.1 创建和运行线程方法一，直接使用 Thread// 构造方法的参数是给线程指定名字，，推荐给线程起个名字Thread t1 = new Thread(&quot;t1&quot;) &#123; @Override // run 方法内实现了要执行的任务 public void run() &#123; log.debug(&quot;hello&quot;); &#125;&#125;;t1.start();\n\n\n\n方法二，使用 Runnable 配合 Thread把【线程】和【任务】（要执行的代码）分开，Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）Test2.java\n// 创建任务对象Runnable task2 = new Runnable() &#123; @Override public void run() &#123; log.debug(&quot;hello&quot;); &#125;&#125;;// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字Thread t2 = new Thread(task2, &quot;t2&quot;);t2.start();\n\n小结方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。通过查看源码可以发现，方法二其实到底还是通过方法一执行的！\n方法三，FutureTask 配合 ThreadFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况 Test3.java\npublic static void main(String[] args) throws ExecutionException, InterruptedException &#123;    // 实现多线程的第三种方法可以返回数据    FutureTask futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123;        @Override        public Integer call() throws Exception &#123;            log.debug(&quot;多线程任务&quot;);            Thread.sleep(100);            return 100;        &#125;    &#125;);    // 主线程阻塞，同步等待 task 执行完毕的结果    new Thread(futureTask,&quot;我的名字&quot;).start();    log.debug(&quot;主线程&quot;);    log.debug(&quot;&#123;&#125;&quot;,futureTask.get());&#125;\n\nFuture就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。\npublic interface Future&lt;V&gt; &#123;    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;&#125;\n\nFuture提供了三种功能：\n\n判断任务是否完成；\n\n能够中断任务；\n\n能够获取任务执行结果。\n\n\nFutureTask是Future和Runable的实现\n3.2 线程运行原理虚拟机栈与栈帧拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。当java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法\n线程上下文切换（Thread Context Switch）因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码\n\n线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)\n垃圾回收\n有更高优先级的线程需要运行\n线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法\n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的\n3.3 Thread的常见方法\n3.3.1 start 与 run调用startpublic static void main(String[] args) &#123;    Thread thread = new Thread()&#123;      @Override      public void run()&#123;          log.debug(&quot;我是一个新建的线程正在运行中&quot;);          FileReader.read(fileName);      &#125;    &#125;;    thread.setName(&quot;新建线程&quot;);    thread.start();    log.debug(&quot;主线程&quot;);&#125;\n\n输出：程序在 t1 线程运行， run()方法里面内容的调用是异步的 Test4.java\n11:59:40.711 [main] DEBUG com.concurrent.test.Test4 - 主线程11:59:40.711 [新建线程] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中11:59:40.732 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] start ...11:59:40.735 [新建线程] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 3 ms\n\n调用run将上面代码的thread.start();改为 thread.run();输出结果如下：程序仍在 main 线程运行， run()方法里面内容的调用还是同步的\n12:03:46.711 [main] DEBUG com.concurrent.test.Test4 - 我是一个新建的线程正在运行中12:03:46.727 [main] DEBUG com.concurrent.test.FileReader - read [test] start ...12:03:46.729 [main] DEBUG com.concurrent.test.FileReader - read [test] end ... cost: 2 ms12:03:46.730 [main] DEBUG com.concurrent.test.Test4 - 主线程\n\n小结直接调用 run() 是在主线程中执行了 run()，没有启动新的线程使用 start() 是启动新的线程，通过新的线程间接执行 run()方法 中的代码\n3.3.2 sleep 与 yieldsleep\n调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）\n其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 InterruptedException异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】\n睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)\n建议用 TimeUnit 的 sleep() 代替 Thread 的 sleep()来获得更好的可读性\n\nyield\n调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程\n具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)\n\n小结yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线程；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片\n3.3.3 线程优先级线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用\n3.3.4 join在主线程中调用t1.join，则主线程会等待t1线程执行完之后再继续执行 Test10.java\nprivate static void test1() throws InterruptedException &#123;    log.debug(&quot;开始&quot;);    Thread t1 = new Thread(() -&gt; &#123;        log.debug(&quot;开始&quot;);        sleep(1);        log.debug(&quot;结束&quot;);        r = 10;    &#125;,&quot;t1&quot;);    t1.start();    t1.join();    log.debug(&quot;结果为:&#123;&#125;&quot;, r);    log.debug(&quot;结束&quot;);&#125;\n\n\nprivate static void test2() throws InterruptedException &#123;        Thread t1 = new Thread(() -&gt; &#123;            sleep(1);            r1 = 10;        &#125;);        Thread t2 = new Thread(() -&gt; &#123;            sleep(2);            r2 = 20;        &#125;);        t1.start();        t2.start();        long start = System.currentTimeMillis();        log.debug(&quot;join begin&quot;);        t2.join();        log.debug(&quot;t2 join end&quot;);        t1.join();        log.debug(&quot;t1 join end&quot;);        long end = System.currentTimeMillis();        log.debug(&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;, r1, r2, end - start);    &#125;\n\n3.3.5 interrupt 方法详解打断 sleep，wait，join 的线程先了解一些interrupt()方法的相关知识：博客地址\nsleep，wait，join 的线程，这几个方法都会让线程进入阻塞状态，以 sleep 为例Test7.java\npublic static void main(String[] args) throws InterruptedException &#123;    Thread t1 = new Thread() &#123;        @Override        public void run() &#123;            log.debug(&quot;线程任务执行&quot;);            try &#123;                Thread.sleep(10000); // wait, join            &#125; catch (InterruptedException e) &#123;                //e.printStackTrace();                log.debug(&quot;被打断&quot;);            &#125;        &#125;    &#125;;    t1.start();    Thread.sleep(500);    log.debug(&quot;111是否被打断？&#123;&#125;&quot;,t1.isInterrupted());    t1.interrupt();    log.debug(&quot;222是否被打断？&#123;&#125;&quot;,t1.isInterrupted());    Thread.sleep(500);    log.debug(&quot;222是否被打断？&#123;&#125;&quot;,t1.isInterrupted());    log.debug(&quot;主线程&quot;);&#125;\n输出结果：（我下面将中断和打断两个词混用）可以看到，打断 sleep 的线程, 会清空中断状态，刚被中断完之后t1.isInterrupted()的值为true，后来变为false，即中断状态会被清除。那么线程是否被中断过可以通过异常来判断。【同时要注意如果打断被join()，wait() blocked的线程也是一样会被清除，被清除(interrupt status will be cleared)的意思即中断状态设置为false，被设置( interrupt status will be set)的意思就是中断状态设置为true】\n17:06:11.890 [Thread-0] DEBUG com.concurrent.test.Test7 - 线程任务执行17:06:12.387 [main] DEBUG com.concurrent.test.Test7 - 111是否被打断？false17:06:12.390 [Thread-0] DEBUG com.concurrent.test.Test7 - 被打断17:06:12.390 [main] DEBUG com.concurrent.test.Test7 - 222是否被打断？true17:06:12.890 [main] DEBUG com.concurrent.test.Test7 - 222是否被打断？false17:06:12.890 [main] DEBUG com.concurrent.test.Test7 - 主线程\n\n打断正常运行的线程打断正常运行的线程, 线程并不会暂停，只是调用方法Thread.currentThread().isInterrupted();的返回值为true，可以判断Thread.currentThread().isInterrupted();的值来手动停止线程\npublic static void main(String[] args) throws InterruptedException &#123;    Thread t1 = new Thread(() -&gt; &#123;        while(true) &#123;            boolean interrupted = Thread.currentThread().isInterrupted();            if(interrupted) &#123;                log.debug(&quot;被打断了, 退出循环&quot;);                break;            &#125;        &#125;    &#125;, &quot;t1&quot;);    t1.start();    Thread.sleep(1000);    log.debug(&quot;interrupt&quot;);    t1.interrupt();&#125;\n\n终止模式之两阶段终止模式Two Phase Termination，就是考虑在一个线程T1中如何优雅地终止另一个线程T2？这里的优雅指的是给T2一个料理后事的机会（如释放锁）。\n如下所示：那么线程的isInterrupted()方法可以取得线程的打断标记，如果线程在睡眠sleep期间被打断，打断标记是不会变的，为false，但是sleep期间被打断会抛出异常，我们据此手动设置打断标记为true；如果是在程序正常运行期间被打断的，那么打断标记就被自动设置为true。处理好这两种情况那我们就可以放心地来料理后事啦！\n\n代码实现如下：\n@Slf4jpublic class Test11 &#123;    public static void main(String[] args) throws InterruptedException &#123;        TwoParseTermination twoParseTermination = new TwoParseTermination();        twoParseTermination.start();        Thread.sleep(3000);  // 让监控线程执行一会儿        twoParseTermination.stop(); // 停止监控线程    &#125;&#125;@Slf4jclass TwoParseTermination&#123;    Thread thread ;    public void start()&#123;        thread = new Thread(()-&gt;&#123;            while(true)&#123;                if (Thread.currentThread().isInterrupted())&#123;                    log.debug(&quot;线程结束。。正在料理后事中&quot;);                    break;                &#125;                try &#123;                    Thread.sleep(500);                    log.debug(&quot;正在执行监控的功能&quot;);                &#125; catch (InterruptedException e) &#123;                    Thread.currentThread().interrupt();                    e.printStackTrace();                &#125;            &#125;        &#125;);        thread.start();    &#125;    public void stop()&#123;        thread.interrupt();    &#125;&#125;\n\n3.3.6 sleep，yiled，wait，join 对比关于join的原理和这几个方法的对比：看这里\n\n补充：\n\nsleep，join，yield，interrupted是Thread类中的方法\nwait&#x2F;notify是object中的方法\n\nsleep 不释放锁、释放cpujoin 释放锁、抢占cpuyiled 不释放锁、释放cpuwait 释放锁、释放cpu\n\n3.4 守护线程默认情况下，java进程需要等待所有的线程结束后才会停止，但是有一种特殊的线程，叫做守护线程，在其他线程全部结束的时候即使守护线程还未结束代码未执行完java进程也会停止。普通线程t1可以调用t1.setDeamon(true); 方法变成守护线程\n\n注意垃圾回收器线程就是一种守护线程Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求\n\n3.5 线程状态之五种状态五种状态的划分主要是从操作系统的层面进行划分的\n\n\n初始状态，仅仅是在语言层面上创建了线程对象，即Thead thread = new Thead();，还未与操作系统线程关联\n可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行\n运行状态，指线程获取了CPU时间片，正在运行\n当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换\n\n\n阻塞状态\n如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】\n等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】\n与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片\n\n\n终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态\n\n3.6 线程状态之六种状态这是从 Java API 层面来描述的，我们主要研究的就是这种。状态转换详情图：地址根据 Thread.State 枚举，分为六种状态 Test12.java\n\n\nNEW 跟五种状态里的初始状态是一个意思\nRUNNABLE 是当调用了 start() 方法之后的状态，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的【可运行状态】、【运行状态】和【io阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）\nBLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述\n\n","categories":["技术类","JUC学习日志"]},{"title":"JUC——线程与进程","url":"/2022/09/12/JUC%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B-juc-xian-cheng-yu-jin-cheng/","content":"线程与进程2.1 进程与线程进程\n程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令管理内存管理IO的\n当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程\n进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）\n\n线程\n一个进程之内可以分为一到多个线程。\n一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行\nJava 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器（这里感觉要学了计算机组成原理之后会更有感觉吧！）\n\n二者对比进程基本上相互独立的，而线程存在于进程内，是进程的一个子集进程拥有共享的资源，如内存空间等，供其内部的线程共享进程间通信较为复杂同一台计算机的进程通信称为 IPC（Inter-process communication）不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量线程更轻量，线程上下文切换成本一般上要比进程上下文切换低\n2.2 并行与并发并发在单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）\n\n并行多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。\n\n二者对比引用 Rob Pike 的一段描述：并发（concurrent）是同一时间应对（dealing with）多件事情的能力，并行（parallel）是同一时间动手做（doing）多件事情的能力\n\n家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发\n雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行\n家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）\n\n应用同步和异步的概念以调用方的角度讲，如果需要等待结果返回才能继续运行的话就是同步，如果不需要等待就是异步\n1) 设计多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。\n2) 结论\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程\ntomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程\nui 程序中，开线程进行其他操作，避免阻塞 ui 线程\n\n","categories":["技术类","JUC学习日志"]},{"title":"JavaEE——CSS入门","url":"/2022/07/22/JavaEE%E2%80%94%E2%80%94CSS%E5%85%A5%E9%97%A8-javaeecss-ru-men/","content":"什么是CSS，有什么作用？CSS(Cascading Style Sheet):层叠样式表语言。    CSS的作用是：        修饰HTML页面，设置HTML页面中的某些元素的样式，让HTML页面更好看。        CSS好比是HTML的化妆品一样。    HTML还是主体，CSS依赖HTML。CSS的存在就是修饰HTML，所以新建的文件还是xx.html文件。\n在HTML页面中嵌套使用CSS的三种方式：第一种方式：在标签内部使用style属性来设置元素的CSS样式，这种方式称为内联定义方式。语法格式：\n&lt;标签 style=&quot;样式名:样式值;样式名:样式值;样式名:样式值;...&quot;&gt;&lt;/标签&gt;\n\n第二种方式：在head标签中使用style块，这种方式被称为样式块方式。语法格式：\n&lt;head&gt;\t&lt;style type=&quot;text/css&quot;&gt;\t选择器 &#123;\t样式名 : 样式值;\t样式名 : 样式值;\t.....\t&#125;\t选择器 &#123;\t样式名 : 样式值;\t样式名 : 样式值;\t.....\t&#125;\t&lt;/style&gt;&lt;/head&gt;\n\n\n\n第三种方式：链入外部样式表文件，这种方式最常用。（将样式写到一个独立的xxx.css文件当中，在需要的网页上    直接引入css文件，样式就引入了）        语法格式：\n&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;css文件的路径&quot; /&gt;\n\n这种方式易维护，维护成本较低。            xxx.css文件                1.html中引入了                2.html中引入了                3.html中引入了                4.html中引入了\n具体样式设计参考帮助文档即可：http://css.doyoe.com/quicksearch.htm\n","categories":["技术类"]},{"title":"JavaSE——Date类||Number类||随机数||枚举","url":"/2022/08/21/JavaSE%E2%80%94%E2%80%94Date%E7%B1%BBNumber%E7%B1%BB%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9E%9A%E4%B8%BE-javasedate-lei-number-lei--sui-ji-shu--mei-ju/","content":"Date类import java.text.SimpleDateFormat;import java.util.Date;/*java中对日期的处理    这个案例最主要掌握：        知识点1：怎么获取系统当前时间        知识点2：String ---&gt; Date        知识点3：Date ---&gt; String */public class DateTest01 &#123;    public static void main(String[] args) throws Exception &#123;        // 获取系统当前时间（精确到毫秒的系统当前时间）        // 直接调用无参数构造方法就行。        Date nowTime = new Date();        // java.util.Date类的toString()方法已经被重写了。        // 输出的应该不是一个对象的内存地址，应该是一个日期字符串。        //System.out.println(nowTime); //Thu Mar 05 10:51:06 CST 2020        // 日期可以格式化吗？        // 将日期类型Date，按照指定的格式进行转换：Date --转换成具有一定格式的日期字符串--&gt;String        // SimpleDateFormat是java.text包下的。专门负责日期格式化的。        /*        yyyy 年(年是4位)        MM 月（月是2位）        dd 日        HH 时        mm 分        ss 秒        SSS 毫秒（毫秒3位，最高999。1000毫秒代表1秒）        注意：在日期格式中，除了y M d H m s S这些字符不能随便写之外，剩下的符号格式自己随意组织。         */        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);        //SimpleDateFormat sdf = new SimpleDateFormat(&quot;dd/MM/yyyy&quot;);        //SimpleDateFormat sdf = new SimpleDateFormat(&quot;yy/MM/dd HH:mm:ss&quot;);        String nowTimeStr = sdf.format(nowTime);        System.out.println(nowTimeStr);        // 假设现在有一个日期字符串String，怎么转换成Date类型？        // String --&gt; Date        String time = &quot;2008-08-08 08:08:08 888&quot;;        //SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;格式不能随便写，要和日期字符串格式相同&quot;);        // 注意：字符串的日期格式和SimpleDateFormat对象指定的日期格式要一致。不然会出现异常：java.text.ParseException        SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);        Date dateTime = sdf2.parse(time);        System.out.println(dateTime); //Fri Aug 08 08:08:08 CST 2008    &#125;&#125;\n\n利用统计毫秒数计算方法耗时：\n/*获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。1秒 = 1000毫秒简单总结一下System类的相关属性和方法：    System.out 【out是System类的静态变量。】    System.out.println() 【println()方法不是System类的，是PrintStream类的方法。】    System.gc() 建议启动垃圾回收器    System.currentTimeMillis() 获取自1970年1月1日到系统当前时间的总毫秒数。    System.exit(0) 退出JVM。 */public class DateTest02 &#123;    public static void main(String[] args) &#123;        // 获取自1970年1月1日 00:00:00 000到当前系统时间的总毫秒数。        long nowTimeMillis = System.currentTimeMillis();        System.out.println(nowTimeMillis); //1583377912981        // 统计一个方法耗时        // 在调用目标方法之前记录一个毫秒数        long begin = System.currentTimeMillis();        print();        // 在执行完目标方法之后记录一个毫秒数        long end = System.currentTimeMillis();        System.out.println(&quot;耗费时长&quot;+(end - begin)+&quot;毫秒&quot;);    &#125;    // 需求：统计一个方法执行所耗费的时长    public static void print()&#123;        for(int i = 0; i &lt; 1000000000; i++)&#123;            System.out.println(&quot;i = &quot; + i);        &#125;    &#125;&#125;\n\nimport java.text.SimpleDateFormat;import java.util.Date;public class DateTest03 &#123;    public static void main(String[] args) &#123;        // 这个时间是什么时间？        // 1970-01-01 00:00:00 001        Date time = new Date(1); // 注意：参数是一个毫秒        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);        String strTime = sdf.format(time);        // 北京是东8区。差8个小时。        System.out.println(strTime); // 1970-01-01 08:00:00 001        // 获取昨天的此时的时间。        Date time2 = new Date(System.currentTimeMillis() - 1000 * 60 * 60 * 24);        String strTime2 = sdf.format(time2);        System.out.println(strTime2); //2020-03-04 11:44:14 829        // 获取“去年的今天”的时间        // 自己玩。    &#125;&#125;\n\nNumber类数字的格式化import java.text.DecimalFormat;/*关于数字的格式化。（了解） */public class DecimalFormatTest01 &#123;    public static void main(String[] args) &#123;        // java.text.DecimalFormat专门负责数字格式化的。        //DecimalFormat df = new DecimalFormat(&quot;数字格式&quot;);        /*        数字格式有哪些？            # 代表任意数字            , 代表千分位            . 代表小数点            0 代表不够时补0            ###,###.##                表示：加入千分位，保留2个小数。         */        DecimalFormat df = new DecimalFormat(&quot;###,###.##&quot;);        //String s = df.format(1234.56);        String s = df.format(1234.561232);        System.out.println(s); // &quot;1,234.56&quot;        DecimalFormat df2 = new DecimalFormat(&quot;###,###.0000&quot;); //保留4个小数位，不够补上0        String s2 = df2.format(1234.56);        System.out.println(s2); // &quot;1,234.5600&quot;    &#125;&#125;\nBigDecimalimport java.math.BigDecimal;/*1、BigDecimal 属于大数据，精度极高。不属于基本数据类型，属于java对象（引用数据类型）这是SUN提供的一个类。专门用在财务软件当中。2、注意：财务软件中double是不够的。咱们之前有一个学生去用友面试，经理就问了这样一个问题：    你处理过财务数据吗？用的哪一种类型？        千万别说double，说java.math.BigDecimal */public class BigDecimalTest01 &#123;    public static void main(String[] args) &#123;        // 这个100不是普通的100，是精度极高的100        BigDecimal v1 = new BigDecimal(100);        // 精度极高的200        BigDecimal v2 = new BigDecimal(200);        // 求和        // v1 + v2; // 这样不行，v1和v2都是引用，不能直接使用+求和。        BigDecimal v3 = v1.add(v2); // 调用方法求和。        System.out.println(v3); //300        BigDecimal v4 = v2.divide(v1);        System.out.println(v4); // 2    &#125;&#125;\n随机数import java.util.Random;/** * 随机数 */public class RandomTest01 &#123;    public static void main(String[] args) &#123;        // 创建随机数对象        Random random = new Random();        // 随机产生一个int类型取值范围内的数字。        int num1 = random.nextInt();        System.out.println(num1);        // 产生[0~100]之间的随机数。不能产生101。        // nextInt翻译为：下一个int类型的数据是101，表示只能取到100.        int num2 = random.nextInt(101); //不包括101        System.out.println(num2);    &#125;&#125;\n\n枚举1、枚举是一种引用数据类型。    2、枚举编译之后也是class文件。    3、枚举类型怎么定义？        enum 枚举类型名{            枚举值,枚举值2,枚举值3        }    4、当一个方法执行结果超过两种情况，并且是一枚一枚可以列举出来的时候，建议返回值类型设计为枚举类型。\n使用枚举前：\n/*这个案例没有使用java中的枚举，分析以下程序，在设计方面有什么缺陷？    以下代码可以编译，也可以运行。这些都没有问题。    就是设计上你觉得有什么缺陷？ */public class EnumTest01 &#123;    public static void main(String[] args) &#123;        //System.out.println(10 / 0); //java.lang.ArithmeticException: / by zero        /*        int retValue = divide(10, 2);        System.out.println(retValue == 1 ? &quot;计算成功&quot; : &quot;计算失败&quot;); // 1        int retValue2 = divide(10, 0);        System.out.println(retValue2 == 0 ? &quot;计算失败&quot; : &quot;计算成功&quot;); // 0         */        boolean success = divide(10, 0);        System.out.println(success ? &quot;计算成功&quot; : &quot;计算失败&quot;);    &#125;    /**     * 需求（这是设计者说的！）：以下程序，计算两个int类型数据的商，计算成功返回1，计算失败返回0     * @param a int类型的数据     * @param b int类型的数据     * @return 返回1表示成功，返回0表示失败！     */    /*    public static int divide(int a, int b)&#123;        try &#123;            int c = a / b;            // 程序执行到此处表示以上代码没有发生异常。表示执行成功！            return 1;        &#125; catch (Exception e)&#123;            // 程序执行到此处表示以上程序出现了异常！            // 表示执行失败！            return 0;        &#125;    &#125;     */    // 设计缺陷？在这个方法的返回值类型上。返回一个int不恰当。    // 既然最后的结果只是成功和失败，最好使用布尔类型。因为布尔类型true和false正好可以表示两种不同的状态。    /*    public static int divide(int a, int b)&#123;        try &#123;            int c = a / b;            // 返回10已经偏离了需求，实际上已经出错了，但是编译器没有检查出来。            // 我们一直想追求的是：所有的错误尽可能让编译器找出来，所有的错误越早发现越好！            return 10;        &#125; catch (Exception e)&#123;            return 0;        &#125;    &#125;    */    // 这种设计不错。    public static boolean divide(int a, int b)&#123;        try &#123;            int c = a / b;            return true;        &#125; catch (Exception e)&#123;            return false;        &#125;    &#125;    /*    思考：以上的这个方法设计没毛病，挺好，返回true和false表示两种情况，    但是在以后的开发中，有可能遇到一个方法的执行结果可能包括三种情况，    四种情况，五种情况不等，但是每一个都是可以数清楚的，一枚一枚都是可以    列举出来的。这个布尔类型就无法满足需求了。此时需要使用java语言中的    枚举类型。     */&#125;\n\n使用枚举后：\n// 采用枚举的方式改造程序/*总结：    1、枚举是一种引用数据类型    2、枚举类型怎么定义，语法是？        enum 枚举类型名&#123;            枚举值1,枚举值2        &#125;    3、结果只有两种情况的，建议使用布尔类型。    结果超过两种并且还是可以一枚一枚列举出来的，建议使用枚举类型。        例如：颜色、四季、星期等都可以使用枚举类型。 */public class EnumTest02 &#123;    public static void main(String[] args) &#123;        Result r = divide(10, 2);        System.out.println(r == Result.SUCCESS ? &quot;计算成功&quot; : &quot;计算失败&quot;);    &#125;    /**     * 计算两个int类型数据的商。     * @param a int数据     * @param b int数据     * @return Result.SUCCESS表示成功，Result.FAIL表示失败！     */    public static Result divide(int a, int b)&#123;        try &#123;            int c = a / b;            return Result.SUCCESS;        &#125; catch (Exception e)&#123;            return Result.FAIL;        &#125;    &#125;&#125;// 枚举：一枚一枚可以列举出来的，才建议使用枚举类型。// 枚举编译之后也是生成class文件。// 枚举也是一种引用数据类型。// 枚举中的每一个值可以看做是常量。enum Result&#123;    // SUCCESS 是枚举Result类型中的一个值    // FAIL 是枚举Result类型中的一个值    // 枚举中的每一个值，可以看做是“常量”    SUCCESS, FAIL&#125;\n\n多结果使用枚举的示例：\npublic class SwitchTest &#123;    public static void main(String[] args) &#123;        // switch语句支持枚举类型        // switch也支持String、int        // 低版本的JDK，只支持int        // 高版本的JDK，支持int、String、枚举。        // byte short char也可以，因为存在自动类型转换。        switch (Season.SPRING) &#123;            // 必须省略Season.            case SPRING -&gt; System.out.println(&quot;春天&quot;);            case SUMMER -&gt; System.out.println(&quot;夏天&quot;);            case AUTUMN -&gt; System.out.println(&quot;秋天&quot;);            case WINTER -&gt; System.out.println(&quot;冬天&quot;);        &#125;    &#125;&#125;enum Season &#123;    /*    春夏秋冬     */    SPRING, SUMMER, AUTUMN, WINTER&#125;","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——String类||StringBuffer/StringBuilder||八种基本数据类型对应的包装类","url":"/2022/08/20/JavaSE%E2%80%94%E2%80%94String%E7%B1%BBStringBufferStringBuilder%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB-javasestring/","content":"String类对String在内存存储方面的理解：第一：字符串一旦创建不可变。        第二：双引号括起来的字符串存储在字符串常量池中。        第三：字符串的比较必须使用equals方法。        第四：String已经重写了toString()和equals()方法。\nString的构造方法String s = &quot;abc&quot;;\nString s = new String(&quot;abc&quot;);\nString s = new String(byte数组);\nString s = new String(byte数组, 起始下标, 长度);\nString s = new String(char数组);\nString s = new String(char数组, 起始下标, 长度);\n\nString类常用的21个方法public class StringTest05 &#123;    public static void main(String[] args) &#123;        // String类当中常用方法。        //1（掌握）.char charAt(int index)        char c = &quot;中国人&quot;.charAt(1); // &quot;中国人&quot;是一个字符串String对象。只要是对象就能“点.”        System.out.println(c); // 国        // 2（了解）.int compareTo(String anotherString)        // 字符串之间比较大小不能直接使用 &gt; &lt; ，需要使用compareTo方法。        int result = &quot;abc&quot;.compareTo(&quot;abc&quot;);        System.out.println(result); //0（等于0） 前后一致  10 - 10 = 0        int result2 = &quot;abcd&quot;.compareTo(&quot;abce&quot;);        System.out.println(result2); //-1（小于0） 前小后大 8 - 9 = -1                int result3 = &quot;abce&quot;.compareTo(&quot;abcd&quot;);        System.out.println(result3); // 1（大于0） 前大后小 9 - 8 = 1        // 拿着字符串第一个字母和后面字符串的第一个字母比较。能分胜负就不再比较了。        System.out.println(&quot;xyz&quot;.compareTo(&quot;yxz&quot;)); // -1        // 3（掌握）.boolean contains(CharSequence s)        // 判断前面的字符串中是否包含后面的子字符串。        System.out.println(&quot;HelloWorld.java&quot;.contains(&quot;.java&quot;)); // true        System.out.println(&quot;http://www.baidu.com&quot;.contains(&quot;https://&quot;)); // false        // 4（掌握）. boolean endsWith(String suffix)        // 判断当前字符串是否以某个子字符串结尾。        System.out.println(&quot;test.txt&quot;.endsWith(&quot;.java&quot;)); // false        System.out.println(&quot;test.txt&quot;.endsWith(&quot;.txt&quot;)); // true        System.out.println(&quot;fdsajklfhdkjlsahfjkdsahjklfdss&quot;.endsWith(&quot;ss&quot;)); // true        // 5（掌握）.boolean equals(Object anObject)        // 比较两个字符串必须使用equals方法，不能使用“==”        // equals方法有没有调用compareTo方法？ 老版本可以看一下。JDK13中并没有调用compareTo()方法。        // equals只能看出相等不相等。        // compareTo方法可以看出是否相等，并且同时还可以看出谁大谁小。        System.out.println(&quot;abc&quot;.equals(&quot;abc&quot;)); // true        // 6（掌握）.boolean equalsIgnoreCase(String anotherString)        // 判断两个字符串是否相等，并且同时忽略大小写。        System.out.println(&quot;ABc&quot;.equalsIgnoreCase(&quot;abC&quot;)); // true        // 7（掌握）.byte[] getBytes()        // 将字符串对象转换成字节数组        byte[] bytes = &quot;abcdef&quot;.getBytes();        for(int i = 0; i &lt; bytes.length; i++)&#123;            System.out.println(bytes[i]);        &#125;        // 8（掌握）.int indexOf(String str)        // 判断某个子字符串在当前字符串中第一次出现处的索引（下标）。        System.out.println(&quot;oraclejavac++.netc#phppythonjavaoraclec++&quot;.indexOf(&quot;java&quot;)); // 6        // 9（掌握）.boolean isEmpty()        // 判断某个字符串是否为“空字符串”。底层源代码调用的应该是字符串的length()方法。        //String s = &quot;&quot;;        String s = &quot;a&quot;;        System.out.println(s.isEmpty());        // 10（掌握）. int length()        // 面试题：判断数组长度和判断字符串长度不一样        // 判断数组长度是length属性，判断字符串长度是length()方法。        System.out.println(&quot;abc&quot;.length()); // 3        System.out.println(&quot;&quot;.length()); // 0        // 11（掌握）.int lastIndexOf(String str)        // 判断某个子字符串在当前字符串中最后一次出现的索引（下标）        System.out.println(&quot;oraclejavac++javac#phpjavapython&quot;.lastIndexOf(&quot;java&quot;)); //22        // 12（掌握）. String replace(CharSequence target, CharSequence replacement)        // 替换。        // String的父接口就是：CharSequence        String newString = &quot;http://www.baidu.com&quot;.replace(&quot;http://&quot;, &quot;https://&quot;);        System.out.println(newString); //https://www.baidu.com        // 把以下字符串中的“=”替换成“:”        String newString2 = &quot;name=zhangsan&amp;password=123&amp;age=20&quot;.replace(&quot;=&quot;, &quot;:&quot;);        System.out.println(newString2); //name:zhangsan&amp;password:123&amp;age:20        // 13（掌握）.String[] split(String regex)        // 拆分字符串        String[] ymd = &quot;1980-10-11&quot;.split(&quot;-&quot;); //&quot;1980-10-11&quot;以&quot;-&quot;分隔符进行拆分。        for(int i = 0; i &lt; ymd.length; i++)&#123;            System.out.println(ymd[i]);        &#125;        String param = &quot;name=zhangsan&amp;password=123&amp;age=20&quot;;        String[] params = param.split(&quot;&amp;&quot;);        for(int i = 0; i &lt;params.length; i++)&#123;            System.out.println(params[i]);            // 可以继续向下拆分，可以通过“=”拆分。        &#125;        // 14（掌握）、boolean startsWith(String prefix)        // 判断某个字符串是否以某个子字符串开始。        System.out.println(&quot;http://www.baidu.com&quot;.startsWith(&quot;http&quot;)); // true        System.out.println(&quot;http://www.baidu.com&quot;.startsWith(&quot;https&quot;)); // false        // 15（掌握）、 String substring(int beginIndex) 参数是起始下标。        // 截取字符串        System.out.println(&quot;http://www.baidu.com&quot;.substring(7)); //www.baidu.com        // 16（掌握）、String substring(int beginIndex, int endIndex)        // beginIndex起始位置（包括）        // endIndex结束位置（不包括）        System.out.println(&quot;http://www.baidu.com&quot;.substring(7, 10)); //www        // 17(掌握)、char[] toCharArray()        // 将字符串转换成char数组        char[] chars = &quot;我是中国人&quot;.toCharArray();        for(int i = 0; i &lt; chars.length; i++)&#123;            System.out.println(chars[i]);        &#125;        // 18（掌握）、String toLowerCase()        // 转换为小写。        System.out.println(&quot;ABCDefKXyz&quot;.toLowerCase());        // 19（掌握）、String toUpperCase();        System.out.println(&quot;ABCDefKXyz&quot;.toUpperCase());        // 20（掌握）. String trim();        // 去除字符串前后空白        System.out.println(&quot;           hello      world             &quot;.trim());        // 21（掌握）. String中只有一个方法是静态的，不需要new对象        // 这个方法叫做valueOf        // 作用：将“非字符串”转换成“字符串”        //String s1 = String.valueOf(true);        //String s1 = String.valueOf(100);        //String s1 = String.valueOf(3.14);        // 这个静态的valueOf()方法，参数是一个对象的时候，会自动调用该对象的toString()方法吗？        String s1 = String.valueOf(new Customer());        //System.out.println(s1); // 没有重写toString()方法之前是对象内存地址 com.bjpowernode.javase.string.Customer@10f87f48        System.out.println(s1); //我是一个VIP客户！！！！        // 我们是不是可以研究一下println()方法的源代码了？        System.out.println(100);        System.out.println(3.14);        System.out.println(true);        Object obj = new Object();        // 通过源代码可以看出：为什么输出一个引用的时候，会调用toString()方法!!!!        //　本质上System.out.println()这个方法在输出任何数据的时候都是先转换成字符串，再输出。        System.out.println(obj);        System.out.println(new Customer());    &#125;&#125;class Customer &#123;    // 重写toString()方法    @Override    public String toString() &#123;        return &quot;我是一个VIP客户！！！！&quot;;    &#125;&#125;\n\nStringBuffer&#x2F;StringBuilder1、StringBuffer&#x2F;StringBuilder可以看做可变长度字符串。    2、StringBuffer&#x2F;StringBuilder初始化容量16.    3、StringBuffer&#x2F;StringBuilder是完成字符串拼接操作的，方法名：append    4、StringBuffer是线程安全的。StringBuilder是非线程安全的。    5、频繁进行字符串拼接不建议使用“+”\n /** * 如果以后需要进行大量字符串的拼接操作，建议使用JDK中自带的： *      java.lang.StringBuffer *      java.lang.StringBuilder * * 如何优化StringBuffer的性能？ *      在创建StringBuffer的时候尽可能给定一个初始化容量。 *      最好减少底层数组的扩容次数。预估计一下，给一个大一些初始化容量。 *      关键点：给一个合适的初始化容量。可以提高程序的执行效率。 */public class StringBufferTest02 &#123;    public static void main(String[] args) &#123;        // 创建一个初始化容量为16个byte[] 数组。（字符串缓冲区对象）        StringBuffer stringBuffer = new StringBuffer();        // 拼接字符串，以后拼接字符串统一调用 append()方法。        // append是追加的意思。        stringBuffer.append(&quot;a&quot;);        stringBuffer.append(&quot;b&quot;);        stringBuffer.append(&quot;d&quot;);        stringBuffer.append(3.14);        stringBuffer.append(true);        // append方法底层在进行追加的时候，如果byte数组满了，会自动扩容。        stringBuffer.append(100L);        System.out.println(stringBuffer.toString());        // 指定初始化容量的StringBuffer对象（字符串缓冲区对象）        StringBuffer sb = new StringBuffer(100);        sb.append(&quot;hello&quot;);        sb.append(&quot;world&quot;);        sb.append(&quot;hello&quot;);        sb.append(&quot;kitty&quot;);        System.out.println(sb);    &#125;&#125;\n\n/*1、面试题：String为什么是不可变的？    我看过源代码，String类中有一个byte[]数组，这个byte[]数组采用了final修饰，    因为数组一旦创建长度不可变。并且被final修饰的引用一旦指向某个对象之后，不    可再指向其它对象，所以String是不可变的！        &quot;abc&quot; 无法变成 &quot;abcd&quot;2、StringBuilder/StringBuffer为什么是可变的呢？    我看过源代码，StringBuffer/StringBuilder内部实际上是一个byte[]数组，    这个byte[]数组没有被final修饰，StringBuffer/StringBuilder的初始化    容量我记得应该是16，当存满之后会进行扩容，底层调用了数组拷贝的方法    System.arraycopy()...是这样扩容的。所以StringBuilder/StringBuffer    适合于使用字符串的频繁拼接操作。 */public class StringBufferTest04 &#123;    public static void main(String[] args) &#123;        // 字符串不可变是什么意思？        // 是说双引号里面的字符串对象一旦创建不可变。        String s = &quot;abc&quot;; //&quot;abc&quot;放到了字符串常量池当中。&quot;abc&quot;不可变。        // s变量是可以指向其它对象的。        // 字符串不可变不是说以上变量s不可变。说的是&quot;abc&quot;这个对象不可变。        s = &quot;xyz&quot;;//&quot;xyz&quot;放到了字符串常量池当中。&quot;xyz&quot;不可变。    &#125;&#125;\n\n/*java.lang.StringBuilderStringBuffer和StringBuilder的区别？    StringBuffer中的方法都有：synchronized关键字修饰。表示StringBuffer在多线程环境下运行是安全的。    StringBuilder中的方法都没有：synchronized关键字修饰，表示StringBuilder在多线程环境下运行是不安全的。    StringBuffer是线程安全的。    StringBuilder是非线程安全的。     */public class StringBuilderTest01 &#123;    public static void main(String[] args) &#123;        // 使用StringBuilder也是可以完成字符串的拼接。        StringBuilder sb = new StringBuilder();        sb.append(100);        sb.append(true);        sb.append(&quot;hello&quot;);        sb.append(&quot;kitty&quot;);        System.out.println(sb);    &#125;&#125;\n\n八种基本数据类型对应的包装类八种包装类的类名是什么？基本数据类型              包装类型\n-------------------------------------\nbyte                    java.lang.Byte（父类Number）\nshort                   java.lang.Short（父类Number）\nint                     java.lang.Integer（父类Number）\nlong                    java.lang.Long（父类Number）\nfloat                   java.lang.Float（父类Number）\ndouble                  java.lang.Double（父类Number）\nboolean                 java.lang.Boolean（父类Object）\nchar                    java.lang.Character（父类Object）\n\n以上八种包装类中，重点以java.lang.Integer为代表进行学习，其它的类型照葫芦画瓢就行。\n什么是自动装箱和自动拆箱，代码怎么写？// 通过访问包装类的常量，来获取最大值和最小值System.out.println(&quot;int的最大值：&quot; + Integer.MAX_VALUE);System.out.println(&quot;int的最小值：&quot; + Integer.MIN_VALUE);System.out.println(&quot;byte的最大值：&quot; + Byte.MAX_VALUE);System.out.println(&quot;byte的最小值：&quot; + Byte.MIN_VALUE);/** * 好消息：在java5之后，引入了一种新特性，自动装箱和自动拆箱 *  自动装箱：基本数据类型自动转换成包装类。 *  自动拆箱：包装类自动转换成基本数据类型。 * * 有了自动拆箱之后，Number类中的方法就用不着了！ * * 自动装箱和自动拆箱的好处？ *      方便编程。 */public class IntegerTest05 &#123;    public static void main(String[] args) &#123;        // 900是基本数据类型        // x是包装类型        // 基本数据类型 --(自动转换)--&gt; 包装类型：自动装箱        Integer x = 900;        System.out.println(x);        // x是包装类型        // y是基本数据类型        // 包装类型 --(自动转换)--&gt; 基本数据类型：自动拆箱        int y = x;        System.out.println(y);        // z是一个引用，z是一个变量，z还是保存了一个对象的内存地址。        Integer z = 1000; // 等同于：Integer z = new Integer(1000);        // 分析为什么这个没有报错呢？        // +两边要求是基本数据类型的数字，z是包装类，不属于基本数据类型，这里会进行自动拆箱。将z转换成基本数据类型        // 在java5之前你这样写肯定编译器报错。        System.out.println(z + 1);        Integer a = 1000; // Integer a = new Integer(1000); a是个引用，保存内存地址指向对象。        Integer b = 1000; // Integer b = new Integer(1000); b是个引用，保存内存地址指向对象。        // == 比较的是对象的内存地址，a和b两个引用中保存的对象内存地址不同。        // == 这个运算符不会触发自动拆箱机制。（只有+ - * /等运算的时候才会。）        System.out.println(a == b); //false    &#125;&#125;\n\npackage com.bjpowernode.javase.integer;/*这个题目是Integer非常重要的面试题。 */public class IntegerTest06 &#123;    public static void main(String[] args) &#123;        Integer a = 128;        Integer b = 128;        System.out.println(a == b); //false        /*        java中为了提高程序的执行效率，将[-128到127]之间所有的包装对象提前创建好，        放到了一个方法区的“整数型常量池”当中了，目的是只要用这个区间的数据不需要        再new了，直接从整数型常量池当中取出来。        原理：x变量中保存的对象的内存地址和y变量中保存的对象的内存地址是一样的。         */        Integer x = 127;        Integer y = 127;        // == 永远判断的都是两个对象的内存地址是否相同。        System.out.println(x == y); //true    &#125;&#125;\n\nInteger类常用方法Integer.valueOf()        Integer.parseInt(“123”)        Integer.parseInt(“中文”) : NumberFormatException\nimport jdk.swing.interop.SwingInterOpUtils;/*总结一下之前所学的经典异常？    空指针异常：NullPointerException    类型转换异常：ClassCastException    数组下标越界异常：ArrayIndexOutOfBoundsException    数字格式化异常：NumberFormatExceptionInteger类当中有哪些常用的方法呢？ */public class IntegerTest07 &#123;    public static void main(String[] args) &#123;        // 手动装箱        Integer x = new Integer(1000);        // 手动拆箱。        int y = x.intValue();        System.out.println(y);        Integer a = new Integer(&quot;123&quot;);        // 编译的时候没问题，一切符合java语法，运行时会不会出问题呢？        // 不是一个“数字”可以包装成Integer吗？不能。运行时出现异常。        // java.lang.NumberFormatException        //Integer a = new Integer(&quot;中文&quot;);        // 重点方法        // static int parseInt(String s)        // 静态方法，传参String，返回int        //网页上文本框中输入的100实际上是&quot;100&quot;字符串。后台数据库中要求存储100数字，此时java程序需要将&quot;100&quot;转换成100数字。        int retValue = Integer.parseInt(&quot;123&quot;); // String -转换-&gt; int        //int retValue = Integer.parseInt(&quot;中文&quot;); // NumberFormatException        System.out.println(retValue + 100);        // 照葫芦画瓢        double retValue2 = Double.parseDouble(&quot;3.14&quot;);        System.out.println(retValue2 + 1); //4.140000000000001（精度问题）        float retValue3 = Float.parseFloat(&quot;1.0&quot;);        System.out.println(retValue3 + 1); //2.0        // -----------------------------------以下内容作为了解，不需要掌握---------------------------------------        // static String toBinaryString(int i)        // 静态的：将十进制转换成二进制字符串。        String binaryString = Integer.toBinaryString(3);        System.out.println(binaryString); //&quot;11&quot; 二进制字符串        // static String toHexString(int i)        // 静态的：将十进制转换成十六进制字符串。        String hexString = Integer.toHexString(16);        System.out.println(hexString); // &quot;10&quot;        // 十六进制：1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 17 18 19 1a        hexString = Integer.toHexString(17);        System.out.println(hexString); // &quot;11&quot;        //static String toOctalString(int i)        // 静态的：将十进制转换成八进制字符串。        String octalString = Integer.toOctalString(8);        System.out.println(octalString); // &quot;10&quot;        System.out.println(new Object()); //java.lang.Object@6e8cf4c6        // valueOf方法作为了解        //static Integer valueOf(int i)        // 静态的：int--&gt;Integer        Integer i1 = Integer.valueOf(100);        System.out.println(i1);        // static Integer valueOf(String s)        // 静态的：String--&gt;Integer        Integer i2 = Integer.valueOf(&quot;100&quot;);        System.out.println(i2);    &#125;&#125;\n\nInteger String int三种类型互相转换/** * String int Integer之间互相转换 */public class IntegerTest08 &#123;    public static void main(String[] args) &#123;        // String --&gt; int        int i1 = Integer.parseInt(&quot;100&quot;); // i1是100数字        System.out.println(i1 + 1); // 101        // int --&gt; String        String s2 = i1 + &quot;&quot;; // &quot;100&quot;字符串        System.out.println(s2 + 1); // &quot;1001&quot;        // int --&gt; Integer        // 自动装箱        Integer x = 1000;        // Integer --&gt; int        // 自动拆箱        int y = x;        // String --&gt; Integer        Integer k = Integer.valueOf(&quot;123&quot;);        // Integer --&gt; String        String e = String.valueOf(k);    &#125;&#125;\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——IO流","url":"/2022/09/08/JavaSE%E2%80%94%E2%80%94IO%E6%B5%81-javaseio/","content":"什么是IO流I : InputO : Output通过IO可以完成硬盘文件的读和写。  \n\nIO流的分类有多种分类方式：\n一种方式是按照流的方向进行分类：以内存作为参照物，往内存中去，叫做输入(Input)。或者叫做读(Read)。从内存中出来，叫做输出(Output)。或者叫做写(Write)。\n另一种方式是按照读取数据方式不同进行分类：有的流是按照字节的方式读取数据，一次读取1个字节byte，等同于一次读取8个二进制位。这种流是万能的，什么类型的文件都可以读取。包括：文本文件，图片，声音文件，视频文件等….假设文件file1.txt，采用字节流的话是这样读的：a中国bc张三fe第一次读：一个字节，正好读到’a’第二次读：一个字节，正好读到’中’字符的一半。第三次读：一个字节，正好读到’中’字符的另外一半。  \n有的流是按照字符的方式读取数据的，一次读取一个字符，这种流是为了方便读取普通文本文件而存在的，这种流不能读取：图片、声音、视频等文件。只能读取纯文本文件，连word文件都无法读取。假设文件file1.txt，采用字符流的话是这样读的：a中国bc张三fe第一次读：’a’字符（’a’字符在windows系统中占用1个字节。）第二次读：’中’字符（’中’字符在windows系统中占用2个字节。）  \n综上所述：流的分类输入流、输出流字节流、字符流\nIO流如何学习？Java中的IO流都已经写好了，我们程序员不需要关心,我们最主要还是掌握，在java中已经提供了哪些流，每个流的特点是什么，每个流对象上的常用方法有哪些？？？？java中所有的流都是在：java.io.*;下。  \njava中主要还是研究：        怎么new流对象。        调用流对象的哪个方法是读，哪个方法是写。\njava IO流的四大家族四大家族的首领： \njava.io.InputStream  字节输入流\njava.io.OutputStream 字节输出流\njava.io.Reader\t\t字符输入流\njava.io.Writer\t\t字符输出流\n四大家族的首领都是抽象类。(abstract class)\n注意：在java中只要“类名”以Stream结尾的都是字节流。以“Reader&#x2F;Writer”结尾的都是字符流。\n所有的流都实现了：java.io.Closeable接口，都是可关闭的，都有close()方法。流毕竟是一个管道，这个是内存和硬盘之间的通道，用完之后一定要关闭，不然会耗费(占用)很多资源。养成好习惯，用完流一定要关闭。  \n所有的输出流都实现了：            java.io.Flushable接口，都是可刷新的，都有flush()方法。            养成一个好习惯，输出流在最终输出之后，一定要记得flush()            刷新一下。这个刷新表示将通道&#x2F;管道当中剩余未输出的数据            强行输出完（清空管道！）刷新的作用就是清空管道。注意：如果没有flush()可能会导致丢失数据。  \n需要掌握的IO流文件专属：java.io.FileInputStream（掌握）java.io.FileOutputStream（掌握）java.io.FileReaderjava.io.FileWriter  \n转换流：（将字节流转换成字符流）        java.io.InputStreamReader        java.io.OutputStreamWriter  \n缓冲流专属：        java.io.BufferedReader        java.io.BufferedWriter        java.io.BufferedInputStream        java.io.BufferedOutputStream\n数据流专属：        java.io.DataInputStream        java.io.DataOutputStream\n标准输出流：        java.io.PrintWriter        java.io.PrintStream（掌握）\n对象专属流：        java.io.ObjectInputStream（掌握）        java.io.ObjectOutputStream（掌握）\njava.io.FileInputStream:1、文件字节输入流，万能的，任何类型的文件都可以采用这个流来读。2、字节的方式，完成输入的操作，完成读的操作（硬盘—&gt; 内存）\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileInputStreamTest01 &#123;\tpublic static void main(String[] args) &#123;\t\tFileInputStream fis = null;\t\ttry &#123;\t\t\t// 创建文件字节输入流对象\t\t\t// 文件路径：D:\\course\\JavaProjects\\02-JavaSE\\temp （IDEA会自动把\\编程\\\\，因为java中\\表示转义）\t\t\t// 以下都是采用了：绝对路径的方式。\t\t\t//FileInputStream fis = new FileInputStream(&quot;D:\\\\course\\\\JavaProjects\\\\02-JavaSE\\\\temp&quot;);\t\t\t// 写成这个/也是可以的。\t\t\tfis = new FileInputStream(&quot;D:/course/JavaProjects/02-JavaSE/temp&quot;);\t\t\t// 开始读\t\t\tint readData = fis.read(); // 这个方法的返回值是：读取到的“字节”本身。\t\t\tSystem.out.println(readData); //97\t\t\treadData = fis.read();\t\t\tSystem.out.println(readData); //98\t\t\treadData = fis.read();\t\t\tSystem.out.println(readData); //99\t\t\treadData = fis.read();\t\t\tSystem.out.println(readData); //100\t\t\treadData = fis.read();\t\t\tSystem.out.println(readData); //101\t\t\treadData = fis.read();\t\t\tSystem.out.println(readData); //102\t\t\t// 已经读到文件的末尾了，再读的时候读取不到任何数据，返回-1.\t\t\treadData = fis.read();\t\t\tSystem.out.println(readData);\t\t\treadData = fis.read();\t\t\tSystem.out.println(readData);\t\t\treadData = fis.read();\t\t\tSystem.out.println(readData);\t\t&#125; catch (FileNotFoundException e) &#123;\t\t\te.printStackTrace();\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\t// 在finally语句块当中确保流一定关闭。\t\t\tif (fis != null) &#123; // 避免空指针异常！\t\t\t\t// 关闭流的前提是：流不是空。流是null的时候没必要关闭。\t\t\t\ttry &#123;\t\t\t\t\tfis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n改进版：\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/*对第一个程序进行改进。循环方式。分析这个程序的缺点：    一次读取一个字节byte，这样内存和硬盘交互太频繁，基本上时间/资源都耗费    在交互上面了。能不能一次读取多个字节呢？可以。 */public class FileInputStreamTest02 &#123;    public static void main(String[] args) &#123;        FileInputStream fis = null;        try &#123;            fis = new FileInputStream(&quot;D:\\\\course\\\\JavaProjects\\\\02-JavaSE\\\\temp&quot;);            /*while(true) &#123;                int readData = fis.read();                if(readData == -1) &#123;                    break;                &#125;                System.out.println(readData);            &#125;*/            // 改造while循环            int readData = 0;            while((readData = fis.read()) != -1)&#123;                System.out.println(readData);            &#125;        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (fis != null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n int read(byte[] data)一次最多读取 b.length 个字节。减少硬盘和内存的交互，提高程序的执行效率。往byte[]数组当中读。\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class FileInputStreamTest03 &#123;\tpublic static void main(String[] args) &#123;\t\tFileInputStream fis = null;\t\ttry &#123;\t\t\t// 相对路径的话呢？相对路径一定是从当前所在的位置作为起点开始找！\t\t\t// IDEA默认的当前路径是哪里？工程Project的根就是IDEA的默认当前路径。\t\t\t//fis = new FileInputStream(&quot;tempfile3&quot;);\t\t\t//fis = new FileInputStream(&quot;chapter23/tempfile2&quot;);\t\t\t//fis = new FileInputStream(&quot;chapter23/src/tempfile3&quot;);\t\t\tfis = new FileInputStream(&quot;chapter23/src/com/bjpowernode/java/io/tempfile4&quot;);\t\t\t// 开始读，采用byte数组，一次读取多个字节。最多读取“数组.length”个字节。\t\t\tbyte[] bytes = new byte[4]; // 准备一个4个长度的byte数组，一次最多读取4个字节。\t\t\t// 这个方法的返回值是：读取到的字节数量。（不是字节本身）\t\t\tint readCount = fis.read(bytes);\t\t\tSystem.out.println(readCount); // 第一次读到了4个字节。\t\t\t// 将字节数组全部转换成字符串\t\t\t//System.out.println(new String(bytes)); // abcd\t\t\t// 不应该全部都转换，应该是读取了多少个字节，转换多少个。\t\t\tSystem.out.println(new String(bytes,0, readCount));\t\t\treadCount = fis.read(bytes); // 第二次只能读取到2个字节。\t\t\tSystem.out.println(readCount); // 2\t\t\t// 将字节数组全部转换成字符串\t\t\t//System.out.println(new String(bytes)); // efcd\t\t\t// 不应该全部都转换，应该是读取了多少个字节，转换多少个。\t\t\tSystem.out.println(new String(bytes,0, readCount));\t\t\treadCount = fis.read(bytes); // 1个字节都没有读取到返回-1\t\t\tSystem.out.println(readCount); // -1\t\t&#125; catch (FileNotFoundException e) &#123;\t\t\te.printStackTrace();\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (fis != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tfis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n最终版：\nimport java.io.FileInputStream;import java.io.IOException;/*最终版，需要掌握。 */public class FileInputStreamTest04 &#123;\tpublic static void main(String[] args) &#123;\t\tFileInputStream fis = null;\t\ttry &#123;\t\t\tfis = new FileInputStream(&quot;chapter23/src/tempfile3&quot;);\t\t\t// 准备一个byte数组\t\t\tbyte[] bytes = new byte[4];            /*while(true)&#123;                int readCount = fis.read(bytes);                if(readCount == -1)&#123;                    break;                &#125;                // 把byte数组转换成字符串，读到多少个转换多少个。                System.out.print(new String(bytes, 0, readCount));            &#125;*/\t\t\tint readCount;\t\t\twhile((readCount = fis.read(bytes)) != -1) &#123;\t\t\t\tSystem.out.print(new String(bytes, 0, readCount));\t\t\t&#125;\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (fis != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tfis.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n其他方法：\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/*FileInputStream类的其它常用方法：    int available()：返回流当中剩余的没有读到的字节数量    long skip(long n)：跳过几个字节不读。 */public class FileInputStreamTest05 &#123;    public static void main(String[] args) &#123;        FileInputStream fis = null;        try &#123;            fis = new FileInputStream(&quot;tempfile&quot;);            System.out.println(&quot;总字节数量：&quot; + fis.available());            // 读1个字节            //int readByte = fis.read();            // 还剩下可以读的字节数量是：5            //System.out.println(&quot;剩下多少个字节没有读：&quot; + fis.available());            // 这个方法有什么用？            //byte[] bytes = new byte[fis.available()]; // 这种方式不太适合太大的文件，因为byte[]数组不能太大。            // 不需要循环了。            // 直接读一次就行了。            //int readCount = fis.read(bytes); // 6            //System.out.println(new String(bytes)); // abcdef            // skip跳过几个字节不读取，这个方法也可能以后会用！            fis.skip(3);            System.out.println(fis.read()); //100        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (fis != null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\njava.io.FileOutputStreamimport java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/** * 文件字节输出流，负责写。 * 从内存到硬盘。 */public class FileOutputStreamTest01 &#123;    public static void main(String[] args) &#123;        FileOutputStream fos = null;        try &#123;            // myfile文件不存在的时候会自动新建！            // 这种方式谨慎使用，这种方式会先将原文件清空，然后重新写入。            //fos = new FileOutputStream(&quot;myfile&quot;);            //fos = new FileOutputStream(&quot;chapter23/src/tempfile3&quot;);            // 以追加的方式在文件末尾写入。不会清空原文件内容。            fos = new FileOutputStream(&quot;chapter23/src/tempfile3&quot;, true);            // 开始写。            byte[] bytes = &#123;97, 98, 99, 100&#125;;            // 将byte数组全部写出！            fos.write(bytes); // abcd            // 将byte数组的一部分写出！            fos.write(bytes, 0, 2); // 再写出ab            // 字符串            String s = &quot;我是一个中国人，我骄傲！！！&quot;;            // 将字符串转换成byte数组。            byte[] bs = s.getBytes();            // 写            fos.write(bs);            // 写完之后，最后一定要刷新            fos.flush();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (fos != null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\n文件的复制原理\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/*使用FileInputStream + FileOutputStream完成文件的拷贝。拷贝的过程应该是一边读，一边写。使用以上的字节流拷贝文件的时候，文件类型随意，万能的。什么样的文件都能拷贝。 */public class Copy01 &#123;    public static void main(String[] args) &#123;        FileInputStream fis = null;        FileOutputStream fos = null;        try &#123;            // 创建一个输入流对象            fis = new FileInputStream(&quot;D:\\\\course\\\\02-JavaSE\\\\video\\\\chapter01\\\\动力节点-JavaSE-杜聚宾-001-文件扩展名的显示.avi&quot;);            // 创建一个输出流对象            fos = new FileOutputStream(&quot;C:\\\\动力节点-JavaSE-杜聚宾-001-文件扩展名的显示.avi&quot;);            // 最核心的：一边读，一边写            byte[] bytes = new byte[1024 * 1024]; // 1MB（一次最多拷贝1MB。）            int readCount = 0;            while((readCount = fis.read(bytes)) != -1) &#123;                fos.write(bytes, 0, readCount);            &#125;            // 刷新，输出流最后要刷新            fos.flush();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            // 分开try，不要一起try。            // 一起try的时候，其中一个出现异常，可能会影响到另一个流的关闭。            if (fos != null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (fis != null) &#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\njava.io.FileReader文件字符输入流，只能读取普通文本。读取文本内容时，比较方便，快捷。\nimport java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class FileReaderTest &#123;\tpublic static void main(String[] args) &#123;\t\tFileReader reader = null;\t\ttry &#123;\t\t\t// 创建文件字符输入流\t\t\treader = new FileReader(&quot;tempfile&quot;);\t\t\t//准备一个char数组\t\t\tchar[] chars = new char[4];\t\t\t// 往char数组中读\t\t\treader.read(chars); // 按照字符的方式读取：第一次e，第二次f，第三次 风....\t\t\tfor(char c : chars) &#123;\t\t\t\tSystem.out.println(c);\t\t\t&#125;            /*// 开始读            char[] chars = new char[4]; // 一次读取4个字符            int readCount = 0;            while((readCount = reader.read(chars)) != -1) &#123;                System.out.print(new String(chars,0,readCount));            &#125;*/\t\t&#125; catch (FileNotFoundException e) &#123;\t\t\te.printStackTrace();\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (reader != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\treader.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\njava.io.FileWriter文件字符输出流。写。只能输出普通文本。\nimport java.io.FileWriter;import java.io.IOException;public class FileWriterTest &#123;\tpublic static void main(String[] args) &#123;\t\tFileWriter out = null;\t\ttry &#123;\t\t\t// 创建文件字符输出流对象\t\t\t//out = new FileWriter(&quot;file&quot;);\t\t\tout = new FileWriter(&quot;file&quot;, true);\t\t\t// 开始写。\t\t\tchar[] chars = &#123;&#x27;我&#x27;,&#x27;是&#x27;,&#x27;中&#x27;,&#x27;国&#x27;,&#x27;人&#x27;&#125;;\t\t\tout.write(chars);\t\t\tout.write(chars, 2, 3);\t\t\tout.write(&quot;我是一名java软件工程师！&quot;);\t\t\t// 写出一个换行符。\t\t\tout.write(&quot;\\n&quot;);\t\t\tout.write(&quot;hello world!&quot;);\t\t\t// 刷新\t\t\tout.flush();\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125; finally &#123;\t\t\tif (out != null) &#123;\t\t\t\ttry &#123;\t\t\t\t\tout.close();\t\t\t\t&#125; catch (IOException e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\nimport java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/*使用FileReader FileWriter进行拷贝的话，只能拷贝“普通文本”文件。 */public class Copy02 &#123;    public static void main(String[] args) &#123;        FileReader in = null;        FileWriter out = null;        try &#123;            // 读            in = new FileReader(&quot;chapter23/src/com/bjpowernode/java/io/Copy02.java&quot;);            // 写            out = new FileWriter(&quot;Copy02.java&quot;);            // 一边读一边写：            char[] chars = new char[1024 * 512]; // 1MB            int readCount = 0;            while((readCount = in.read(chars)) != -1)&#123;                out.write(chars, 0, readCount);            &#125;            // 刷新            out.flush();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (in != null) &#123;                try &#123;                    in.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (out != null) &#123;                try &#123;                    out.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\njava.io.BufferedReader带有缓冲区的字符输入流。使用这个流的时候不需要自定义char数组，或者说不需要自定义byte数组。自带缓冲。\nimport java.io.BufferedReader;import java.io.FileReader;public class BufferedReaderTest01 &#123;\tpublic static void main(String[] args) throws Exception&#123;\t\tFileReader reader = new FileReader(&quot;Copy02.java&quot;);\t\t// 当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流。\t\t// 外部负责包装的这个流，叫做：包装流，还有一个名字叫做：处理流。\t\t// 像当前这个程序来说：FileReader就是一个节点流。BufferedReader就是包装流/处理流。\t\tBufferedReader br = new BufferedReader(reader);\t\t// 读一行        /*String firstLine = br.readLine();        System.out.println(firstLine);        String secondLine = br.readLine();        System.out.println(secondLine);        String line3 = br.readLine();        System.out.println(line3);*/\t\t// br.readLine()方法读取一个文本行，但不带换行符。\t\tString s = null;\t\twhile((s = br.readLine()) != null)&#123;\t\t\tSystem.out.print(s);\t\t&#125;\t\t// 关闭流\t\t// 对于包装流来说，只需要关闭最外层流就行，里面的节点流会自动关闭。（可以看源代码。）\t\tbr.close();\t&#125;&#125;\n\njava.io.InputStreamReaderimport java.io.BufferedReader;import java.io.FileInputStream;import java.io.InputStream;import java.io.InputStreamReader;/*    转换流：InputStreamReader */public class BufferedReaderTest02 &#123;    public static void main(String[] args) throws Exception&#123;        /*// 字节流        FileInputStream in = new FileInputStream(&quot;Copy02.java&quot;);        // 通过转换流转换（InputStreamReader将字节流转换成字符流。）        // in是节点流。reader是包装流。        InputStreamReader reader = new InputStreamReader(in);        // 这个构造方法只能传一个字符流。不能传字节流。        // reader是节点流。br是包装流。        BufferedReader br = new BufferedReader(reader);*/        // 合并        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;Copy02.java&quot;)));        String line = null;        while((line = br.readLine()) != null)&#123;            System.out.println(line);        &#125;        // 关闭最外层        br.close();    &#125;&#125;\n\njava.io.BufferedWriterimport java.io.BufferedWriter;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.OutputStreamWriter;/*BufferedWriter：带有缓冲的字符输出流。OutputStreamWriter：转换流 */public class BufferedWriterTest &#123;    public static void main(String[] args) throws Exception&#123;        // 带有缓冲区的字符输出流        //BufferedWriter out = new BufferedWriter(new FileWriter(&quot;copy&quot;));        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;copy&quot;, true)));        // 开始写。        out.write(&quot;hello world!&quot;);        out.write(&quot;\\n&quot;);        out.write(&quot;hello kitty!&quot;);        // 刷新        out.flush();        // 关闭最外层        out.close();    &#125;&#125;\n\njava.io.DataOutputStreamjava.io.DataOutputStream：数据专属的流。这个流可以将数据连同数据的类型一并写入文件。注意：这个文件不是普通文本文档。（这个文件使用记事本打不开。）\nimport java.io.DataOutputStream;import java.io.FileOutputStream;public class DataOutputStreamTest &#123;\tpublic static void main(String[] args) throws Exception&#123;\t\t// 创建数据专属的字节输出流\t\tDataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;data&quot;));\t\t// 写数据\t\tbyte b = 100;\t\tshort s = 200;\t\tint i = 300;\t\tlong l = 400L;\t\tfloat f = 3.0F;\t\tdouble d = 3.14;\t\tboolean sex = false;\t\tchar c = &#x27;a&#x27;;\t\t// 写\t\tdos.writeByte(b); // 把数据以及数据的类型一并写入到文件当中。\t\tdos.writeShort(s);\t\tdos.writeInt(i);\t\tdos.writeLong(l);\t\tdos.writeFloat(f);\t\tdos.writeDouble(d);\t\tdos.writeBoolean(sex);\t\tdos.writeChar(c);\t\t// 刷新\t\tdos.flush();\t\t// 关闭最外层\t\tdos.close();\t&#125;&#125;\n\njava.io.DataInputStreamDataInputStream:数据字节输入流。DataOutputStream写的文件，只能使用DataInputStream去读。并且读的时候你需要提前知道写入的顺序。读的顺序需要和写的顺序一致。才可以正常取出数据。\nimport java.io.DataInputStream;import java.io.FileInputStream;public class DataInputStreamTest01 &#123;    public static void main(String[] args) throws Exception&#123;        DataInputStream dis = new DataInputStream(new FileInputStream(&quot;data&quot;));        // 开始读        byte b = dis.readByte();        short s = dis.readShort();        int i = dis.readInt();        long l = dis.readLong();        float f = dis.readFloat();        double d = dis.readDouble();        boolean sex = dis.readBoolean();        char c = dis.readChar();        System.out.println(b);        System.out.println(s);        System.out.println(i + 1000);        System.out.println(l);        System.out.println(f);        System.out.println(d);        System.out.println(sex);        System.out.println(c);        dis.close();    &#125;&#125;\n\n\njava.io.PrintStreamjava.io.PrintStream：标准的字节输出流。默认输出到控制台。\nimport java.io.FileOutputStream;import java.io.PrintStream;/*java.io.PrintStream：标准的字节输出流。默认输出到控制台。 */public class PrintStreamTest &#123;    public static void main(String[] args) throws Exception&#123;        // 联合起来写        System.out.println(&quot;hello world!&quot;);        // 分开写        PrintStream ps = System.out;        ps.println(&quot;hello zhangsan&quot;);        ps.println(&quot;hello lisi&quot;);        ps.println(&quot;hello wangwu&quot;);        // 标准输出流不需要手动close()关闭。        // 可以改变标准输出流的输出方向吗？ 可以        /*        // 这些是之前System类使用过的方法和属性。        System.gc();        System.currentTimeMillis();        PrintStream ps2 = System.out;        System.exit(0);        System.arraycopy(....);         */        // 标准输出流不再指向控制台，指向“log”文件。        PrintStream printStream = new PrintStream(new FileOutputStream(&quot;log&quot;));        // 修改输出方向，将输出方向修改到&quot;log&quot;文件。        System.setOut(printStream);        // 再输出        System.out.println(&quot;hello world&quot;);        System.out.println(&quot;hello kitty&quot;);        System.out.println(&quot;hello zhangsan&quot;);    &#125;&#125;\n\n利用标准输出流编写日志工具：Logger.java:\nimport java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.PrintStream;import java.text.SimpleDateFormat;import java.util.Date;/*日志工具 */public class Logger &#123;    /*    记录日志的方法。     */    public static void log(String msg) &#123;        try &#123;            // 指向一个日志文件            PrintStream out = new PrintStream(new FileOutputStream(&quot;log.txt&quot;, true));            // 改变输出方向            System.setOut(out);            // 日期当前时间            Date nowTime = new Date();            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);            String strTime = sdf.format(nowTime);            System.out.println(strTime + &quot;: &quot; + msg);        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\nLogTest.java：\npublic class LogTest &#123;    public static void main(String[] args) &#123;        //测试工具类是否好用        Logger.log(&quot;调用了System类的gc()方法，建议启动垃圾回收&quot;);        Logger.log(&quot;调用了UserService的doSome()方法&quot;);        Logger.log(&quot;用户尝试进行登录，验证失败&quot;);        Logger.log(&quot;我非常喜欢这个记录日志的工具哦！&quot;);    &#125;&#125;\n\nFile类1、File类和四大家族没有关系，所以File类不能完成文件的读和写。2、File对象代表什么？文件和目录路径名的抽象表示形式。C:\\Drivers 这是一个File对象C:\\Drivers\\Lan\\Realtek\\Readme.txt 也是File对象。一个File对象有可能对应的是目录，也可能是文件。File只是一个路径名的抽象表示形式。3、需要掌握File类中常用的方法\nimport java.io.File;public class FileTest01 &#123;    public static void main(String[] args) throws Exception &#123;        // 创建一个File对象        File f1 = new File(&quot;D:\\\\file&quot;);        // 判断是否存在！        System.out.println(f1.exists());        // 如果D:\\file不存在，则以文件的形式创建出来        /*if(!f1.exists()) &#123;            // 以文件形式新建            f1.createNewFile();        &#125;*/        // 如果D:\\file不存在，则以目录的形式创建出来        /*if(!f1.exists()) &#123;            // 以目录的形式新建。            f1.mkdir();        &#125;*/        // 可以创建多重目录吗？        File f2 = new File(&quot;D:/a/b/c/d/e/f&quot;);        /*if(!f2.exists()) &#123;            // 多重目录的形式新建。            f2.mkdirs();        &#125;*/        File f3 = new File(&quot;D:\\\\course\\\\01-开课\\\\学习方法.txt&quot;);        // 获取文件的父路径        String parentPath = f3.getParent();        System.out.println(parentPath); //D:\\course\\01-开课        File parentFile = f3.getParentFile();        System.out.println(&quot;获取绝对路径：&quot; + parentFile.getAbsolutePath());        File f4 = new File(&quot;copy&quot;);        System.out.println(&quot;绝对路径：&quot; + f4.getAbsolutePath()); // C:\\Users\\Administrator\\IdeaProjects\\javase\\copy    &#125;&#125;\n\nimport java.io.File;import java.text.SimpleDateFormat;import java.util.Date;/*File类的常用方法 */public class FileTest02 &#123;    public static void main(String[] args) &#123;        File f1 = new File(&quot;D:\\\\course\\\\01-开课\\\\开学典礼.ppt&quot;);        // 获取文件名        System.out.println(&quot;文件名：&quot; + f1.getName());        // 判断是否是一个目录        System.out.println(f1.isDirectory()); // false        // 判断是否是一个文件        System.out.println(f1.isFile()); // true        // 获取文件最后一次修改时间        long haoMiao = f1.lastModified(); // 这个毫秒是从1970年到现在的总毫秒数。        // 将总毫秒数转换成日期?????        Date time = new Date(haoMiao);        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);        String strTime = sdf.format(time);        System.out.println(strTime);        // 获取文件大小        System.out.println(f1.length()); //216064字节。    &#125;&#125;\nimport java.io.File;/*File中的listFiles方法。 */public class FileTest03 &#123;    public static void main(String[] args) &#123;        // File[] listFiles()        // 获取当前目录下所有的子文件。        File f = new File(&quot;D:\\\\course\\\\01-开课&quot;);        File[] files = f.listFiles();        // foreach        for(File file : files)&#123;            //System.out.println(file.getAbsolutePath());            System.out.println(file.getName());        &#125;    &#125;&#125;\n\n拷贝目录import java.io.*;/*拷贝目录 */public class CopyAll &#123;    public static void main(String[] args) &#123;        // 拷贝源        File srcFile = new File(&quot;D:\\\\course\\\\02-JavaSE\\\\document&quot;);        // 拷贝目标        File destFile = new File(&quot;C:\\\\a\\\\b\\\\c&quot;);        // 调用方法拷贝        copyDir(srcFile, destFile);    &#125;    /**     * 拷贝目录     * @param srcFile 拷贝源     * @param destFile 拷贝目标     */    private static void copyDir(File srcFile, File destFile) &#123;        if(srcFile.isFile()) &#123;            // srcFile如果是一个文件的话，递归结束。            // 是文件的时候需要拷贝。            // ....一边读一边写。            FileInputStream in = null;            FileOutputStream out = null;            try &#123;                // 读这个文件                // D:\\course\\02-JavaSE\\document\\JavaSE进阶讲义\\JavaSE进阶-01-面向对象.pdf                in = new FileInputStream(srcFile);                // 写到这个文件中                // C:\\course\\02-JavaSE\\document\\JavaSE进阶讲义\\JavaSE进阶-01-面向对象.pdf                String path = (destFile.getAbsolutePath().endsWith(&quot;\\\\&quot;) ? destFile.getAbsolutePath() : destFile.getAbsolutePath() + &quot;\\\\&quot;)  + srcFile.getAbsolutePath().substring(3);                out = new FileOutputStream(path);                // 一边读一边写                byte[] bytes = new byte[1024 * 1024]; // 一次复制1MB                int readCount = 0;                while((readCount = in.read(bytes)) != -1)&#123;                    out.write(bytes, 0, readCount);                &#125;                out.flush();            &#125; catch (FileNotFoundException e) &#123;                e.printStackTrace();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; finally &#123;                if (out != null) &#123;                    try &#123;                        out.close();                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                if (in != null) &#123;                    try &#123;                        in.close();                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;            return;        &#125;        // 获取源下面的子目录        File[] files = srcFile.listFiles();        for(File file : files)&#123;            // 获取所有文件的（包括目录和文件）绝对路径            //System.out.println(file.getAbsolutePath());            if(file.isDirectory())&#123;                // 新建对应的目录                //System.out.println(file.getAbsolutePath());                //D:\\course\\02-JavaSE\\document\\JavaSE进阶讲义       源目录                //C:\\course\\02-JavaSE\\document\\JavaSE进阶讲义       目标目录                String srcDir = file.getAbsolutePath();                String destDir = (destFile.getAbsolutePath().endsWith(&quot;\\\\&quot;) ? destFile.getAbsolutePath() : destFile.getAbsolutePath() + &quot;\\\\&quot;)  + srcDir.substring(3);                File newFile = new File(destDir);                if(!newFile.exists())&#123;                    newFile.mkdirs();                &#125;            &#125;            // 递归调用            copyDir(file, destFile);        &#125;    &#125;&#125;\n\n序列化与反序列化\n序列化1、java.io.NotSerializableException:Student对象不支持序列化！！！！\n2、参与序列化和反序列化的对象，必须实现Serializable接口。\n3、注意：通过源代码发现，Serializable接口只是一个标志接口：public interface Serializable {}这个接口当中什么代码都没有。那么它起到一个什么作用呢？起到标识的作用，标志的作用，java虚拟机看到这个类实现了这个接口，可能会对这个类进行特殊待遇。Serializable这个标志接口是给java虚拟机参考的，java虚拟机看到这个接口之后，会为该类自动生成一个序列化版本号。\n4、序列化版本号有什么用呢？java.io.InvalidClassException:com.bjpowernode.java.bean.Student;local class incompatible:stream classdesc serialVersionUID &#x3D; -684255398724514298（十年后）,local class serialVersionUID &#x3D; -3463447116624555755（十年前）  \njava语言中是采用什么机制来区分类的？        第一：首先通过类名进行比对，如果类名不一样，肯定不是同一个类。        第二：如果类名一样，再怎么进行类的区别？靠序列化版本号进行区分。  \n小鹏编写了一个类：com.bjpowernode.java.bean.Student implements Serializable    胡浪编写了一个类：com.bjpowernode.java.bean.Student implements Serializable    不同的人编写了同一个类，但“这两个类确实不是同一个类”。这个时候序列化版本就起上作用了。    对于java虚拟机来说，java虚拟机是可以区分开这两个类的，因为这两个类都实现了Serializable接口，    都有默认的序列化版本号，他们的序列化版本号不一样。所以区分开了。（这是自动生成序列化版本号的好处）\n请思考？        这种自动生成序列化版本号有什么缺陷？            这种自动生成的序列化版本号缺点是：一旦代码确定之后，不能进行后续的修改，            因为只要修改，必然会重新编译，此时会生成全新的序列化版本号，这个时候java            虚拟机会认为这是一个全新的类。（这样就不好了！）\n 最终结论：        凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。        这样，以后这个类即使代码修改了，但是版本号不变，java虚拟机会认为是同一个类。\n重点：参与序列化的类型必须实现java.io.Serializable接口。并且建议将序列化版本号手动的写出来。private static final long serialVersionUID &#x3D; 1L;  \nimport java.io.Serializable;public class Student implements Serializable &#123;    // IDEA工具自动生成序列化版本号。    //private static final long serialVersionUID = -7998917368642754840L;    // Java虚拟机看到Serializable接口之后，会自动生成一个序列化版本号。    // 这里没有手动写出来，java虚拟机会默认提供这个序列化版本号。    // 建议将序列化版本号手动的写出来。不建议自动生成    private static final long serialVersionUID = 1L; // java虚拟机识别一个类的时候先通过类名，如果类名一致，再通过序列化版本号。    private int no;    //private String name;    // 过了很久，Student这个类源代码改动了。    // 源代码改动之后，需要重新编译，编译之后生成了全新的字节码文件。    // 并且class文件再次运行的时候，java虚拟机生成的序列化版本号也会发生相应的改变。    private int age;    private String email;    private String address;    public Student() &#123;    &#125;    public Student(int no, String name) &#123;        this.no = no;        //this.name = name;    &#125;    public int getNo() &#123;        return no;    &#125;    public void setNo(int no) &#123;        this.no = no;    &#125;    /*public String getName() &#123;        return name;    &#125;*/    /*public void setName(String name) &#123;        this.name = name;    &#125;*/    /*@Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;*/    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;no=&quot; + no +                &quot;, age=&quot; + age +                &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; +                &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n反序列化import java.io.FileInputStream;import java.io.ObjectInputStream;/*反序列化 */public class ObjectInputStreamTest01 &#123;    public static void main(String[] args) throws Exception&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;students&quot;));        // 开始反序列化，读        Object obj = ois.readObject();        // 反序列化回来是一个学生对象，所以会调用学生对象的toString方法。        System.out.println(obj);        ois.close();    &#125;&#125;\n\n一次性序列化与反序列化多个对象transient关键字表示游离的，不参与序列化。\nUser.java:\nimport java.io.Serializable;public class User implements Serializable &#123;    private int no;        private transient String name; // name不参与序列化操作！    public User() &#123;    &#125;    public User(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public int getNo() &#123;        return no;    &#125;    public void setNo(int no) &#123;        this.no = no;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\nObjectOutputStreamTest02.java:\nimport java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.util.ArrayList;import java.util.List;/*一次序列化多个对象呢？    可以，可以将对象放到集合当中，序列化集合。提示：    参与序列化的ArrayList集合以及集合中的元素User都需要实现 java.io.Serializable接口。 */public class ObjectOutputStreamTest02 &#123;    public static void main(String[] args) throws Exception&#123;        List&lt;User&gt; userList = new ArrayList&lt;&gt;();        userList.add(new User(1,&quot;zhangsan&quot;));        userList.add(new User(2, &quot;lisi&quot;));        userList.add(new User(3, &quot;wangwu&quot;));        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;users&quot;));        // 序列化一个集合，这个集合对象中放了很多其他对象。        oos.writeObject(userList);        oos.flush();        oos.close();    &#125;&#125;\n\nObjectInputStreamTest02.java:\nimport java.io.FileInputStream;import java.io.ObjectInputStream;import java.util.List;/*反序列化集合 */public class ObjectInputStreamTest02 &#123;    public static void main(String[] args) throws Exception&#123;        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;users&quot;));        //Object obj = ois.readObject();        //System.out.println(obj instanceof List);        List&lt;User&gt; userList = (List&lt;User&gt;)ois.readObject();        for(User user : userList)&#123;            System.out.println(user);        &#125;        ois.close();    &#125;&#125;\n\nIO+Properties的联合应用IO流：文件的读和写。Properties:是一个Map集合，key和value都是String类型。\n非常好的一个设计理念：以后经常改变的数据，可以单独写到一个文件中，使用程序动态读取。将来只需要修改这个文件的内容，java代码不需要改动，不需要重新编译，服务器也不需要重启。就可以拿到动态的信息。\n类似于以上机制的这种文件被称为配置文件。    并且当配置文件中的内容格式是：        key1&#x3D;value        key2&#x3D;value    的时候，我们把这种配置文件叫做属性配置文件。  \njava规范中有要求：属性配置文件建议以.properties结尾，但这不是必须的。    这种以.properties结尾的文件在java中被称为：属性配置文件。    其中Properties是专门存放属性配置文件内容的一个类。\nimport java.io.FileReader;import java.util.Properties;public class IoPropertiesTest01 &#123;\tpublic static void main(String[] args) throws Exception&#123;        /*        Properties是一个Map集合，key和value都是String类型。        想将userinfo文件中的数据加载到Properties对象当中。         */\t\t// 新建一个输入流对象\t\tFileReader reader = new FileReader(&quot;chapter23/userinfo.properties&quot;);\t\t// 新建一个Map集合\t\tProperties pro = new Properties();\t\t// 调用Properties对象的load方法将文件中的数据加载到Map集合中。\t\tpro.load(reader); // 文件中的数据顺着管道加载到Map集合中，其中等号=左边做key，右边做value\t\t// 通过key来获取value呢？\t\tString username = pro.getProperty(&quot;username&quot;);\t\tSystem.out.println(username);\t\tString password = pro.getProperty(&quot;password&quot;);\t\tSystem.out.println(password);\t\tString data = pro.getProperty(&quot;data&quot;);\t\tSystem.out.println(data);\t\tString usernamex = pro.getProperty(&quot;usernamex&quot;);\t\tSystem.out.println(usernamex);\t&#125;&#125;\n\n在属性配置文件中#是注释属性配置文件的key重复的话，value会自动覆盖！最好不要有空格！建议key和value之间使用&#x3D;的方式  不建议使用:&#x3D;左边是key，&#x3D;右边是value  \n","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——匿名内部类","url":"/2022/07/14/JavaSE%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-javase%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/","content":"匿名内部类/*\t匿名内部类：\t\t1、什么是内部类？\t\t\t内部类：在类的内部又定义了一个新的类。被称为内部类。\t\t2、内部类的分类：\t\t\t静态内部类：类似于静态变量\t\t\t实例内部类：类似于实例变量\t\t\t局部内部类：类似于局部变量\t\t3、使用内部类编写的代码，可读性很差。能不用尽量不用。\t\t4、匿名内部类是局部内部类的一种。\t\t\t因为这个类没有名字而得名，叫做匿名内部类。\t\t\t\t5、学习匿名内部类主要是让大家以后在阅读别人代码的时候，能够理解。\t\t并不代表以后都要这样写。因为匿名内部类有两个缺点：\t\t\t缺点1：太复杂，太乱，可读性差。\t\t\t缺点2：类没有名字，以后想重复使用，不能用。\t\t\t\t6、不理解算了，你只要记住这种写法就行。*/class Test01&#123;\t// 静态变量\tstatic String country;\t// 该类在类的内部，所以称为内部类\t// 由于前面有static，所以称为“静态内部类”\tstatic class Inner1&#123;\t&#125;\t\t// 实例变量\tint age;\t// 该类在类的内部，所以称为内部类\t// 没有static叫做实例内部类。\tclass Inner2&#123;\t&#125;\t// 方法\tpublic void doSome()&#123;\t\t// 局部变量\t\tint i = 100;\t\t// 该类在类的内部，所以称为内部类\t\t// 局部内部类。\t\tclass Inner3&#123;\t\t&#125;\t&#125;\tpublic void doOther()&#123;\t\t// doSome()方法中的局部内部类Inner3，在doOther()中不能用。\t&#125;\t// main方法，入口\tpublic static void main(String[] args)&#123;\t\t// 调用MyMath中的mySum方法。\t\tMyMath mm = new MyMath();\t\t/*\t\tCompute c = new ComputeImpl();\t\tmm.mySum(c, 100, 200);\t\t*/\t\t\t\t//合并（这样写代码，表示这个类名是有的。类名是：ComputeImpl）\t\t//mm.mySum(new ComputeImpl(), 100, 200);\t\t\t// 使用匿名内部类，表示这个ComputeImpl这个类没名字了。\t\t// 这里表面看上去好像是接口可以直接new了，实际上并不是接口可以new了。\t\t// 后面的&#123;&#125; 代表了对接口的实现。\t\t// 不建议使用匿名内部类，为什么？\t\t// 因为一个类没有名字，没有办法重复使用。另外代码太乱，可读性太差。\t\tmm.mySum(new Compute()&#123;\t\t\tpublic int sum(int a, int b)&#123;\t\t\t\treturn a + b;\t\t\t&#125;\t\t&#125;, 200, 300);\t&#125;&#125;// 负责计算的接口interface Compute&#123; \t\t// 抽象方法\tint sum(int a, int b);&#125;// 你自动会在这里编写一个Compute接口的实现类/*class ComputeImpl implements Compute&#123;\t// 对方法的实现\tpublic int sum(int a, int b)&#123;\t\treturn a + b;\t&#125;&#125;*/// 数学类class MyMath&#123;\t// 数学求和方法\tpublic void mySum(Compute c, int x, int y)&#123;\t\tint retValue = c.sum(x, y);\t\tSystem.out.println(x + &quot;+&quot; + y + &quot;=&quot; + retValue);\t&#125;\t&#125;\n\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——包||访问控制权限||toString||equals||finalize||hashCode","url":"/2022/07/11/JavaSE%E2%80%94%E2%80%94%E5%8C%85%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90toStringequalsfinalizehashCode-2022-07-11-16-46-22/","content":"包package第一：package出现在java源文件第一行。    第二：带有包名怎么编译？javac -d . xxx.java        第三：怎么运行？java 完整类名\n补充：以后说类名的时候，如果带着包名描述，表示完整类名。        如果没有带包，描述的话，表示简类名。            java.util.Scanner 完整类名。            Scanner 简类名\nimportimport什么时候不需要？            java.lang不需要。            同包下不需要。            其它一律都需要。\n用法：import 完整类名;import 包名.*;\nimport java.util.Scanner; &#x2F;&#x2F; 完整类名。import java.util.*;\n但import java.; 这是不允许的，因为在java语言中规定，这里的只代表某些类的名字。\n例子：\npackage com;// 将需要的类导入。//import com.bjpowernode.javase.chapter17.HelloWorld;import com.bjpowernode.javase.chapter17.*;public class Test02&#123;\tpublic static void main(String[] args)&#123;\t\t/*\t\t\tTest02在com包下。\t\t\tHelloWorld在com.bjpowernode.javase.chapter17下。\t\t\t不在同一个package下，包名可以省略吗？\t\t\t\t不能省略。\t\t*/\t\t//错误: 找不到符号\t\t/*\t\tHelloWorld hw = new HelloWorld();\t\tSystem.out.println(hw);\t\t*/\t\t/*\t\tcom.bjpowernode.javase.chapter17.HelloWorld hw = new com.bjpowernode.javase.chapter17.HelloWorld();\t\tSystem.out.println(hw);\t\tcom.bjpowernode.javase.chapter17.HelloWorld hw2 = new com.bjpowernode.javase.chapter17.HelloWorld();\t\tSystem.out.println(hw2);\t\tcom.bjpowernode.javase.chapter17.HelloWorld hw3 = new com.bjpowernode.javase.chapter17.HelloWorld();\t\tSystem.out.println(hw3);\t\t*/\t\tHelloWorld hw1 = new HelloWorld();\t\tSystem.out.println(hw1);\t\tHelloWorld hw2 = new HelloWorld();\t\tSystem.out.println(hw2);\t&#125;&#125;\n\n访问控制权限访问控制权限\n1、访问控制权限都有哪些？        4个。private\t私有        public 公开protected\t受保护        默认\n2、以上的4个访问控制权限：控制的范围是什么？        private 表示私有的，只能在本类中访问        public 表示公开的，在任何位置都可以访问        “默认”表示只能在本类，以及同包下访问。        protected表示只能在本类、同包、子类中访问。\n    访问控制修饰符\t\t\t本类\t\t\t同包\t\t\t子类\t\t\t任意位置\n    -----------------------------------------------------------------------------------------------------------------\n    public\t\t\t\t可以\t\t\t可以\t\t\t可以\t\t\t可以\n    protected\t\t\t可以\t\t\t可以\t\t\t可以\t\t\t不行\n    默认\t\t\t\t可以\t\t\t可以\t\t\t不行\t\t\t不行\n    private\t\t\t\t可以\t\t\t不行\t\t\t不行\t\t\t不行\n\n范围从大到小排序：public &gt; protected &gt; 默认 &gt; private\n3、访问控制权限修饰符可以修饰什么？        属性（4个都能用）        方法（4个都能用）        类（public和默认能用，其它不行。）        接口（public和默认能用，其它不行。）\ntoString方法以后所有类的toString()方法是需要重写的。        重写规则，越简单越明了就好。\nSystem.out.println(引用); 这里会自动调用“引用”的toString()方法。    String类是SUN写的，toString方法已经重写了。\n/*\t关于Object类中的toString()方法\t\t1、源代码长什么样？\t\t\tpublic String toString() &#123;\t\t\t\treturn this.getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());\t\t\t&#125;\t\t\t源代码上toString()方法的默认实现是：\t\t\t\t类名@对象的内存地址转换为十六进制的形式\t\t2、SUN公司设计toString()方法的目的是什么？\t\t\ttoString()方法的作用是什么？\t\t\t\ttoString()方法的设计目的是：通过调用这个方法可以将一个“java对象”转换成“字符串表示形式”\t\t3、其实SUN公司开发java语言的时候，建议所有的子类都去重写toString()方法。\t\ttoString()方法应该是一个简洁的、详实的、易阅读的.*/public class Test01&#123;\tpublic static void main(String[] args)&#123;\t\tMyTime t1 = new MyTime(1970, 1, 1);\t\t// 一个日期对象转换成字符串形式的话，我可能还是希望能看到具体的日期信息。\t\tString s1 = t1.toString();\t\t//MyTime类重写toString()方法之前\t\t//System.out.println(s1); // MyTime@28a418fc\t\t\t\t//MyTime类重写toString()方法之后\t\tSystem.out.println(s1); // 1970年1月1日\t\t\t\t//System.out.println(t1.toString()); //1970年1月1日\t\t// 注意：输出引用的时候，会自动调用该引用的toString()方法。\t\tSystem.out.println(t1);\t&#125;&#125;class MyTime&#123;\tint year;\tint month;\tint day;\tpublic MyTime()&#123;\t\t&#125;\tpublic MyTime(int year, int month, int day)&#123;\t\tthis.year = year;\t\tthis.month = month;\t\tthis.day = day;\t&#125;\t// 重写toString()方法\t// 这个toString()方法怎么重写呢？\t// 越简洁越好，可读性越强越好。\t// 向简洁的、详实的、易阅读的方向发展\tpublic String toString()&#123;\t\t//return this.year + &quot;年&quot; + this.month + &quot;月&quot; + this.day + &quot;日&quot;;\t\treturn this.year + &quot;/&quot; + this.month + &quot;/&quot; + this.day;\t&#125;&#125;\nequals方法以后所有类的equals方法也需要重写，因为Object中的equals方法比较的是两个对象的内存地址，我们应该比较内容，所以需要重写。\n重写规则：自己定，主要看是什么和什么相等时表示两个对象相等。\n基本数据类型比较实用：&#x3D;&#x3D;        对象和对象比较：调用equals方法\n/*\t关于Object类中的equals方法\t\t1、equals方法的源代码\t\t\tpublic boolean equals(Object obj) &#123;\t\t\t\treturn (this == obj);\t\t\t&#125;\t\t\t以上这个方法是Object类的默认实现。\t\t\t\t\t\t\t\t2、SUN公司设计equals方法的目的是什么？\t\t\t以后编程的过程当中，都要通过equals方法来判断两个对象是否相等。\t\t\tequals方法是判断两个对象是否相等的。\t\t\t\t3、我们需要研究一下Object类给的这个默认的equals方法够不够用！！！！\t\t\t\t在Object类中的equals方法当中，默认采用的是“==”判断两个java对象\t\t\t\t是否相等。而“==”判断的是两个java对象的内存地址，我们应该判断\t\t\t\t两个java对象的内容是否相等。所以老祖宗的equals方法不够用，\t\t\t\t需要子类重写equals。\t\t\t\t4、判断两个java对象是否相等，不能使用“==”，因为“==”比较的是两个\t\t对象的内存地址。*/public class Test02&#123;\tpublic static void main(String[] args)&#123;\t\t// 判断两个基本数据类型的数据是否相等直接使用“==”就行。\t\tint a = 100;\t\tint b = 100;\t\t// 这个“==”是判断a中保存的100和b中保存的100是否相等。\t\tSystem.out.println(a == b); //true（相等） false(不相等)\t\t// 判断两个java对象是否相等，我们怎么办？能直接使用“==”吗？\t\t// 创建一个日期对象是：2008年8月8日。\t\tMyTime t1 = new MyTime(2008, 8, 8); //MyTime t1 = 0x1234;\t\t// 创建了一个新的日期对象，但表示的日期也是：2008年8月8日。\t\tMyTime t2 = new MyTime(2008, 8, 8); //MyTime t2 = 0x3698;\t\t\t\t//测试以下，比较两个对象是否相等，能不能使用“==”？？？\t\t// 这里的“==”判断的是：t1中保存的对象内存地址和t2中保存的对象内存地址是否相等。\t\tSystem.out.println(t1 == t2); // false\t\t\t\t// 重写Object equals方法之前（比较的是对象内存地址）\t\t/*\t\tboolean flag = t1.equals(t2);\t\tSystem.out.println(flag); //false\t\t*/\t\t\t\t// 重写Object equals方法之后（比较的是内容。）\t\tboolean flag = t1.equals(t2);\t\tSystem.out.println(flag); //true\t\t// 再创建一个新的日期\t\tMyTime t3 = new MyTime(2008, 8, 9);\t\t// 两个日期不相等，就是false。\t\tSystem.out.println(t1.equals(t3)); // false\t\t// 我们这个程序有bug吗？可以运行，但是效率怎么样？低（怎么改造。）\t\tMyTime t4 = null;\t\tSystem.out.println(t1.equals(t4)); //false\t&#125;&#125;class MyTime &#123; //extends Object&#123;\tint year;\tint month;\tint day;\tpublic MyTime()&#123;\t\t&#125;\tpublic MyTime(int year, int month, int day)&#123;\t\tthis.year = year;\t\tthis.month = month;\t\tthis.day = day;\t&#125;\t// 默认的equals方法\t/*\tpublic boolean equals(Object obj) &#123;\t\treturn (this == obj);\t&#125;\t*/\t/*\t// 重写Object类的equals方法\t// 怎么重写？复制粘贴。相同的返回值类型、相同的方法名、相同的形式参数列表。\t// equals到底应该怎么重写？你自己定，你认为两个对象什么相等的时候表示相等，你就怎么重写。\tpublic boolean equals(Object obj) &#123;\t\t// 当年相同，月相同，并且日也相同的时候，表示两个日期相同。两个对象相等。\t\t// 获取第一个日期的年月日\t\tint year1 = this.year;\t\tint month1 = this.month;\t\tint day1 = this.day;\t\t// 获取第二个日期的年月日\t\t//int year2 = obj.year;\t\t//int month2 = obj.month;\t\t//int day2 = obj.day;\t\tif(obj instanceof MyTime)&#123;\t\t\tMyTime t = (MyTime)obj;\t\t\tint year2 = t.year;\t\t\tint month2 = t.month;\t\t\tint day2 = t.day;\t\t\tif(year1 == year2 &amp;&amp; month1 == month2 &amp;&amp; day1 == day2)&#123;\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t\t// 程序能够执行到此处表示日期不相等。\t\treturn false;\t&#125;\t*/\t/*\t// 改良equals方法\tpublic boolean equals(Object obj) &#123;\t\t// 如果obj是空，直接返回false\t\tif(obj == null)&#123;\t\t\treturn false;\t\t&#125;\t\t// 如果obj不是一个MyTime，没必要比较了 ，直接返回false\t\tif(!(obj instanceof MyTime))&#123;\t\t\treturn false;\t\t&#125;\t\t// 如果this和obj保存的内存地址相同，没必要比较了，直接返回true。\t\t// 内存地址相同的时候指向的堆内存的对象肯定是同一个。\t\tif(this == obj)&#123;\t\t\treturn true;\t\t&#125;\t\t// 程序能够执行到此处说明什么？\t\t// 说明obj不是null，obj是MyTime类型。\t\tMyTime t = (MyTime)obj;\t\tif(this.year == t.year &amp;&amp; this.month == t.month &amp;&amp; this.day == t.day)&#123;\t\t\treturn true;\t\t&#125;\t\t// 程序能到这里返回false\t\treturn false;\t&#125;\t*/\t\t//再次改良。\t/*\tpublic boolean equals(Object obj) &#123;\t\t// 如果obj是空，直接返回false\t\tif(obj == null)&#123;\t\t\treturn false;\t\t&#125;\t\t// 如果obj不是一个MyTime，没必要比较了 ，直接返回false\t\tif(!(obj instanceof MyTime))&#123;\t\t\treturn false;\t\t&#125;\t\t// 如果this和obj保存的内存地址相同，没必要比较了，直接返回true。\t\t// 内存地址相同的时候指向的堆内存的对象肯定是同一个。\t\tif(this == obj)&#123;\t\t\treturn true;\t\t&#125;\t\t// 程序能够执行到此处说明什么？\t\t// 说明obj不是null，obj是MyTime类型。\t\tMyTime t = (MyTime)obj;\t\treturn this.year == t.year &amp;&amp; this.month == t.month &amp;&amp; this.day == t.day ;\t&#125;\t*/\tpublic boolean equals(Object obj) &#123;\t\tif(obj == null || !(obj instanceof MyTime))&#123;\t\t\treturn false;\t\t&#125;\t\tif(this == obj)&#123;\t\t\treturn true;\t\t&#125;\t\tMyTime t = (MyTime)obj;\t\treturn this.year == t.year &amp;&amp; this.month == t.month &amp;&amp; this.day == t.day ;\t&#125;&#125;/*class Person&#123;\tprivate String idCard;&#125;*/\nString类重写方法：String类是SUN编写的，所以String类的equals方法重写了。        以后判断两个字符串是否相等，最好不要使用&#x3D;&#x3D;，要调用字符串对象的equals方法。注意：重写equals方法的时候要彻底。\n/*\tjava语言当中的字符串String有没有重写toString方法，有没有重写equals方法。\t总结：\t\t1、String类已经重写了equals方法，比较两个字符串不能使用==，必须使用equals。\t\tequals是通用的。\t\t2、String类已经重写了toString方法。\t\t大结论：\t\tjava中什么类型的数据可以使用“==”判断\t\t\tjava中基本数据类型比较是否相等，使用==\t\tjava中什么类型的数据需要使用equals判断\t\t\tjava中所有的引用数据类型统一使用equals方法来判断是否相等。\t\t\t\t这是规矩。*/public class Test03&#123;\tpublic static void main(String[] args)&#123;\t\t// 大部分情况下，采用这样的方式创建字符串对象\t\tString s1 = &quot;hello&quot;;\t\tString s2 = &quot;abc&quot;;\t\t// 实际上String也是一个类。不属于基本数据类型。\t\t// 既然String是一个类，那么一定存在构造方法。\t\tString s3 = new String(&quot;Test1&quot;);\t\tString s4 = new String(&quot;Test1&quot;);\t\t// new两次，两个对象内存地址，s3保存的内存地址和s4保存的内存地址不同。\t\t// == 判断的是内存地址。不是内容。\t\tSystem.out.println(s3 == s4); // false\t\t// 比较两个字符串能不能使用双等号？\t\t// 不能，必须调用equals方法。\t\t// String类已经重写equals方法了。\t\tSystem.out.println(s3.equals(s4)); // true\t\t// String类有没有重写toString方法呢？\t\tString x = new String(&quot;动力节点&quot;);\t\t// 如果String没有重写toString()方法，输出结果：java.lang.String@十六进制的地址\t\t// 经过测试：String类已经重写了toString()方法。\t\tSystem.out.println(x.toString()); //动力节点\t\tSystem.out.println(x); //动力节点\t&#125;&#125;\n\n\n// equals方法重写的时候要彻底。public class Test05&#123;\tpublic static void main(String[] args)&#123;\t\t\t\t// 多态（自动类型转换。）\t\tObject o1 = new String(&quot;hello world!&quot;);\t\tObject o2 = new User();\t\tObject o3 = new Address();\t\tUser u1 = new User(&quot;zhangsan&quot;, new Address(&quot;北京&quot;,&quot;大兴区&quot;,&quot;11111&quot;));\t\tUser u2 = new User(&quot;zhangsan&quot;, new Address(&quot;北京&quot;,&quot;大兴区&quot;,&quot;11111&quot;));\t\tSystem.out.println(u1.equals(u2)); // true\t\tUser u3 = new User(&quot;zhangsan&quot;, new Address(&quot;北京&quot;,&quot;朝阳区&quot;,&quot;11112&quot;));\t\tSystem.out.println(u1.equals(u3)); // false\t&#125;&#125;class User&#123;\t// 用户名\tString name; \t// 用户的住址\tAddress addr;\tpublic User()&#123;\t&#125;\tpublic User(String name, Address addr)&#123;\t\tthis.name = name;\t\tthis.addr = addr;\t&#125;\t// 重写equals方法\t// 重写规则：当一个用户的用户名和家庭住址都相同，表示同一个用户。\t// 这个equals判断的是User对象和User对象是否相等。\tpublic boolean equals(Object obj)&#123;\t\t// 用户名和用户名相同，住址和住址相同的时候，认定是同一个用户。\t\tif(obj == null || !(obj instanceof User)) return false;\t\tif(this == obj) return true;\t\t\t\tUser u = (User)obj;\t\tif(this.name.equals(u.name) &amp;&amp; this.addr.equals(u.addr))&#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;&#125;class Address&#123;\tString city;\tString street;\tString zipcode;\tpublic Address()&#123;\t\t&#125;\tpublic Address(String city,String street,String zipcode)&#123;\t\tthis.city = city;\t\tthis.street = street;\t\tthis.zipcode = zipcode;\t&#125;\t// 注意：这里并没有重写equals方法。\t// 这里的equals方法判断的是：Address对象和Address对象是否相等。\tpublic boolean equals(Object obj)&#123;\t\tif(obj == null || !(obj instanceof Address)) return false;\t\tif(this == obj) return true;\t\t// 怎么算是家庭住址相同呢？\t\t// 城市相同，街道相同，邮编相同，表示相同。\t\tAddress a = (Address)obj;\t\tif(this.city.equals(a.city) \t\t\t&amp;&amp; this.street.equals(a.street) \t\t\t&amp;&amp; this.zipcode.equals(a.zipcode))&#123;\t\t\treturn true;\t\t&#125;\t\treturn false;\t&#125;&#125;\n\nfinalize方法（了解即可）关于Object类中的finalize()方法。（非重点  了解即可。）\n/*\t关于Object类中的finalize()方法。（非重点  了解即可。）\t\t1、在Object类中的源代码：\t\t\tprotected void finalize() throws Throwable &#123; &#125;\t\t\tGC：负责调用finalize()方法。\t\t2、finalize()方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的。\t\t3、这个方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法。\t\t不像equals toString，equals和toString()方法是需要你写代码调用的。\t\tfinalize()只需要重写，重写完将来自动会有程序来调用。\t\t4、finalize()方法的执行时机：\t\t\t当一个java对象即将被垃圾回收器回收的时候，垃圾回收器负责调用\t\t\tfinalize()方法。\t\t\t\t5、finalize()方法实际上是SUN公司为java程序员准备的一个时机，垃圾销毁时机。\t\t如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize()方法当中。\t\t6、静态代码块的作用是什么？\t\t\tstatic &#123;\t\t\t\t....\t\t\t&#125;\t\t\t静态代码块在类加载时刻执行，并且只执行一次。\t\t\t这是一个SUN准备的类加载时机。\t\t\tfinalize()方法同样也是SUN为程序员准备的一个时机。\t\t\t这个时机是垃圾回收时机。\t\t7、提示：\t\t\t\tjava中的垃圾回收器不是轻易启动的，\t\t\t垃圾太少，或者时间没到，种种条件下，\t\t\t有可能启动，也有可能不启动。*/public class Test06&#123;\tpublic static void main(String[] args)&#123;\t\t/*\t\t// 创建对象\t\tPerson p = new Person();\t\t// 怎么把Person对象变成垃圾？\t\tp = null;\t\t*/\t\t// 多造点垃圾\t\t/*\t\tfor(int i = 0; i &lt; 100000000; i++)&#123;\t\t\tPerson p = new Person();\t\t\tp = null;\t\t&#125;\t\t*/\t\t\t\tfor(int i = 0; i &lt; 1000; i++)&#123;\t\t\tPerson p = new Person();\t\t\tp = null;\t\t\t// 有一段代码可以建议垃圾回收器启动。\t\t\tif(i % 2 == 0)&#123;\t\t\t\tSystem.gc(); // 建议启动垃圾回收器。（只是建议，可能不启动，也可能启动。启动的概率高了一些。）\t\t\t&#125;\t\t&#125;\t\t\t&#125;&#125;// 项目开发中有这样的业务需求：所有对象在JVM中被释放的时候，请记录一下释放时间！！！// 记录对象被释放的时间点，这个负责记录的代码写到哪里？// 写到finalize()方法中。class Person&#123;\t// 重写finalize()方法\t// Person类型的对象被垃圾回收器回收的时候，垃圾回收器负责调用：p.finalize();\tprotected void finalize() throws Throwable &#123;\t\t// this代表当前对象\t\tSystem.out.println(this + &quot;即将被销毁！&quot;);\t&#125;&#125;\n\nhashCode方法/*\thashCode方法：\t\t在Object中的hashCode方法是怎样的？\t\t\tpublic native int hashCode();\t\t\t这个方法不是抽象方法，带有native关键字，底层调用C++程序。\t\t\t\thashCode()方法返回的是哈希码：\t\t\t实际上就是一个java对象的内存地址，经过哈希算法，得出的一个值。\t\t\t所以hashCode()方法的执行结果可以等同看做一个java对象的内存地址。*/public class Test07&#123;\tpublic static void main(String[] args)&#123;\t\tObject o = new Object();\t\tint hashCodeValue = o.hashCode();\t\t// 对象内存地址经过哈希算法转换的一个数字。可以等同看做内存地址。\t\tSystem.out.println(hashCodeValue); //798154996\t\tMyClass mc = new MyClass();\t\tint hashCodeValue2 = mc.hashCode();\t\tSystem.out.println(hashCodeValue2); //1392838282\t\tMyClass mc2 = new MyClass();\t\tSystem.out.println(mc2.hashCode()); // 523429237\t&#125;&#125;class MyClass&#123;&#125;\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——反射","url":"/2022/09/10/JavaSE%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84-javasereflect/","content":"反射机制反射机制有什么用？通过java语言中的反射机制可以操作字节码文件。优点类似于黑客。（可以读和修改字节码文件。）通过反射机制可以操作代码片段。（class文件。）\n反射机制的相关类在哪个包下？java.lang.reflect.*;\n反射机制相关的重要的类有哪些？java.lang.Class：代表整个字节码，代表一个类型，代表整个类。java.lang.reflect.Method：代表字节码中的方法字节码。代表类中的方法。ava.lang.reflect.Constructor：代表字节码中的构造方法字节码。代表类中的构造方法java.lang.reflect.Field：代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。\n举例：\n             //java.lang.Class：public class User&#123;\t// Field\tint no;\t// Constructor\tpublic User()&#123;\t\t&#125;\tpublic User(int no)&#123;\t\tthis.no = no;\t&#125;\t// Method\tpublic void setNo(int no)&#123;\t\tthis.no = no;\t&#125;\tpublic int getNo()&#123;\t\treturn no;\t&#125;&#125;\n\n获取java.lang.Class实例要操作一个类的字节码，需要首先获取到这个类的字节码，怎么获取java.lang.Class实例？三种方式第一种：Class c &#x3D; Class.forName(“完整类名带包名”);第二种：Class c &#x3D; 对象.getClass();第三种：Class c &#x3D; 任何类型.class;\nimport java.util.Date;public class ReflectTest01 &#123;    public static void main(String[] args) &#123;        /*        Class.forName()            1、静态方法            2、方法的参数是一个字符串。            3、字符串需要的是一个完整类名。            4、完整类名必须带有包名。java.lang包也不能省略。         */        Class c1 = null;        Class c2 = null;        try &#123;            c1 = Class.forName(&quot;java.lang.String&quot;); // c1代表String.class文件，或者说c1代表String类型。            c2 = Class.forName(&quot;java.util.Date&quot;); // c2代表Date类型            Class c3 = Class.forName(&quot;java.lang.Integer&quot;); // c3代表Integer类型            Class c4 = Class.forName(&quot;java.lang.System&quot;); // c4代表System类型        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        // java中任何一个对象都有一个方法：getClass()        String s = &quot;abc&quot;;        Class x = s.getClass(); // x代表String.class字节码文件，x代表String类型。        System.out.println(c1 == x); // true（==判断的是对象的内存地址。）        Date time = new Date();        Class y = time.getClass();        System.out.println(c2 == y); // true (c2和y两个变量中保存的内存地址都是一样的，都指向方法区中的字节码文件。)        // 第三种方式，java语言中任何一种类型，包括基本数据类型，它都有.class属性。        Class z = String.class; // z代表String类型        Class k = Date.class; // k代表Date类型        Class f = int.class; // f代表int类型        Class e = double.class; // e代表double类型        System.out.println(x == z); // true    &#125;&#125;\n\n字节码内存图：\n获取到Class，能干什么？通过Class的newInstance()方法来实例化对象。注意：newInstance()方法内部实际上调用了无参数构造方法，必须保证无参构造存在才可以。\nimport com.bjpowernode.java.bean.User111;import com.bjpowernode.java.bean.User111;public class ReflectTest02 &#123;    public static void main(String[] args) &#123;        // 这是不使用反射机制，创建对象        User111 user111 = new User111();        System.out.println(user111);        // 下面这段代码是以反射机制的方式创建对象。        try &#123;            // 通过反射机制，获取Class，通过Class来实例化对象            Class c = Class.forName(&quot;com.bjpowernode.java.bean.User111&quot;); // c代表User类型。            // newInstance() 这个方法会调用User这个类的无参数构造方法，完成对象的创建。            // 重点是：newInstance()调用的是无参构造，必须保证无参构造是存在的！            Object obj = c.newInstance();            System.out.println(obj); // com.bjpowernode.java.bean.User111@10f87f48        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n验证反射机制的灵活性。java代码写一遍，再不改变java源代码的基础之上，可以做到不同对象的实例化。非常之灵活。（符合OCP开闭原则：对扩展开放，对修改关闭。）  \n后期要学习的是高级框架，而工作过程中，也都是使用高级框架，包括： ssh ssmSpring SpringMVC MyBatisSpring Struts Hibernate…这些高级框架底层实现原理：都采用了反射机制。所以反射机制还是重要的。学会了反射机制有利于你理解剖析框架底层的源代码。\nimport java.io.FileReader;import java.util.Properties;public class ReflectTest03 &#123;    public static void main(String[] args) throws Exception&#123;        // 这种方式代码就写死了。只能创建一个User类型的对象        //User user111 = new User();        // 以下代码是灵活的，代码不需要改动，可以修改配置文件，配置文件修改之后，可以创建出不同的实例对象。        // 通过IO流读取classinfo.properties文件        FileReader reader = new FileReader(&quot;chapter25/classinfo2.properties&quot;);        // 创建属性类对象Map        Properties pro = new Properties(); // key value都是String        // 加载        pro.load(reader);        // 关闭流        reader.close();        // 通过key获取value        String className = pro.getProperty(&quot;className&quot;);        //System.out.println(className);        // 通过反射机制实例化对象        Class c = Class.forName(className);        Object obj = c.newInstance();        System.out.println(obj);    &#125;&#125;\n\n研究一下：Class.forName()发生了什么？记住，重点：如果你只是希望一个类的静态代码块执行，其它代码一律不执行，你可以使用：Class.forName(“完整类名”);这个方法的执行会导致类加载，类加载时，静态代码块执行。\n提示：后面JDBC技术的时候我们还需要。\npublic class ReflectTest04 &#123;    public static void main(String[] args) &#123;        try &#123;            // Class.forName()这个方法的执行会导致：类加载。            Class.forName(&quot;com.bjpowernode.java.reflect.MyClass&quot;);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n资源绑定器java.util包下提供了一个资源绑定器，便于获取属性配置文件中的内容。使用以下这种方式的时候，属性配置文件xxx.properties必须放到类路径下。\nimport java.util.ResourceBundle;public class ResourceBundleTest &#123;    public static void main(String[] args) &#123;        // 资源绑定器，只能绑定xxx.properties文件。并且这个文件必须在类路径下。文件扩展名也必须是properties        // 并且在写路径的时候，路径后面的扩展名不能写。        //ResourceBundle bundle = ResourceBundle.getBundle(&quot;classinfo2&quot;);        ResourceBundle bundle = ResourceBundle.getBundle(&quot;com/bjpowernode/java/bean/db&quot;);        String className = bundle.getString(&quot;className&quot;);        System.out.println(className);    &#125;&#125;\n\n获取Field（了解即可）import java.lang.reflect.Field;import java.lang.reflect.Modifier;/*反射Student类当中所有的Field（了解一下） */public class ReflectTest05 &#123;    public static void main(String[] args) throws Exception &#123;        // 获取整个类        Class studentClass = Class.forName(&quot;com.bjpowernode.java.bean.Student111&quot;);        //com.bjpowernode.java.bean.Student111        String className = studentClass.getName();        System.out.println(&quot;完整类名：&quot; + className);        String simpleName = studentClass.getSimpleName();        System.out.println(&quot;简类名：&quot; + simpleName);        // 获取类中所有的public修饰的Field        Field[] fields = studentClass.getFields();        System.out.println(fields.length); // 测试数组中只有1个元素        // 取出这个Field        Field f = fields[0];        // 取出这个Field它的名字        String fieldName = f.getName();        System.out.println(fieldName);        // 获取所有的Field        Field[] fs = studentClass.getDeclaredFields();        System.out.println(fs.length); // 4        System.out.println(&quot;==================================&quot;);        // 遍历        for (Field field : fs) &#123;            // 获取属性的修饰符列表            int i = field.getModifiers(); // 返回的修饰符是一个数字，每个数字是修饰符的代号！！！            System.out.println(i);            // 可以将这个“代号”数字转换成“字符串”吗？            String modifierString = Modifier.toString(i);            System.out.println(modifierString);            // 获取属性的类型            Class fieldType = field.getType();            //String fName = fieldType.getName();            String fName = fieldType.getSimpleName();            System.out.println(fName);            // 获取属性的名字            System.out.println(field.getName());        &#125;    &#125;&#125;\n\n通过反射机制，反编译一个类的属性Field:\npublic class ReflectTest06 &#123;    public static void main(String[] args) throws Exception&#123;        // 创建这个是为了拼接字符串。        StringBuilder s = new StringBuilder();        //Class studentClass = Class.forName(&quot;com.bjpowernode.java.bean.Student&quot;);        Class studentClass = Class.forName(&quot;java.lang.Thread&quot;);        s.append(Modifier.toString(studentClass.getModifiers()) + &quot; class &quot; + studentClass.getSimpleName() + &quot; &#123;\\n&quot;);        Field[] fields = studentClass.getDeclaredFields();        for(Field field : fields)&#123;            s.append(&quot;\\t&quot;);            s.append(Modifier.toString(field.getModifiers()));            s.append(&quot; &quot;);            s.append(field.getType().getSimpleName());            s.append(&quot; &quot;);            s.append(field.getName());            s.append(&quot;;\\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;\n\n反射Method&#x2F;反编译Method（了解即可）import java.lang.reflect.Method;import java.lang.reflect.Modifier;/*作为了解内容（不需要掌握）：    反射Method */public class ReflectTest08 &#123;    public static void main(String[] args) throws Exception&#123;        // 获取类了        Class userServiceClass = Class.forName(&quot;com.bjpowernode.java.service.UserService&quot;);        // 获取所有的Method（包括私有的！）        Method[] methods = userServiceClass.getDeclaredMethods();        //System.out.println(methods.length); // 2        // 遍历Method        for(Method method : methods)&#123;            // 获取修饰符列表            System.out.println(Modifier.toString(method.getModifiers()));            // 获取方法的返回值类型            System.out.println(method.getReturnType().getSimpleName());            // 获取方法名            System.out.println(method.getName());            // 方法的修饰符列表（一个方法的参数可能会有多个。）            Class[] parameterTypes = method.getParameterTypes();            for(Class parameterType : parameterTypes)&#123;                System.out.println(parameterType.getSimpleName());            &#125;        &#125;    &#125;&#125;\n\nimport java.lang.reflect.Method;import java.lang.reflect.Modifier;/*了解一下，不需要掌握（反编译一个类的方法。） */public class ReflectTest09 &#123;    public static void main(String[] args) throws Exception&#123;        StringBuilder s = new StringBuilder();        //Class userServiceClass = Class.forName(&quot;com.bjpowernode.java.service.UserService&quot;);        Class userServiceClass = Class.forName(&quot;java.lang.String&quot;);        s.append(Modifier.toString(userServiceClass.getModifiers()) + &quot; class &quot;+userServiceClass.getSimpleName()+&quot; &#123;\\n&quot;);        Method[] methods = userServiceClass.getDeclaredMethods();        for(Method method : methods)&#123;            //public boolean login(String name,String password)&#123;&#125;            s.append(&quot;\\t&quot;);            s.append(Modifier.toString(method.getModifiers()));            s.append(&quot; &quot;);            s.append(method.getReturnType().getSimpleName());            s.append(&quot; &quot;);            s.append(method.getName());            s.append(&quot;(&quot;);            // 参数列表            Class[] parameterTypes = method.getParameterTypes();            for(Class parameterType : parameterTypes)&#123;                s.append(parameterType.getSimpleName());                s.append(&quot;,&quot;);            &#125;            // 删除指定下标位置上的字符            s.deleteCharAt(s.length() - 1);            s.append(&quot;)&#123;&#125;\\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;\n\n通过反射机制怎么调用一个对象的方法（重点）！反射机制，让代码很具有通用性，可变化的内容都是写到配置文件当中，将来修改配置文件之后，创建的对象不一样了，调用的方法也不同了，但是java代码不需要做任何改动。这就是反射机制的魅力。\nimport java.lang.reflect.Method;public class ReflectTest10 &#123;    public static void main(String[] args) throws Exception&#123;        // 不使用反射机制，怎么调用方法        // 创建对象        UserService userService = new UserService();        // 调用方法        /*        要素分析：            要素1：对象userService            要素2：login方法名            要素3：实参列表            要素4：返回值         */        boolean loginSuccess = userService.login(&quot;admin&quot;,&quot;123&quot;);        //System.out.println(loginSuccess);        System.out.println(loginSuccess ? &quot;登录成功&quot; : &quot;登录失败&quot;);        // 使用反射机制来调用一个对象的方法该怎么做？        Class userServiceClass = Class.forName(&quot;com.bjpowernode.java.service.UserService&quot;);        // 创建对象        Object obj = userServiceClass.newInstance();        // 获取Method        Method loginMethod = userServiceClass.getDeclaredMethod(&quot;login&quot;, String.class, String.class);        //Method loginMethod = userServiceClass.getDeclaredMethod(&quot;login&quot;, int.class);        // 调用方法        // 调用方法有几个要素？ 也需要4要素。        // 反射机制中最最最最最重要的一个方法，必须记住。        /*        四要素：        loginMethod方法        obj对象        &quot;admin&quot;,&quot;123&quot; 实参        retValue 返回值         */        Object retValue = loginMethod.invoke(obj, &quot;admin&quot;,&quot;123123&quot;);        System.out.println(retValue);    &#125;&#125;\n\nConstructorimport java.lang.reflect.Constructor;import java.lang.reflect.Modifier;/*反编译一个类的Constructor构造方法。 */public class ReflectTest11 &#123;    public static void main(String[] args) throws Exception&#123;        StringBuilder s = new StringBuilder();        Class vipClass = Class.forName(&quot;java.lang.String&quot;);        s.append(Modifier.toString(vipClass.getModifiers()));        s.append(&quot; class &quot;);        s.append(vipClass.getSimpleName());        s.append(&quot;&#123;\\n&quot;);        // 拼接构造方法        Constructor[] constructors = vipClass.getDeclaredConstructors();        for(Constructor constructor : constructors)&#123;            //public Vip(int no, String name, String birth, boolean sex) &#123;            s.append(&quot;\\t&quot;);            s.append(Modifier.toString(constructor.getModifiers()));            s.append(&quot; &quot;);            s.append(vipClass.getSimpleName());            s.append(&quot;(&quot;);            // 拼接参数            Class[] parameterTypes = constructor.getParameterTypes();            for(Class parameterType : parameterTypes)&#123;                s.append(parameterType.getSimpleName());                s.append(&quot;,&quot;);            &#125;            // 删除最后下标位置上的字符            if(parameterTypes.length &gt; 0)&#123;                s.deleteCharAt(s.length() - 1);            &#125;            s.append(&quot;)&#123;&#125;\\n&quot;);        &#125;        s.append(&quot;&#125;&quot;);        System.out.println(s);    &#125;&#125;\n\nimport com.bjpowernode.java.bean.Vip;import java.lang.reflect.Constructor;/*比上一个例子(ReflectTest11)重要一些！！！通过反射机制调用构造方法实例化java对象。（这个不是重点） */public class ReflectTest12 &#123;    public static void main(String[] args) throws Exception&#123;        // 不使用反射机制怎么创建对象        Vip v1 = new Vip();        Vip v2 = new Vip(110, &quot;zhangsan&quot;, &quot;2001-10-11&quot;, true);        // 使用反射机制怎么创建对象呢？        Class c = Class.forName(&quot;com.bjpowernode.java.bean.Vip&quot;);        // 调用无参数构造方法        Object obj = c.newInstance();        System.out.println(obj);        // 调用有参数的构造方法怎么办？        // 第一步：先获取到这个有参数的构造方法        Constructor con = c.getDeclaredConstructor(int.class, String.class, String.class,boolean.class);        // 第二步：调用构造方法new对象        Object newObj = con.newInstance(110, &quot;jackson&quot;, &quot;1990-10-11&quot;, true);        System.out.println(newObj);        // 获取无参数构造方法        Constructor con2 = c.getDeclaredConstructor();        Object newObj2 = con2.newInstance();        System.out.println(newObj2);    &#125;&#125;\n\n\n类加载器什么是类加载器？专门负责加载类的命令&#x2F;工具。ClassLoader\nJDK中自带了3个类加载器启动类加载器:rt.jar扩展类加载器:ext&#x2F;*.jar应用类加载器:classpath\n假设有这样一段代码：String s &#x3D; “abc”;\n代码在开始执行之前，会将所需要类全部加载到JVM当中。通过类加载器加载，看到以上代码类加载器会找String.class文件，找到就加载，那么是怎么进行加载的呢？\n首先通过“启动类加载器”加载。注意：启动类加载器专门加载：C:\\Program Files\\Java\\jdk1.8.0_101\\jre\\lib\\rt.jarrt.jar中都是JDK最核心的类库。\n如果通过“启动类加载器”加载不到的时候，会通过”扩展类加载器”加载。注意：扩展类加载器专门加载：C:\\Program Files\\Java\\jdk1.8.0_101\\jre\\lib\\ext*.jar\n如果“扩展类加载器”没有加载到，那么会通过“应用类加载器”加载。注意：应用类加载器专门加载：classpath中的类。\n双亲委派机制java中为了保证类加载的安全，使用了双亲委派机制。优先从启动类加载器中加载，这个称为“父”“父”无法加载到，再从扩展类加载器中加载，这个称为“母”。双亲委派。如果都加载不到，才会考虑从应用类加载器中加载。直到加载到为止。\n通过反射机制访问一个java对象的属性给属性赋值set获取属性的值get\nimport java.lang.reflect.Field;public class ReflectTest07 &#123;    public static void main(String[] args) throws Exception&#123;        // 我们不使用反射机制，怎么去访问一个对象的属性呢？        Student111 s = new Student111();        // 给属性赋值        s.no = 1111; //三要素：给s对象的no属性赋值1111        //要素1：对象s        //要素2：no属性        //要素3：1111        // 读属性值        // 两个要素：获取s对象的no属性的值。        System.out.println(s.no);        // 使用反射机制，怎么去访问一个对象的属性。（set get）        Class studentClass = Class.forName(&quot;com.bjpowernode.java.bean.Student&quot;);        Object obj = studentClass.newInstance(); // obj就是Student对象。（底层调用无参数构造方法）        // 获取no属性（根据属性的名称来获取Field）        Field noFiled = studentClass.getDeclaredField(&quot;no&quot;);        // 给obj对象(Student对象)的no属性赋值        /*        虽然使用了反射机制，但是三要素还是缺一不可：            要素1：obj对象            要素2：no属性            要素3：2222值        注意：反射机制让代码复杂了，但是为了一个“灵活”，这也是值得的。         */        noFiled.set(obj, 22222); // 给obj对象的no属性赋值2222        // 读取属性的值        // 两个要素：获取obj对象的no属性的值。        System.out.println(noFiled.get(obj));        // 可以访问私有的属性吗？        Field nameField = studentClass.getDeclaredField(&quot;name&quot;);         // 打破封装（反射机制的缺点：打破封装，可能会给不法分子留下机会！！！）        // 这样设置完之后，在外部也是可以访问private的。        nameField.setAccessible(true);        // 给name属性赋值        nameField.set(obj, &quot;jackson&quot;);        // 获取name属性的值        System.out.println(nameField.get(obj));    &#125;&#125;\n\n可变长参数int… args 这就是可变长度参数语法是：类型…  （注意：一定是3个点。）\n1、可变长度参数要求的参数个数是：0~N个。    2、可变长度参数在参数列表中必须在最后一个位置上，而且可变长度参数只能有1个。    3、可变长度参数可以当做一个数组来看待\npublic class ArgsTest &#123;    public static void main(String[] args) &#123;        m();        m(10);        m(10, 20);        // 编译报错        //m(&quot;abc&quot;);        m2(100);        m2(200, &quot;abc&quot;);        m2(200, &quot;abc&quot;, &quot;def&quot;);        m2(200, &quot;abc&quot;, &quot;def&quot;, &quot;xyz&quot;);        m3(&quot;ab&quot;, &quot;de&quot;, &quot;kk&quot;, &quot;ff&quot;);        String[] strs = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;        // 也可以传1个数组        m3(strs);        // 直接传1个数组        m3(new String[]&#123;&quot;我&quot;,&quot;是&quot;,&quot;中&quot;,&quot;国&quot;, &quot;人&quot;&#125;); //没必要        m3(&quot;我&quot;,&quot;是&quot;,&quot;中&quot;,&quot;国&quot;, &quot;人&quot;);    &#125;    public static void m(int... args)&#123;        System.out.println(&quot;m方法执行了！&quot;);    &#125;    //public static void m2(int... args2, String... args1)&#123;&#125;    // 必须在最后，只能有1个。    public static void m2(int a, String... args1)&#123;    &#125;    public static void m3(String... args)&#123;        //args有length属性，说明args是一个数组！        // 可以将可变长度参数当做一个数组来看。        for(int i = 0; i &lt; args.length; i++)&#123;            System.out.println(args[i]);        &#125;    &#125;&#125;\n\n获取父类和父接口/*重点：给你一个类，怎么获取这个类的父类，已经实现了哪些接口？ */public class ReflectTest13 &#123;    public static void main(String[] args) throws Exception&#123;        // String举例        Class stringClass = Class.forName(&quot;java.lang.String&quot;);        // 获取String的父类        Class superClass = stringClass.getSuperclass();        System.out.println(superClass.getName());        // 获取String类实现的所有接口（一个类可以实现多个接口。）        Class[] interfaces = stringClass.getInterfaces();        for(Class in : interfaces)&#123;            System.out.println(in.getName());        &#125;    &#125;&#125;","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——异常","url":"/2022/08/22/JavaSE%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8-javase%E5%BC%82%E5%B8%B8/","content":"异常认识异常1、什么是异常，java提供异常处理机制有什么用？    以下程序执行过程中发生了不正常的情况，而这种不正常的情况叫做：异常    java语言是很完善的语言，提供了异常的处理方式，以下程序执行过程中出现了不正常情况，    java把该异常信息打印输出到控制台，供程序员参考。程序员看到异常信息之后，可以对    程序进行修改，让程序更加的健壮。\n   什么是异常：程序执行过程中的不正常情况。    异常的作用：增强程序的健壮性。\n2、以下程序执行控制台出现了：    Exception in thread “main” java.lang.ArithmeticException: &#x2F; by zero        at com.bjpowernode.javase.exception.ExceptionTest01.main(ExceptionTest01.java:14)    这个信息被我们称为：异常信息。这个信息是JVM打印的。\n3、重写之后的方法不能比重写之前的方法抛出更多（更宽泛）的异常，可以更少。 public class ExceptionTest01 &#123;    public static void main(String[] args) &#123;        int a = 10;        int b = 0;        // 实际上JVM在执行到此处的时候，会new异常对象：new ArithmeticException(&quot;/ by zero&quot;);        // 并且JVM将new的异常对象抛出，打印输出信息到控制台了。        int c = a / b;        System.out.println(a + &quot;/&quot; + b + &quot;=&quot; + c);        // 此处运行也会创建一个：ArithmeticException类型的异常对象。        //System.out.println(100 / 0);        // 我观察到异常信息之后，对程序进行修改，更加健壮。        /*        int a = 10;        int b = 2;        if(b == 0) &#123;            System.out.println(&quot;除数不能为0&quot;);            return;        &#125;        // 程序执行到此处表示除数一定不是0        int c = a / b;        System.out.println(a + &quot;/&quot; + b + &quot;=&quot; + c);         */    &#125;&#125;\npackage com.bjpowernode.javase.exception;/*java语言中异常是以什么形式存在的呢？    1、异常在java中以类的形式存在，每一个异常类都可以创建异常对象。    2、异常对应的现实生活中是怎样的？        火灾(异常类)：            2008年8月8日,小明家着火了（异常对象）            2008年8月9日,小刚家着火了（异常对象）            2008年9月8日,小红家着火了（异常对象）        类是：模板。        对象是：实际存在的个体。        钱包丢了（异常类）：            2008年1月8日，小明的钱包丢了（异常对象）            2008年1月9日，小芳的钱包丢了（异常对象）            .... */public class ExceptionTest02 &#123;    public static void main(String[] args) &#123;        // 通过“异常类”实例化“异常对象”        NumberFormatException nfe = new NumberFormatException(&quot;数字格式化异常！&quot;);        // java.lang.NumberFormatException: 数字格式化异常！        System.out.println(nfe);        // 通过“异常类”创建“异常对象”        NullPointerException npe = new NullPointerException(&quot;空指针异常发生了！&quot;);        //java.lang.NullPointerException: 空指针异常发生了！        System.out.println(npe);    &#125;&#125;\n\n异常处理机制1、异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？    我们可以使用UML图来描述一下继承结构。    画UML图有很多工具，例如：Rational Rose（收费的）、starUML等….        Object        Object下有Throwable（可抛出的）        Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）        Exception下有两个分支：            Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。            RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）\n/*以下代码报错的原因是什么？    因为doSome()方法声明位置上使用了：throws ClassNotFoundException    而ClassNotFoundException是编译时异常。必须编写代码时处理，没有处理    编译器报错。 */public class ExceptionTest04 &#123;    public static void main(String[] args) &#123;        // main方法中调用doSome()方法        // 因为doSome()方法声明位置上有：throws ClassNotFoundException        // 我们在调用doSome()方法的时候必须对这种异常进行预先的处理。        // 如果不处理，编译器就报错。        //编译器报错信息： Unhandled exception: java.lang.ClassNotFoundException        //doSome();    &#125;    /**     * doSome方法在方法声明的位置上使用了：throws ClassNotFoundException     * 这个代码表示doSome()方法在执行过程中，有可能会出现ClassNotFoundException异常。     * 叫做类没找到异常。这个异常直接父类是：Exception，所以ClassNotFoundException属于编译时异常。     * @throws ClassNotFoundException     */    public static void doSome() throws ClassNotFoundException&#123;        System.out.println(&quot;doSome!!!!&quot;);    &#125;&#125;\n\n2、编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。        编译时异常因为什么而得名？        因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。        所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象。        因为异常的发生就是new异常对象。\n3、编译时异常和运行时异常的区别？\n编译时异常一般发生的概率比较高。            举个例子：                你看到外面下雨了，倾盆大雨的。                你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。                而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。                “拿一把伞”就是对“生病异常”发生之前的一种处理方式。\n对于一些发生概率较高的异常，需要在运行之前对其进行预处理。\n运行时异常一般发生的概率比较低。            举个例子：                小明走在大街上，可能会被天上的飞机轮子砸到。                被飞机轮子砸到也算一种异常。                但是这种异常发生概率较低。                在出门之前你没必要提前对这种发生概率较低的异常进行预处理。                如果你预处理这种异常，你将活的很累。        假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加的安全，但是你这个人活的很累。\n假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，        所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？            首先，如果这样的话，程序肯定是绝对的安全的。            但是程序员编写程序太累，代码到处都是处理异常的代码。\n4、编译时异常还有其他名字：        受检异常：CheckedException        受控异常\n5、运行时异常还有其它名字：        未受检异常：UnCheckedException        非受控异常\n6、再次强调：所有异常都是发生在运行阶段的。\n7、Java语言中对异常的处理包括两种方式：\n第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。            谁调用我，我就抛给谁。抛给上一级。\n第二种方式：使用try..catch语句进行异常的捕捉。            这件事发生了，谁也不知道，因为我给抓住了。\n举个例子：            我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，            “损失1000元”这可以看做是一个异常发生了。我有两种处理方式，            第一种方式：我把这件事告诉我的领导【异常上抛】            第二种方式：我自己掏腰包把这个钱补上。【异常的捕捉】\n张三 –&gt; 李四 —&gt; 王五 –&gt; CEO\n思考：            异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。\n8、注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续    向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/*处理异常的第一种方式：    在方法声明的位置上使用throws关键字抛出，谁调用我这个方法，我就抛给谁。抛给调用者来处理。    这种处理异常的态度：上报。处理异常的第二种方式：    使用try..catch语句对异常进行捕捉。    这个异常不会上报，自己把这个事儿处理了。    异常抛到此处为止，不再上抛了。注意：    只要异常没有捕捉，采用上报的方式，此方法的后续代码不会执行。    另外需要注意，try语句块中的某一行出现异常，该行后面的代码不会执行。    try..catch捕捉异常之后，后续代码可以执行。在以后的开发中，处理编译时异常，应该上报还是捕捉呢，怎么选？    如果希望调用者来处理，选择throws上报。    其它情况使用捕捉的方式。 */public class ExceptionTest06 &#123;    // 一般不建议在main方法上使用throws，因为这个异常如果真正的发生了，一定会抛给JVM。JVM只有终止。    // 异常处理机制的作用就是增强程序的健壮性。怎么能做到，异常发生了也不影响程序的执行。所以    // 一般main方法中的异常建议使用try..catch进行捕捉。main就不要继续上抛了。    /*    public static void main(String[] args) throws FileNotFoundException &#123;        System.out.println(&quot;main begin&quot;);        m1();        System.out.println(&quot;main over&quot;);    &#125;     */    public static void main(String[] args) &#123;        // 100 / 0这是算术异常，这个异常是运行时异常，你在编译阶段，可以处理，也可以不处理。编译器不管。        //System.out.println(100 / 0); // 不处理编译器也不管        // 你处理也可以。        /*        try &#123;            System.out.println(100 / 0);        &#125; catch(ArithmeticException e)&#123;            System.out.println(&quot;算术异常了！！！！&quot;);        &#125;         */        System.out.println(&quot;main begin&quot;);        try &#123;            // try尝试            m1();            // 以上代码出现异常，直接进入catch语句块中执行。            System.out.println(&quot;hello world!&quot;);        &#125; catch (FileNotFoundException e)&#123; // catch后面的好像一个方法的形参。            // 这个分支中可以使用e引用，e引用保存的内存地址是那个new出来异常对象的内存地址。            // catch是捕捉异常之后走的分支。            // 在catch分支中干什么？处理异常。            System.out.println(&quot;文件不存在，可能路径错误，也可能该文件被删除了！&quot;);            System.out.println(e); //java.io.FileNotFoundException: D:\\course\\01-课\\学习方法.txt (系统找不到指定的路径。)        &#125;        // try..catch把异常抓住之后，这里的代码会继续执行。        System.out.println(&quot;main over&quot;);    &#125;    private static void m1() throws FileNotFoundException &#123;        System.out.println(&quot;m1 begin&quot;);        m2();        // 以上代码出异常，这里是无法执行的。        System.out.println(&quot;m1 over&quot;);    &#125;    // 抛别的不行，抛ClassCastException说明你还是没有对FileNotFoundException进行处理    //private static void m2() throws ClassCastException&#123;    // 抛FileNotFoundException的父对象IOException，这样是可以的。因为IOException包括FileNotFoundException    //private static void m2() throws IOException &#123;    // 这样也可以，因为Exception包括所有的异常。    //private static void m2() throws Exception&#123;    // throws后面也可以写多个异常，可以使用逗号隔开。    //private static void m2() throws ClassCastException, FileNotFoundException&#123;    private static void m2() throws FileNotFoundException &#123;        System.out.println(&quot;m2 begin&quot;);        // 编译器报错原因是：m3()方法声明位置上有：throws FileNotFoundException        // 我们在这里调用m3()没有对异常进行预处理，所以编译报错。        // m3();        m3();        // 以上如果出现异常，这里是无法执行的！        System.out.println(&quot;m2 over&quot;);    &#125;    private static void m3() throws FileNotFoundException &#123;        // 调用SUN jdk中某个类的构造方法。        // 这个类还没有接触过，后期IO流的时候就知道了。        // 我们只是借助这个类学习一下异常处理机制。        // 创建一个输入流对象，该流指向一个文件。        /*        编译报错的原因是什么？            第一：这里调用了一个构造方法：FileInputStream(String name)            第二：这个构造方法的声明位置上有：throws FileNotFoundException            第三：通过类的继承结构看到：FileNotFoundException父类是IOException，IOException的父类是Exception，            最终得知，FileNotFoundException是编译时异常。            错误原因？编译时异常要求程序员编写程序阶段必须对它进行处理，不处理编译器就报错。         */        //new FileInputStream(&quot;D:\\\\course\\\\01-开课\\\\学习方法.txt&quot;);        // 我们采用第一种处理方式：在方法声明的位置上使用throws继续上抛。        // 一个方法体当中的代码出现异常之后，如果上报的话，此方法结束。        new FileInputStream(&quot;D:\\\\course\\\\01-课\\\\学习方法.txt&quot;);        System.out.println(&quot;如果以上代码出异常，这里会执行吗??????????????????不会！！！&quot;);    &#125;&#125;\n\n深入理解try…catch…import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/*深入try..catch    1、catch后面的小括号中的类型可以是具体的异常类型，也可以是该异常类型的父类型。    2、catch可以写多个。建议catch的时候，精确的一个一个处理。这样有利于程序的调试。    3、catch写多个的时候，从上到下，必须遵守从小到大。 */public class ExceptionTest07 &#123;    /*    public static void main(String[] args) throws Exception, FileNotFoundException, NullPointerException &#123;    &#125;     */    /*public static void main(String[] args) throws Exception &#123;    &#125;*/    public static void main(String[] args) &#123;        //编译报错        /*try &#123;            FileInputStream fis = new FileInputStream(&quot;D:\\\\course\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);        &#125; catch(NullPointerException e) &#123;        &#125;*/        /*try &#123;            FileInputStream fis = new FileInputStream(&quot;D:\\\\curse\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);            System.out.println(&quot;以上出现异常，这里无法执行！&quot;);        &#125; catch(FileNotFoundException e) &#123;            System.out.println(&quot;文件不存在！&quot;);        &#125;        System.out.println(&quot;hello world!&quot;);*/        /*try &#123;            FileInputStream fis = new FileInputStream(&quot;D:\\\\curse\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);        &#125; catch(IOException e) &#123; // 多态：IOException e = new FileNotFoundException();            System.out.println(&quot;文件不存在！&quot;);        &#125;*/        /*try &#123;            FileInputStream fis = new FileInputStream(&quot;D:\\\\curse\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);        &#125; catch(Exception e) &#123; // 多态：Exception e = new FileNotFoundException();            System.out.println(&quot;文件不存在！&quot;);        &#125;*/        /*try &#123;            //创建输入流            FileInputStream fis = new FileInputStream(&quot;D:\\\\curse\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);            //读文件            fis.read();        &#125; catch(Exception e) &#123; //所有的异常都走这个分支。            System.out.println(&quot;文件不存在！&quot;);        &#125;*/        /*try &#123;            //创建输入流            FileInputStream fis = new FileInputStream(&quot;D:\\\\curse\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);            //读文件            fis.read();        &#125; catch(FileNotFoundException e) &#123;            System.out.println(&quot;文件不存在！&quot;);        &#125; catch(IOException e)&#123;            System.out.println(&quot;读文件报错了！&quot;);        &#125;*/        // 编译报错。        /*        try &#123;            //创建输入流            FileInputStream fis = new FileInputStream(&quot;D:\\\\curse\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);            //读文件            fis.read();        &#125; catch(IOException e)&#123;            System.out.println(&quot;读文件报错了！&quot;);        &#125; catch(FileNotFoundException e) &#123;            System.out.println(&quot;文件不存在！&quot;);        &#125;         */        // JDK8的新特性！        try &#123;            //创建输入流            FileInputStream fis = new FileInputStream(&quot;D:\\\\curse\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);            // 进行数学运算            System.out.println(100 / 0); // 这个异常是运行时异常，编写程序时可以处理，也可以不处理。        &#125; catch(FileNotFoundException | ArithmeticException | NullPointerException e) &#123;            System.out.println(&quot;文件不存在？数学异常？空指针异常？都有可能！&quot;);        &#125;    &#125;&#125;\n\n异常对象的常用方法异常对象有两个非常重要的方法：\n 获取异常简单的描述信息：        String msg &#x3D; exception.getMessage();\n  打印异常追踪的堆栈信息：（更常用）        exception.printStackTrace();\nimport java.io.FileInputStream;import java.io.FileNotFoundException;/*异常对象的两个方法：    String msg = e.getMessage();    e.printStackTrace(); // 一般都是使用这个。我们以后查看异常的追踪信息，我们应该怎么看，可以快速的调试程序呢？    异常信息追踪信息，从上往下一行一行看。    但是需要注意的是：SUN写的代码就不用看了(看包名就知道是自己的还是SUN的。)。    主要的问题是出现在自己编写的代码上。 */public class ExceptionTest09 &#123;    public static void main(String[] args) &#123;        try &#123;            m1();        &#125; catch (FileNotFoundException e) &#123;            // 获取异常的简单描述信息            String msg = e.getMessage();            System.out.println(msg); //C:\\jetns-agent.jar (系统找不到指定的文件。)            //打印异常堆栈追踪信息！！！            //在实际的开发中，建议使用这个。养成好习惯！            // 这行代码要写上，不然出问题你也不知道！            //e.printStackTrace();            /*            java.io.FileNotFoundException: C:\\jetns-agent.jar (系统找不到指定的文件。)                at java.base/java.io.FileInputStream.open0(Native Method)                at java.base/java.io.FileInputStream.open(FileInputStream.java:213)                at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:155)                at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:110)                at com.bjpowernode.javase.exception.ExceptionTest09.m3(ExceptionTest09.java:31)                at com.bjpowernode.javase.exception.ExceptionTest09.m2(ExceptionTest09.java:27)                at com.bjpowernode.javase.exception.ExceptionTest09.m1(ExceptionTest09.java:23)                at com.bjpowernode.javase.exception.ExceptionTest09.main(ExceptionTest09.java:14)                因为31行出问题导致了27行                27行出问题导致23行                23行出问题导致14行。                应该先查看31行的代码。31行是代码错误的根源。             */        &#125;        // 这里程序不耽误执行，很健壮。《服务器不会因为遇到异常而宕机。》        System.out.println(&quot;Hello World!&quot;);    &#125;    private static void m1() throws FileNotFoundException &#123;        m2();    &#125;    private static void m2() throws FileNotFoundException &#123;        m3();    &#125;    private static void m3() throws FileNotFoundException &#123;        new FileInputStream(&quot;C:\\\\jetns-agent.jar&quot;);    &#125;&#125;\n\nfinally语句的使用关于try..catch中的finally子句：    1、在finally子句中的代码是最后执行的，并且是一定会执行的，即使try语句块中的代码出现了异常。        finally子句必须和try一起出现，不能单独编写。\n 2、finally语句通常使用在哪些情况下呢？        通常在finally语句块中完成资源的释放&#x2F;关闭。        因为finally中的代码比较有保障。        即使try语句块中的代码出现异常，finally中代码也会正常执行。\n3、try和finally，没有catch可以吗？可以。            try不能单独使用。            try finally可以联合使用。        以下代码的执行顺序：            先执行try…            再执行finally…            最后执行 return （return语句只要执行方法必然结束。）\n4、退出JVM之后，finally语句中的代码就不执行了\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class ExceptionTest10 &#123;    public static void main(String[] args) &#123;        FileInputStream fis = null; // 声明位置放到try外面。这样在finally中才能用。        try &#123;            // 创建输入流对象            fis = new FileInputStream(&quot;D:\\\\course\\\\02-JavaSE\\\\document\\\\JavaSE进阶讲义\\\\JavaSE进阶-01-面向对象.pdf&quot;);            // 开始读文件....            String s = null;            // 这里一定会出现空指针异常！            s.toString();            System.out.println(&quot;hello world!&quot;);            // 流使用完需要关闭，因为流是占用资源的。            // 即使以上程序出现异常，流也必须要关闭！            // 放在这里有可能流关不了。            //fis.close();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch(IOException e)&#123;            e.printStackTrace();        &#125; catch(NullPointerException e) &#123;            e.printStackTrace();        &#125; finally &#123;            System.out.println(&quot;hello 浩克！&quot;);            // 流的关闭放在这里比较保险。            // finally中的代码是一定会执行的。            // 即使try中出现了异常！            if (fis != null) &#123; // 避免空指针异常！                try &#123;                    // close()方法有异常，采用捕捉的方式。                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        System.out.println(&quot;hello kitty!&quot;);    &#125;&#125;\n\n一道finally面试题：\n/*finally面试题 */public class ExceptionTest13 &#123;    public static void main(String[] args) &#123;        int result = m();        System.out.println(result); //100    &#125;    /*    java语法规则（有一些规则是不能破坏的，一旦这么说了，就必须这么做！）：        java中有一条这样的规则：            方法体中的代码必须遵循自上而下顺序依次逐行执行（亘古不变的语法！）        java中还有一条语法规则：            return语句一旦执行，整个方法必须结束（亘古不变的语法！）     */    public static int m()&#123;        int i = 100;        try &#123;            // 这行代码出现在int i = 100;的下面，所以最终结果必须是返回100            // return语句还必须保证是最后执行的。一旦执行，整个方法结束。            return i;        &#125; finally &#123;            i++;        &#125;    &#125;&#125;/*反编译之后的效果public static int m()&#123;    int i = 100;    int j = i;    i++;    return j;&#125; */\n\nfinal finally finalize有什么区别？\n  final 关键字        final修饰的类无法继承        final修饰的方法无法覆盖        final修饰的变量不能重新赋值。\n finally 关键字        和try一起联合使用。        finally语句块中的代码是必须执行的。\n  finalize 标识符        是一个Object类中的方法名。        这个方法是由垃圾回收器GC负责调用的。\npublic class ExceptionTest14 &#123;    public static void main(String[] args) &#123;        // final是一个关键字。表示最终的。不变的。        final int i = 100;        //i = 200;        // finally也是一个关键字，和try联合使用，使用在异常处理机制中        // 在fianlly语句块中的代码是一定会执行的。        try &#123;        &#125; finally &#123;            System.out.println(&quot;finally....&quot;);        &#125;        // finalize()是Object类中的一个方法。作为方法名出现。        // 所以finalize是标识符。        // finalize()方法是JVM的GC垃圾回收器负责调用。        Object obj;    &#125;&#125;// final修饰的类无法继承final class A &#123;    // 常量。    public static final double MATH_PI = 3.1415926;&#125;class B &#123;    // final修饰的方法无法覆盖    public final void doSome()&#123;    &#125;&#125;\n\n自定义异常1、SUN提供的JDK内置的异常肯定是不够的用的。在实际的开发中，有很多业务，这些业务出现异常之后，JDK中都是没有的。和业务挂钩的。那么异常类我们程序员可以自己定义吗？    可以。\n2、Java中怎么自定义异常呢？    两步：        第一步：编写一个类继承Exception或者RuntimeException.        第二步：提供两个构造方法，一个无参数的，一个带有String参数的。\npublic class MyException extends Exception&#123; // 编译时异常    public MyException()&#123;    &#125;    public MyException(String s)&#123;        super(s);    &#125;&#125;/*public class MyException extends RuntimeException&#123; // 运行时异常&#125; */\n\n异常在实际开发中的作用/*\t编写程序，使用一维数组，模拟栈数据结构。\t要求：\t\t1、这个栈可以存储java中的任何引用类型的数据。\t\t2、在栈中提供push方法模拟压栈。（栈满了，要有提示信息。）\t\t3、在栈中提供pop方法模拟弹栈。（栈空了，也有有提示信息。）\t\t4、编写测试程序，new栈对象，调用push pop方法来模拟压栈弹栈的动作。\t\t5、假设栈的默认初始化容量是10.（请注意无参数构造方法的编写方式。） */public class MyStack &#123;    // 向栈当中存储元素，我们这里使用一维数组模拟。存到栈中，就表示存储到数组中。    // 因为数组是我们学习java的第一个容器。    // 为什么选择Object类型数组？因为这个栈可以存储java中的任何引用类型的数据    // new Animal()对象可以放进去，new Person()对象也可以放进去。因为Animal和Person的超级父类就是Object。    // 包括String也可以存储进去。因为String父类也是Object。    private Object[] elements;    // 栈帧，永远指向栈顶部元素    // 那么这个默认初始值应该是多少。注意：最初的栈是空的，一个元素都没有。    //private int index = 0; // 如果index采用0，表示栈帧指向了顶部元素的上方。    //private int index = -1; // 如果index采用-1，表示栈帧指向了顶部元素。    private int index;    /**     * 无参数构造方法。默认初始化栈容量10.     */    public MyStack() &#123;        // 一维数组动态初始化        // 默认初始化容量是10.        this.elements = new Object[10];        // 给index初始化        this.index = -1;    &#125;    /**     * 压栈的方法     * @param obj 被压入的元素     */    public void push(Object obj) throws MyStackOperationException &#123;        if(index &gt;= elements.length - 1)&#123;            // 改良之前            //System.out.println(&quot;压栈失败，栈已满！&quot;);            //return;            // 创建异常对象            //MyStackOperationException e = new MyStackOperationException(&quot;压栈失败，栈已满！&quot;);            // 手动将异常抛出去！            //throw e; //这里捕捉没有意义，自己new一个异常，自己捉，没有意义。栈已满这个信息你需要传递出去。            // 合并（手动抛出异常！）            throw new MyStackOperationException(&quot;压栈失败，栈已满！&quot;);        &#125;        // 程序能够走到这里，说明栈没满        // 向栈中加1个元素，栈帧向上移动一个位置。        index++;        elements[index] = obj;        // 在声明一次：所有的System.out.println()方法执行时，如果输出引用的话，自动调用引用的toString()方法。        System.out.println(&quot;压栈&quot; + obj + &quot;元素成功，栈帧指向&quot; + index);    &#125;    /**     * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。     * @return     */    public void pop() throws MyStackOperationException &#123;        if(index &lt; 0)&#123;            //System.out.println(&quot;弹栈失败，栈已空！&quot;);            //return;            throw new MyStackOperationException(&quot;弹栈失败，栈已空！&quot;);        &#125;        // 程序能够执行到此处说明栈没有空。        System.out.print(&quot;弹栈&quot; + elements[index] + &quot;元素成功，&quot;);        // 栈帧向下移动一位。        index--;        System.out.println(&quot;栈帧指向&quot; + index);    &#125;    // set和get也许用不上，但是你必须写上，这是规矩。你使用IDEA生成就行了。    // 封装：第一步：属性私有化，第二步：对外提供set和get方法。    public Object[] getElements() &#123;        return elements;    &#125;    public void setElements(Object[] elements) &#123;        this.elements = elements;    &#125;    public int getIndex() &#123;        return index;    &#125;    public void setIndex(int index) &#123;        this.index = index;    &#125;&#125;class MyStackOperationException extends Exception&#123; // 编译时异常！    public MyStackOperationException()&#123;    &#125;    public MyStackOperationException(String s)&#123;        super(s);    &#125;&#125;\n\n测试改良之后的MyStack// 注意：最后这个例子，是异常最终要的案例。必须掌握。自定义异常在实际开发中的应用。public class ExceptionTest16 &#123;    public static void main(String[] args) &#123;        // 创建栈对象        MyStack stack = new MyStack();        // 压栈        try &#123;            stack.push(new Object());            stack.push(new Object());            stack.push(new Object());            stack.push(new Object());            stack.push(new Object());            stack.push(new Object());            stack.push(new Object());            stack.push(new Object());            stack.push(new Object());            stack.push(new Object());            // 这里栈满了            stack.push(new Object());        &#125; catch (MyStackOperationException e) &#123;            // 输出异常的简单信息。            System.out.println(e.getMessage());        &#125;        // 弹栈        try &#123;            stack.pop();            stack.pop();            stack.pop();            stack.pop();            stack.pop();            stack.pop();            stack.pop();            stack.pop();            stack.pop();            stack.pop();            // 弹栈失败            stack.pop();        &#125; catch (MyStackOperationException e) &#123;            System.out.println(e.getMessage());        &#125;    &#125;&#125;","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——抽象类||接口||类间关系||抽象类与接口的区别","url":"/2022/07/07/JavaSE%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB-2022-07-07-16-06-05/","content":"抽象类第一：抽象类怎么定义？在class前添加abstract关键字就行了。        第二：抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。        第三：final和abstract不能联合使用，这两个关键字是对立的。        第四：抽象类的子类可以是抽象类。也可以是非抽象类。        第五：抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。        第六：抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。        第七：抽象方法怎么定义？            public abstract void doSome();        第八（**五颗星）：一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖&#x2F;重写&#x2F;实现。*\n\n上图为对抽象类的理解\n\n面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。\n        不对，错误的。\n        Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们\n        都不是抽象方法，例如：\n            public native int hashCode();\n            这个方法底层调用了C++写的动态链接库程序。\n            前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。\n\n/*\t抽象类：\t1、抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。\t2、重要结论：重要结论五颗星*****（必须记住）\t一个非抽象的类继承抽象类，必须将抽象类中的抽象方法实现了。\t这是java语法上强行规定的，必须的，不然编译器就报错了。\t\t\t\t这里的覆盖或者说重写，也可以叫做实现。（对抽象的实现。）*/public class AbstractTest02&#123;\tpublic static void main(String[] args)&#123;\t\t// 能不能使用多态?\t\t// 父类型引用指向子类型对象。\t\tAnimal a = new Bird();  // 向上转型。（自动类型转换）\t\t// 这就是面向抽象编程。\t\t// 以后你都是调用的a.XXXX\t\t// a的类型是Animal，Animal是抽象的\t\t// 面向抽象编程，不要面向具体编程，降低程序的耦合度，提高程序的扩展力。\t\t// 这种编程思想符合OCP原则。\t\t/*\t\t\t分析以下：\t\t\t\t编译的时候这个move()方法是谁的？\t\t\t\t运行的时候这个move()方法又是谁的？\t\t*/\t\ta.move();\t\t// 多态（当对多态不是很理解的时候，以后写代码能用多态就用多态。慢慢就理解了。）\t\tAnimal x = new Cat();\t\tx.move();\t&#125;&#125;// 动物类（抽象类）abstract class Animal&#123;\t// 抽象方法\tpublic abstract void move();&#125;// 子类（非抽象的）// 错误: Bird不是抽象的, 并且未覆盖Animal中的抽象方法move()/*class Bird extends Animal&#123;&#125;*/class Bird extends Animal&#123;\t// 需要将从父类中继承过来的抽象方法进行覆盖/重写，或者也可以叫做“实现”。\t// 把抽象的方法实现了。\tpublic void move()&#123;\t\tSystem.out.println(&quot;鸟儿在飞翔！&quot;);\t&#125;&#125;class Cat extends Animal&#123;\tpublic void move()&#123;\t\tSystem.out.println(&quot;猫在走猫步！&quot;);\t&#125;&#125;// 如果Bird是抽象类的话，那么这个Animal中继承过来的抽象方法也可以不去重写/覆盖/实现。/*abstract class Bird extends Animal&#123;&#125;*/\t/*\t有些内容不要死记硬背，讲讲道理。\t分析：\t\tAnimal是父类，并且是 抽象的。\t\tAnimal这个抽象类中有一个抽象方法move。\t\tBird是子类，并且是 非抽象的。\t\tBird继承Animal之后，会将抽象方法继承过来。*/\n\n接口接口的基础语法1、接口是一种“引用数据类型”。        2、接口是完全抽象的。        3、接口怎么定义：[修饰符列表] interface 接口名{}        4、接口支持多继承。        5、接口中只有常量+抽象方法。        6、接口中所有的元素都是public修饰的        7、接口中抽象方法的public abstract可以省略。        8、接口中常量的public static final可以省略。        9、接口中方法不能有方法体。        10、一个非抽象的类，实现接口的时候，必须将接口中所有方法加以实现。        11、一个类可以实现多个接口。        12、extends和implements可以共存，extends在前，implements在后。        13、使用接口，写代码的时候，可以使用多态（父类型引用指向子类型对象）。\n/*\t接口的基础语法：\t\t1、类和类之间叫做继承，类和接口之间叫做实现。\t\t别多想：你仍然可以将&quot;实现&quot;看做“继承”。\t\t继承使用extends关键字完成。\t\t实现使用implements关键字完成。\t\t2、五颗星（*****）：当一个非抽象的类实现接口的话，必须将接口中所有的\t\t抽象方法全部实现（覆盖、重写）。*/public class Test02&#123;\tpublic static void main(String[] args)&#123;\t\t//错误: MyMath是抽象的; 无法实例化\t\t//new MyMath();\t\t// 能使用多态吗？可以。\t\t//Animal a = new Cat();\t\t// 父类型的引用指向子类型的对象\t\tMyMath mm = new MyMathImpl();\t\t// 调用接口里面的方法（面向接口编程。）\t\tint result1 = mm.sum(10, 20);\t\tSystem.out.println(result1);\t\tint result2 = mm.sub(20, 10);\t\tSystem.out.println(result2);\t&#125;&#125;// 特殊的抽象类，完全抽象的，叫做接口。interface MyMath&#123;\tdouble PI = 3.1415926;\tint sum(int a, int b);\tint sub(int a, int b);&#125;// 这样没问题/*abstract class MyMathImpl implements MyMath &#123;&#125;*/// 编写一个类（这个类是一个“非抽象”的类）// 这个类的名字是随意的。//错误: MyMathImpl不是抽象的, 并且未覆盖MyMath中的抽象方法sub(int,int)/*class MyMathImpl implements MyMath &#123;&#125;*///修正class MyMathImpl implements MyMath &#123;\t//错误：正在尝试分配更低的访问权限; 以前为public\t/*\tint sum(int a, int b)&#123;\t\treturn a + b;\t&#125;\t*/\t// 重写/覆盖/实现 接口中的方法（通常叫做实现。）\tpublic int sum(int a, int b)&#123;\t\treturn a + b;\t&#125;\tpublic int sub(int a, int b)&#123;\t\treturn a - b;\t&#125;&#125;\n\n/*\t接口和接口之间支持多继承，那么一个类可以同时实现多个接口吗？\t\t对于计算机来说，一个机箱上有多个接口，一个接口是接键盘的，\t\t一个接口是接鼠标的，一个接口是接电源的，一个接口是接显示器的.....\t\t重点（五颗星*****）：一个类可以同时实现多个接口。\t这种机制弥补了java中的哪个缺陷？\t\tjava中类和类只支持单继承。实际上单继承是为了简单而出现的，现实世界中\t\t存在多继承，java中的接口弥补了单继承带来的缺陷。\t\t接口A和接口B虽然没有继承关系，但是写代码的时候，可以互转。\t编译器没意见。但是运行时可能出现：ClassCastException\t之前有一个结论：\t\t无论向上转型还是向下转型，两种类型之间必须要有继承关系，\t\t没有继承关系编译器会报错。（这句话不适用在接口方面。）\t\t最终实际上和之前还是一样，需要加：instanceof运算符进行判断。\t\t向下转型养成好习惯。转型之前先if+instanceof进行判断。*/public class Test03&#123;\tpublic static void main(String[] args)&#123;\t\t// 多态该怎么用呢？\t\t// 都是父类型引用指向子类型对象\t\tA a = new D();\t\t//a.m2(); // 编译报错。A接口中没有m2()方法。\t\tB b = new D();\t\tC c = new D();\t\t// 这个编译没问题，运行也没问题。\t\t// 调用其他接口中的方法，你需要转型（接口转型。）\t\tB b2 = (B)a;\t\tb2.m2();\t\t// 直接向下转型为D可以吗？可以\t\tD d = (D)a;\t\td.m2();\t\tM m = new E();\t\t// 经过测试：接口和接口之间在进行强制类型转换的时候，没有继承关系，也可以强转。\t\t// 但是一定要注意，运行时可能会出现ClassCastException异常。\t\t// 编译没问题，运行有问题。\t\t//K k = (K)m;\t\tif(m instanceof K)&#123;\t\t\tK k = (K)m;\t\t&#125;\t&#125;&#125;interface K&#123;&#125;interface M&#123;&#125;class E implements M&#123;&#125;// --------------------------------------------------------------------interface X&#123;&#125;interface Y&#123;&#125;interface Z extends X,Y&#123; //接口和接口支持多继承。&#125;//------------------------------------------------------------------interface A&#123;\tvoid m1();&#125;interface B&#123;\tvoid m2();&#125;interface C&#123;\tvoid m3();&#125;// 实现多个接口，其实就类似于多继承。class D implements A,B,C&#123;\t// 实现A接口的m1()\tpublic void m1()&#123;\t\t\t&#125;\t// 实现B接口中的m2()\tpublic void m2()&#123;\t\tSystem.out.println(&quot;m2 ....&quot;);\t&#125;\t// 实现接口C中的m3()\tpublic void m3()&#123;\t\t&#125;&#125;\n\n以下为继承与实现同时存在时的情况：\n/*\t继承和实现都存在的话，代码应该怎么写？\t\textends 关键字在前。\t\timplements 关键字在后。*/public class Test04&#123;\tpublic static void main(String[] args)&#123;\t\t// 创建对象（表面看Animal类没起作用！）\t\tFlyable f = new Cat(); //多态。\t\tf.fly();\t\t// 同一个接口\t\tFlyable f2 = new Pig();\t\t// 调用同一个fly()方法，最后的执行效果不同。\t\tf2.fly();\t\tFlyable f3 = new Fish();\t\tf3.fly();\t&#125;&#125;// 动物类：父类class Animal&#123;&#125;// 可飞翔的接口（是一对翅膀）// 能插拔的就是接口。（没有接口你怎么插拔。）// 内存条插到主板上，他们之间有接口。内存条可以更换。// 接口通常提取的是行为动作。interface Flyable&#123;\tvoid fly();&#125;// 动物类子类：猫类// Flyable是一个接口，是一对翅膀的接口，通过接口插到猫身上，让猫变的可以飞翔。class Cat extends Animal implements Flyable&#123;\tpublic void fly()&#123;\t\tSystem.out.println(&quot;飞猫起飞，翱翔太空的一只猫，很神奇，我想做一只猫！！&quot;);\t&#125;&#125;// 蛇类，如果你不想让它飞，可以不实现Flyable接口// 没有实现这个接口表示你没有翅膀，没有给你插翅膀，你肯定不能飞。class Snake extends Animal&#123;&#125;// 想飞就插翅膀这个接口。class Pig extends Animal implements Flyable&#123;\tpublic void fly()&#123;\t\tSystem.out.println(&quot;我是一只会飞的猪！！！&quot;);\t&#125;&#125;// 鱼（默认实际上是存在继承的，默认继承Object。）/*class Fish extends Object implements Flyable&#123;&#125;*/class Fish implements Flyable&#123; //没写extends，也是有的，默认继承Object。\tpublic void fly()&#123;\t\tSystem.out.println(&quot;我是六眼飞鱼（流言蜚语）！！！&quot;);\t&#125;&#125;\n\n接口在开发中的作用注意：接口在开发中的作用，类似于多态在开发中的作用。\n多态：面向抽象编程，不要面向具体编程。降低程序的耦合度。提高程序的扩展力。&#x2F;*public class Master{                public void feed(Dog d){}                public void feed(Cat c){}                &#x2F;&#x2F;假设又要养其它的宠物，那么这个时候需要再加1个方法。（需要修改代码了）                &#x2F;&#x2F;这样扩展力太差了，违背了OCP原则（对扩展开放，对修改关闭。）            }            *&#x2F;\npublic class Master{                public void feed(Animal a){                    &#x2F;&#x2F; 面向Animal父类编程，父类是比子类更抽象的。                    &#x2F;&#x2F;所以我们叫做面向抽象编程，不要面向具体编程。                    &#x2F;&#x2F;这样程序的扩展力就强。                }            }\n接口在开发中的作用？            接口是不是完全的？是。            而我们以后正好要求，面向抽象编程。            面向抽象编程这句话以后可以修改为：面向接口编程。            有了接口就有了可插拔。可插拔表示扩展力很强。不是焊接死的。\n主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新            买一个换下来。这叫做高扩展性。（低耦合度。）\n接口在现实世界中是不是到处都是呢？                螺栓和螺母之间有接口                灯泡和灯口之间有接口                笔记本电脑和键盘之间有接口（usb接口，usb接口是不是某个计算机协会制定的协议&#x2F;规范。）                接口有什么用？扩展性好。可插拔。\n接口是一个抽象的概念。\n分析：                中午去饭馆吃饭，这个过程中有接口吗？\n接口是抽象的。\t\n菜单是一个接口。（菜单上有一个抽象的照片：西红柿炒鸡蛋）\n谁面向接口调用。（顾客面向菜单点菜，调用接口。）\n谁负责实现这个接口。（后台的厨师负责把西红柿鸡蛋做好！是接口的实现者。）\n这个接口有什么用呢？这个饭馆的“菜单”，让“顾客”和“后厨”解耦合了。顾客不用找后厨，后厨不用找顾客。他们之间完全依靠这个抽象的菜单沟通。\n总结一句话：三个字“解耦合”                面向接口编程，可以降低程序的耦合度，提高程序的扩展力。符合OCP开发原则。            接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度。）\n接口可以解耦合，解开的是谁和谁的耦合！！！                任何一个接口都有调用者和实现者。                接口可以将调用者和实现者解耦合。                调用者面向接口调用。                实现者面向接口编写实现。\n类型和类型之间的关系：is a（继承）、has a（关联）、like a（实现）\nis a：                Cat is a Animal（猫是一个动物）                凡是能够满足is a的表示“继承关系”                A extends B\nhas a：                I has a Pen（我有一支笔）                凡是能够满足has a关系的表示“关联关系”                关联关系通常以“属性”的形式存在。                A{                    B b;                }\nlike a:                Cooker like a FoodMenu（厨师像一个菜单一样）                凡是能够满足like a关系的表示“实现关系”                实现关系通常是：类实现接口。                A implements B\n抽象类和接口有什么区别？在这里我们只说一下抽象类和接口在语法上的区别。至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会&#x2F;学习。\n    抽象类是半抽象的。\n    接口是完全抽象的。\n\n    抽象类中有构造方法。\n    接口中没有构造方法。\n\n    接口和接口之间支持多继承。\n    类和类之间只能单继承。\n\n    一个类可以同时实现多个接口。\n    一个抽象类只能继承一个类（单继承）。\n\n    接口中只允许出现常量和抽象方法。\n    \n\n以后接口使用的比抽象类多。一般抽象类使用的还是少。接口一般都是对“行为”的抽象。\n接口在开发中的实现举例：\nAmericCooker.java:\n//西餐厨师// 实现菜单上的菜// 厨师是接口的实现者。public class AmericCooker implements FoodMenu&#123;\t// 西红柿炒蛋\tpublic void shiZiChaoJiDan()&#123;\t\tSystem.out.println(&quot;西餐师傅做的西红柿炒鸡蛋！&quot;);\t&#125;\t// 鱼香肉丝\tpublic void yuXiangRouSi()&#123;\t\tSystem.out.println(&quot;西餐师傅做的鱼香肉丝！&quot;);\t&#125;&#125;\n\nChinaCooker.java:\n//中餐厨师// 实现菜单上的菜// 厨师是接口的实现者。public class ChinaCooker implements FoodMenu&#123;\t// 西红柿炒蛋\tpublic void shiZiChaoJiDan()&#123;\t\tSystem.out.println(&quot;中餐师傅做的西红柿炒鸡蛋，东北口味！&quot;);\t&#125;\t// 鱼香肉丝\tpublic void yuXiangRouSi()&#123;\t\tSystem.out.println(&quot;中餐师傅做的鱼香肉丝，东北口味！&quot;);\t&#125;&#125;\n\nFoodMenu.java:\n/*\t接口：菜单，抽象的*/public interface FoodMenu&#123;\t// 西红柿炒蛋\tvoid shiZiChaoJiDan();\t// 鱼香肉丝\tvoid yuXiangRouSi();&#125;\n\nCustomer.java\n// 顾客public class Customer&#123;\t// 顾客手里有一个菜单\t// Customer has a FoodMenu!（这句话什么意思：顾客有一个菜单）\t// 记住：以后凡是能够使用 has a 来描述的，统一以属性的方式存在。\t// 实例变量，属性\t// 面向抽象编程，面向接口编程。降低程序的耦合度，提高程序的扩展力。\tprivate FoodMenu foodMenu; \t\t// 如果以下这样写，就表示写死了（焊接了。没有可插拔了。）\t// 中餐厨师\t//ChinaCooker cc;\t// 西餐厨师\t//AmericCooker ac\t// 构造方法\tpublic Customer()&#123;\t&#125;\tpublic Customer(FoodMenu foodMenu)&#123;\t\tthis.foodMenu = foodMenu;\t&#125;\t// setter and getter\tpublic void setFoodMenu(FoodMenu foodMenu)&#123;\t\tthis.foodMenu = foodMenu;\t&#125;\tpublic FoodMenu getFoodMenu()&#123;\t\treturn foodMenu;\t&#125;\t// 提供一个点菜的方法\tpublic void order()&#123;\t\t// 先拿到菜单才能点菜\t\t// 调用get方法拿菜单。\t\t//FoodMenu fm = this.getFoodMenu();\t\t// 也可以不调用get方法，因为在本类中私有的属性是可以访问\t\tfoodMenu.shiZiChaoJiDan();\t\tfoodMenu.yuXiangRouSi();\t&#125;&#125;/*\tCat is a Animal，但凡满足is a的表示都可以设置为继承。\tCustomer has a FoodMenu，但凡是满足has a的表示都以属性的形式存在。*//*class Address&#123;\tString city;\tString street;\tString zipcode;&#125;class User&#123;\tint id;\t// 和这个一样。\t// String是一个类。\t// name是变量名。\t// name是一个引用。\tString name;\t// Address是一个类名。\t// 这就是一个变量。\t// 实例变量。\tAddress addr; // addr是一个引用。是一个变量。\tpublic static void main(String[] args)&#123;\t\t// 局部变量\t\t//Address addr;\t\t//addr = new Address();\t\t// 合并。\t\tAddress addr = new Address();\t\tUser u = new User();\t\tu.id = 100;\t\tu.name = &quot;zhangsan&quot;;\t\tu.addr = new Address();\t\tSystem.out.println(u.addr.city); // null\t\tSystem.out.println(u.addr.street); // null\t\tSystem.out.println(u.addr.zipcode); // null\t&#125;&#125;//“自己”类// MySelf has a Friend;class MySelf&#123;\t// 你这个对象，应该有一个朋友对象的电话号码。\t// 电话号码就是一个对象的内存地址。联系你朋友的时候，打电话。\t// f是一个引用。f默认值是null，是null表示，你没有朋友。\tFriend f;\tpublic MySelf()&#123;\t\t&#125;\t//通过构造方法能不能给你一个朋友对象。\tpublic MySelf(Friend f)&#123;\t\tthis.f = f;\t&#125;\tpublic static void main(String[] args)&#123;\t\t// 创建朋友对象\t\tFriend f = new Friend(); //朋友对象有了\t\t// 创建对象的同时交朋友。\t\tMySelf m2 = new MySelf(f);\t\t// 创建自己对象\t\t// 目前还没有交朋友。\t\tMySelf m = new MySelf(); //自己对象\t\t// 交朋友\t\tm.f = f; // 把朋友的地址给了你。\t&#125;&#125;// “朋友”类class Friend&#123;&#125;*/\n\nTest.java:\npublic class Test&#123;\tpublic static void main(String[] args)&#123;\t\t// 创建厨师对象\t\t//FoodMenu cooker1 = new ChinaCooker();\t\tFoodMenu cooker1 = new AmericCooker();\t\t// 创建顾客对象\t\tCustomer customer = new Customer(cooker1);\t\t// 顾客点菜\t\tcustomer.order();\t&#125;&#125;\n","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——数组","url":"/2022/07/31/JavaSE%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84-javase-shu-zu/","content":"数组数组的优点和缺点，并且要理解为什么。        第一：空间存储上，内存地址是连续的。        第二：每个元素占用的空间大小相同。        第三：知道首元素的内存地址。        第四：通过下标可以计算出偏移量。通过一个数学表达式，就可以快速计算出某个下标位置上元素的内存地址，直接通过内存地址定位，效率非常高。\n优点：检索效率高。        缺点：随机增删效率较低，数组无法存储大数据量。        注意：数组最后一个元素的增删效率不受影响。\n一维数组一维数组的静态初始化和动态初始化静态初始化： int[] arr = &#123;1,2,3,4&#125;;Object[] objs = &#123;new Object(), new Object(), new Object()&#125;;\n动态初始化：\nint[] arr = new int[4]; // 4个长度，每个元素默认值0Object[] objs = new Object[4]; // 4个长度，每个元素默认值null\n\n\n一维数组的遍历for(int i = 0; i &lt; arr.length; i++)&#123;\n    System.out.println(arr[i]);\n&#125;\n\n一维数组储存对象的调用 多态的调用package com.bjpowernode.javase.array;/** * 一维数组的深入，数组中存储的类型为：引用数据类型 * 对于数组来说，实际上只能存储java对象的“内存地址”。数组中存储的每个元素是“引用”。 */public class ArrayTest07 &#123;    public static void main(String[] args) &#123;        // a是一个数组        // a[0] 是数组中的一个元素。        // a[1] 是数组中的一个元素。        int[] a = &#123;100, 200, 300&#125;;        System.out.println(a[1]);        //a[2] = 400;        int[] array = &#123;1,2,3&#125;;        for (int i = 0; i &lt; array.length; i++) &#123;            /*int temp = array[i];            System.out.println(temp);*/            System.out.println(array[i]);        &#125;        // 创建一个Animal类型的数组        Animal a1 = new Animal();        Animal a2 = new Animal();        Animal[] animals = &#123;a1, a2&#125;;        // 对Animal数组进行遍历        for (int i = 0; i &lt; animals.length; i++) &#123;            /*Animal a = animals[i];            a.move();*/            // 代码合并            animals[i].move(); // 这个move()方法不是数组的。是数组当中Animal对象的move()方法。        &#125;        // 动态初始化一个长度为2的Animal类型数组。        Animal[] ans = new Animal[2];        // 创建一个Animal对象，放到数组的第一个盒子中。        ans[0] = new Animal();        // Animal数组中只能存放Animal类型，不能存放Product类型。        //ans[1] = new Product();        // Animal数组中可以存放Cat类型的数据，因为Cat是一个Animal。        // Cat是Animal的子类。        ans[1] = new Cat();        // 创建一个Animal类型的数组，数组当中存储Cat和Bird        Cat c = new Cat();        Bird b = new Bird();        Animal[] anis = &#123;c, b&#125;;        //Animal[] anis = &#123;new Cat(), new Bird()&#125;; // 该数组中存储了两个对象的内存地址。        for (int i = 0; i &lt; anis.length; i++)&#123;            // 这个取出来的可能是Cat，也可能是Bird，不过肯定是一个Animal            // 如果调用的方法是父类中存在的方法不需要向下转型。直接使用父类型引用调用即可。            //anis[i]            //Animal an = anis[i];            //an.move();            //Animal中没有sing()方法。            //anis[i].sing();            // 调用子对象特有方法的话，需要向下转型！！！            if(anis[i] instanceof Cat)&#123;                Cat cat = (Cat)anis[i];                cat.catchMouse();            &#125;else if(anis[i] instanceof Bird)&#123;                Bird bird = (Bird)anis[i];                bird.sing();            &#125;        &#125;    &#125;&#125;class Animal&#123;    public void move()&#123;        System.out.println(&quot;Animal move...&quot;);    &#125;&#125;// 商品类class Product&#123;&#125;// Cat是子类class Cat extends Animal &#123;    public void move()&#123;        System.out.println(&quot;猫在走猫步！&quot;);    &#125;    // 特有方法    public void catchMouse()&#123;        System.out.println(&quot;猫抓老鼠！&quot;);    &#125;&#125;// Bird子类class Bird extends Animal &#123;    public void move()&#123;        System.out.println(&quot;Bird Fly!!!&quot;);    &#125;    // 特有的方法    public void sing()&#123;        System.out.println(&quot;鸟儿在歌唱！！！&quot;);    &#125;&#125;\n\n二维数组二维数组的静态初始化和动态初始化静态初始化：\nint[][] arr = &#123;&#123;1,2,34&#125;,&#123;54,4,34,3&#125;,&#123;2,34,4,5&#125;&#125;;Object[][] arr = &#123;&#123;new Object(),new Object()&#125;,&#123;new Object(),new Object()&#125;,&#123;new Object(),new Object(),new Object()&#125;&#125;;\n动态初始化：\nint[][] arr = new int[3][4];Object[][] arr = new Object[4][4];Animal[][] arr = new Animal[3][4];// Person类型数组，里面可以存储Person类型对象，以及Person类型的子类型都可以。Person[][] arr = new Person[2][2];....\n二维数组的遍历for(int i = 0; i &lt; arr.length; i++)&#123; // 外层for循环负责遍历外面的一维数组。\n    // 里面这个for循环负责遍历二维数组里面的一维数组。\n    for(int j = 0; j &lt; arr[i].length; j++)&#123;\n        System.out.print(arr[i][j]);\n    &#125;\n    // 换行。\n    System.out.println();\n&#125;\n\nmain方法上“String[] args”参数的使用（非重点，了解一下，以后一般都是有界面的，用户可以在界面上输入用户名和密码等参数信息。）\n/*模拟一个系统，假设这个系统要使用，必须输入用户名和密码。 */public class ArrayTest06 &#123;    // 用户名和密码输入到String[] args数组当中。    public static void main(String[] args) &#123;        if(args.length != 2)&#123;            System.out.println(&quot;使用该系统时请输入程序参数，参数中包括用户名和密码信息，例如：zhangsan 123&quot;);            return;        &#125;        // 程序执行到此处说明用户确实提供了用户名和密码。        // 接下来你应该判断用户名和密码是否正确。        // 取出用户名        String username = args[0];        // 取出密码        String password = args[1];        // 假设用户名是admin，密码是123的时候表示登录成功。其它一律失败。        // 判断两个字符串是否相等，需要使用equals方法。        //if(username.equals(&quot;admin&quot;) &amp;&amp; password.equals(&quot;123&quot;))&#123;        // 这样编写是不是可以避免空指针异常。        // 采用以下编码风格，及时username和password都是null，也不会出现空指针异常。（这是老程序员给的一条编程经验。）        if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;123&quot;.equals(password))&#123;            System.out.println(&quot;登录成功，欢迎[&quot; + username + &quot;]回来&quot;);            System.out.println(&quot;您可以继续使用该系统....&quot;);        &#125;else&#123;            System.out.println(&quot;验证失败，用户名不存在或者密码错误！&quot;);        &#125;    &#125;&#125;\n\n数组的拷贝：System.arraycopy()方法的使用数组有一个特点：长度一旦确定，不可变。\t所以数组长度不够的时候，需要扩容，扩容的机制是：新建一个大数组，将小数组中的数据拷贝到大数组，然后小数组对象被垃圾回收。\n/** * 关于一维数组的扩容。 * 在java开发中，数组长度一旦确定不可变，那么数组满了怎么办？ *      数组满了，需要扩容。 *      java中对数组的扩容是： *          先新建一个大容量的数组，然后将小容量数组中的数据一个一个拷贝到大数组当中。 * * 结论：数组扩容效率较低。因为涉及到拷贝的问题。所以在以后的开发中请注意：尽可能少的进行数组的拷贝。 * 可以在创建数组对象的时候预估计以下多长合适，最好预估准确，这样可以减少数组的扩容次数。提高效率。 */public class ArrayTest08 &#123;    public static void main(String[] args) &#123;        // java中的数组是怎么进行拷贝的呢？        //System.arraycopy(5个参数);        // 拷贝源（从这个数组中拷贝）        int[] src = &#123;1, 11, 22, 3, 4&#125;;        // 拷贝目标（拷贝到这个目标数组上）        int[] dest = new int[20]; // 动态初始化一个长度为20的数组，每一个元素默认值0        // 调用JDK System类中的arraycopy方法，来完成数组的拷贝        //System.arraycopy(src, 1, dest, 3, 2);        // 遍历目标数组        /*        for (int i = 0; i &lt; dest.length; i++) &#123;            System.out.println(dest[i]); // 0 0 0 11 22 ... 0        &#125;         */        System.arraycopy(src, 0, dest, 0, src.length);        for (int i = 0; i &lt; dest.length; i++) &#123;            System.out.println(dest[i]);        &#125;        // 数组中如果存储的元素是引用，可以拷贝吗？当然可以。        String[] strs = &#123;&quot;hello&quot;, &quot;world!&quot;, &quot;study&quot;, &quot;java&quot;, &quot;oracle&quot;, &quot;mysql&quot;, &quot;jdbc&quot;&#125;;        String[] newStrs = new String[20];        System.arraycopy(strs, 0, newStrs, 0, strs.length);        for (int i = 0; i &lt; newStrs.length; i++) &#123;            System.out.println(newStrs[i]);        &#125;        System.out.println(&quot;================================&quot;);        Object[] objs = &#123;new Object(), new Object(), new Object()&#125;;        Object[] newObjs = new Object[5];        // 思考一下：这里拷贝的时候是拷贝对象，还是拷贝对象的地址。（地址。）        System.arraycopy(objs, 0, newObjs, 0, objs.length);        for (int i = 0; i &lt; newObjs.length; i++) &#123;            System.out.println(newObjs[i]);        &#125;    &#125;&#125;\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——数组中常见的算法","url":"/2022/08/10/JavaSE%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95-javase-shu-zu-zhong-chang-jian-de-suan-fa/","content":"数组中常见的算法例如：java中提供了一个数组工具类：java.util.ArraysArrays是一个工具类。其中有一个sort()方法，可以排序。静态方法，直接使用类名调用就行。\nimport java.util.Arrays;/** * 好消息： *  SUN公司已经为我们程序员写好了一个数组工具类。 *  java.util.Arrays; */public class ArraysTest02 &#123;    public static void main(String[] args) &#123;        // java.util.Arrays; 工具类中有哪些方法，我们开发的时候要参考API帮助文档        // 不要死记硬背。        int[] arr = &#123;3,6,4,5,12,1,2,32,5,5&#125;;        // 排序        Arrays.sort(arr);        // 输出        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.println(arr[i]);        &#125;        // 二分法查找（建立在排序基础之上。）        int index = Arrays.binarySearch(arr, 5);        System.out.println(index == -1 ? &quot;该元素不存在&quot; : &quot;该元素下标是：&quot; + index);    &#125;&#125;\n\n排序冒泡排序/*冒泡排序算法    1、每一次循环结束之后，都要找出最大的数据，放到参与比较的这堆数据的最右边。（冒出最大的那个气泡。）    2、核心：        拿着左边的数字和右边的数字比对，当左边 &gt; 右边的时候，交换位置。原始数据：3, 2, 7, 6, 8第1次循环：(最大的跑到最右边。)2, 3, 7, 6, 8 （3和2比较，2 &lt; 3，所以2和3交换位置）2, 3, 7, 6, 8 （虽然不需要交换位置：但是3和7还是需要比较一次。）2, 3, 6, 7, 8 （7和6交换位置）2, 3, 6, 7, 8 （虽然不需要交换位置：但是3和7还是需要比较一次。）经过第1次循环，此时剩下参与比较的数据：2, 3, 6, 7第2次循环：2, 3, 6, 7 (2和3比较，不需要交换位置)2, 3, 6, 7 （3和6比较，不需要交换位置）2, 3, 6, 7 (6和7比较，不需要交换位置)经过第2次循环，此时剩下参与比较的数据：2, 3, 6第3次循环：2, 3, 6 (2和3比较，不需要交换位置)2, 3, 6 （3和6比较，不需要交换位置）经过第3次循环，此时剩下参与比较的数据：2, 3第4次循环：2, 3 (2和3比较，不需要交换位置) */public class BubbleSort &#123;    public static void main(String[] args) &#123;        // 这是int类型的数组对象        //int[] arr = &#123;3, 2, 7, 6, 8&#125;;        int[] arr = &#123;9, 8, 10, 7, 6, 0, 11&#125;;        // 经过冒泡排序算法对以上数组中元素进行排序        // 冒泡排序算法的核心是什么？        // 7条数据，循环6次。以下的代码可以循环6次。        /*        for(int i = 0; i &lt; arr.length-1; i++)&#123;            System.out.println(i);        &#125;         */        // 7条数据，循环6次。以下的代码可以循环6次。（冒泡排序的外层循环采用这种方式）        //int count = 0;        int count2 = 0;        for(int i = arr.length-1; i &gt; 0; i--)&#123;            for(int j = 0; j &lt; i; j++)&#123;                // 不管是否需要交换位置，总之是要比较一次的。                //count++;                if(arr[j] &gt; arr[j+1])&#123;                    // 交换位置。                    // arr[j] 和 arr[j+1] 交换                    int temp;                    temp = arr[j];                    arr[j] = arr[j+1];                    arr[j+1] = temp;                    count2++;                &#125;            &#125;        &#125;        //System.out.println(&quot;比较次数：&quot; + count);        System.out.println(&quot;交换位置的次数：&quot; + count2); //13        // 输出结果        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.println(arr[i]);        &#125;    &#125;&#125;\n\n选择排序/*选择排序：    每一次从这堆“参与比较的数据当中”找出最小值，    拿着这个最小值和“参与比较的这堆最前面的元素”交换位置。    选择排序比冒泡排序好在：每一次的交换位置都是有意义的。    关键点：选择排序中的关键在于，你怎么找出一堆数据中最小的。        3 2 6 1 5        假设：            第一个3是最小的。            3和2比较，发现2更小，所以此时最小的是2.            继续拿着2往下比对，2和6比较，2仍然是最小的。            继续拿着2往下比对，2和1比对，发现1更小，所以此时最小的是1.            继续拿着1往下比对，1和5比对，发现1还是小的，所以1就是最小的。            拿着1和最左边的3交换位置。       2 6 3 5       假设：        第一个2是最小的。        ...      6 3 5        假设6是最小的：        6和3比对，发现3更小，所以此时最小的是3.        ... */public class SelectSort &#123;    public static void main(String[] args) &#123;        //int[] arr = &#123;3, 1, 6, 2, 5&#125;;        int[] arr = &#123;9, 8, 10, 7, 6, 0, 11&#125;;        int count = 0;        int count2 = 0;        // 选择排序        // 5条数据循环4次。（外层循环4次。）        for(int i = 0; i &lt; arr.length - 1; i++)&#123;            // i的值是0 1 2 3            // i正好是“参加比较的这堆数据中”最左边那个元素的下标。            //System.out.println(i);            // i是一个参与比较的这堆数据中的起点下标。            // 假设起点i下标位置上的元素是最小的。            int min = i;            for(int j = i+1; j &lt; arr.length; j++)&#123;                count++;                //System.out.println(&quot;===&gt;&quot; + j);                if(arr[j] &lt; arr[min])&#123;                    min = j; //最小值的元素下标是j                &#125;            &#125;            // 当i和min相等时，表示最初猜测是对的。            // 当i和min不相等时，表示最初猜测是错的，有比这个元素更小的元素，            // 需要拿着这个更小的元素和最左边的元素交换位置。            if(min != i)&#123;                // 表示存在更小的数据                // arr[min] 最小的数据                // arr[i] 最前面的数据                int temp;                temp = arr[min];                arr[min] = arr[i];                arr[i] = temp;                count2++;            &#125;        &#125;        // 冒泡排序和选择排序实际上比较的次数没变。        // 交换位置的次数减少了。        System.out.println(&quot;比较次数&quot; + count); // 21        System.out.println(&quot;交换次数：&quot; + count2); // 5        // 排序之后遍历        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.println(arr[i]);        &#125;    &#125;&#125;//1 2 3 4 5//假设1是最小的，结果1确实是最小的，就不需要交换位置。\n\n查找——二分查找(binarySearch)package com.bjpowernode.javase.array;/*1、数组工具类：自己写的。不是SUN的。2、关于查找算法中的：二分法查找。    10(下标0) 11 12 13 14 15 16 17 18 19 20(下标10)   arr数组。    通过二分法查找，找出18这个元素的下标：        (0 + 10) / 2 --&gt; 中间元素的下标： 5    拿着中间这个元素和目标要查找的元素进行对比：        中间元素是：arr[5] --&gt; 15        15 &lt; 18(被查找的元素)        被查找的元素18在目前中间元素15的右边。        所以开始元素的下标从0变成 5 + 1.    再重新计算一个中间元素的下标：        开始下标是：5 + 1        结束下标是：10        (6 + 10) / 2 --&gt; 8    8下标对应的元素arr[8]是18        找到的中间元素正好和被找的的元素18相等，表示找到了：下标为8    二分法查找的终止条件：一直折半，直到中间的那个元素恰好是被查找的元素。3、二分法查找算法是基于排序的基础之上。（没有排序的数据是无法查找的。） */public class ArrayUtil &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;100,200,230,235,600,1000,2000,9999&#125;;        // 找出arr这个数组中200所在的下标。        // 调用方法        int index = binarySearch(arr, 230);        System.out.println(index == -1 ? &quot;该元素不存在！&quot; : &quot;该元素下标&quot; + index);    &#125;    /**     * 从数组中查找目标元素的下标。     * @param arr 被查找的数组（这个必须是已经排序的。）     * @param dest 目标元素     * @return -1表示该元素不存在，其它表示返回该元素的下标。     */    public static int binarySearch(int[] arr, int dest) &#123;        // 开始下标        int begin = 0;        // 结束下标        int end = arr.length - 1;        // 开始元素的下标只要在结束元素下标的左边，就有机会继续循环。        while(begin &lt;= end) &#123;            // 中间元素下标            int mid = (begin + end) / 2;            if (arr[mid] == dest) &#123;                return mid;            &#125; else if (arr[mid] &lt; dest) &#123;                // 目标在“中间”的右边                // 开始元素下标需要发生变化（开始元素的下标需要重新赋值）                begin = mid + 1; // 一直增            &#125; else &#123;                // arr[mid] &gt; dest                // 目标在“中间”的左边                // 修改结束元素的下标                end = mid - 1; // 一直减            &#125;        &#125;        return -1;    &#125;&#125;\n\n","categories":["JavaSE学习日志"]},{"title":"2022.3.10 日志","url":"/2022/03/10/2022310%20%E6%97%A5%E5%BF%97-2022310diary/","content":"又封校了&#x2F;(ㄒoㄒ)&#x2F;~~据说是吉林传来的疫情，道外区一天确诊了7个，刚解封三天又封校了，不愧是你啊哈尔滨！😫\n天香的焖面好吃！上学期去吃过一次，但这次去感觉好吃了很多！真的特别香（而且又不是很贵），好评！以后错峰吃饭时会常去恰的！\n\n好图！今天逛pixiv突然找到了我喜欢的老师的2022虎年贺图，锁屏壁纸安排！\n\n计划泡汤本来打算去尝试一下三星的体验活动（居然有哈尔滨站点！），顺便给电脑清清灰。。都泡汤了&#x2F;(ㄒoㄒ)&#x2F;~~\n\n","categories":["所感"]},{"title":"JavaSE——集合（1）","url":"/2022/08/24/JavaSE%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%EF%BC%881%EF%BC%89-javase%E9%9B%86%E5%90%88/","content":"集合概述什么是集合？有什么用？数组其实就是一个集合。集合实际上就是一个容器。可以来容纳其它类型的数据。\n集合为什么说在开发中使用较多？            集合是一个容器，是一个载体，可以一次容纳多个对象。在实际开发中，假设连接数据库，数据库当中有10条记录，那么假设把这10条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放到某一个集合当中，将集合传到前端，然后遍历集合，将一个数据一个数据展现出来。\n集合不能直接存储基本数据类型，另外集合也不能直接存储java对象集合当中存储的都是java对象的内存地址。（或者说集合中存储的是引用。）        list.add(100); &#x2F;&#x2F;自动装箱Integer        注意：            集合在java中本身是一个容器，是一个对象。            集合中任何时候存储的都是“引用”。\n在java中每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素，等于将数据放到了不同的数据结构当中。        new ArrayList(); 创建一个集合，底层是数组。        new LinkedList(); 创建一个集合对象，底层是链表。        new TreeSet(); 创建一个集合对象，底层是二叉树。        …..\n集合在java JDK中哪个包下？    java.util.*;\n    \n\n在java中集合分为两大类：一类是单个方式存储元素：            单个方式存储元素，这一类集合中超级父接口：java.util.Collection;\n一类是以键值对儿的方式存储元素：以键值对的方式存储元素，这一类集合中超级父接口：java.util.Map;\njava中的集合继承结构图文详解集合继承结构图-Collection\n集合继承结构图-Map\nCollection接口中的常用方法 1、Collection中能存放什么元素？        没有使用“泛型”之前，Collection中可以存储Object的所有子类型。        使用了“泛型”之后，Collection中只能存储某个具体的类型。        集合后期我们会学习“泛型”语法。目前先不用管。Collection中什么都能存，        只要是Object的子类型就行。（集合中不能直接存储基本数据类型，也不能存        java对象，只是存储java对象的内存地址。）    2、Collection中的常用方法        boolean add(Object e) 向集合中添加元素        int size()  获取集合中元素的个数        void clear() 清空集合        boolean contains(Object o) 判断当前集合中是否包含元素o，包含返回true，不包含返回false        boolean remove(Object o) 删除集合中的某个元素。        boolean isEmpty()  判断该集合中元素的个数是否为0        Object[] toArray()  调用这个方法可以把集合转换成数组。【作为了解，使用不多。】\nimport java.util.ArrayList;import java.util.Collection;public class CollectionTest01 &#123;    public static void main(String[] args) &#123;        // 创建一个集合对象        //Collection c = new Collection(); // 接口是抽象的，无法实例化。        // 多态        Collection c = new ArrayList();        // 测试Collection接口中的常用方法        c.add(1200); // 自动装箱(java5的新特性。),实际上是放进去了一个对象的内存地址。Integer x = new Integer(1200);        c.add(3.14); // 自动装箱        c.add(new Object());        c.add(new Student());        c.add(true); // 自动装箱        // 获取集合中元素的个数        System.out.println(&quot;集合中元素个数是：&quot; + c.size()); // 5        // 清空集合        c.clear();        System.out.println(&quot;集合中元素个数是：&quot; + c.size()); // 0        // 再向集合中添加元素        c.add(&quot;hello&quot;); // &quot;hello&quot;对象的内存地址放到了集合当中。        c.add(&quot;world&quot;);        c.add(&quot;浩克&quot;);        c.add(&quot;绿巨人&quot;);        c.add(1);        // 判断集合中是否包含&quot;绿巨人&quot;        boolean flag = c.contains(&quot;绿巨人&quot;);        System.out.println(flag); // true        boolean flag2 = c.contains(&quot;绿巨人2&quot;);        System.out.println(flag2); // false        System.out.println(c.contains(1)); // true        System.out.println(&quot;集合中元素个数是：&quot; + c.size()); // 5        // 删除集合中某个元素        c.remove(1);        System.out.println(&quot;集合中元素个数是：&quot; + c.size()); // 4        // 判断集合是否为空（集合中是否存在元素）        System.out.println(c.isEmpty()); // false        // 清空        c.clear();        System.out.println(c.isEmpty()); // true（true表示集合中没有元素了！）        c.add(&quot;abc&quot;);        c.add(&quot;def&quot;);        c.add(100);        c.add(&quot;helloworld!&quot;);        c.add(new Student());        // 转换成数组（了解，使用不多。）        Object[] objs = c.toArray();        for(int i = 0; i &lt; objs.length; i++)&#123;            // 遍历数组            Object o = objs[i];            System.out.println(o);        &#125;    &#125;&#125;class Student&#123;&#125;\n\n集合遍历&#x2F;迭代(重点！）迭代原理：\n\nimport java.util.ArrayList;import java.util.Collection;import java.util.Iterator;/** * 关于集合遍历/迭代专题。（重点：五颗星*****） */public class CollectionTest02 &#123;    public static void main(String[] args) &#123;        // 注意：以下讲解的遍历方式/迭代方式，是所有Collection通用的一种方式。        // 在Map集合中不能用。在所有的Collection以及子类中使用。        // 创建集合对象        Collection c = new ArrayList(); // 后面的集合无所谓，主要是看前面的Collection接口，怎么遍历/迭代。        // 添加元素        c.add(&quot;abc&quot;);        c.add(&quot;def&quot;);        c.add(100);        c.add(new Object());        // 对集合Collection进行遍历/迭代        // 第一步：获取集合对象的迭代器对象Iterator        Iterator it = c.iterator();        // 第二步：通过以上获取的迭代器对象开始迭代/遍历集合。        /*            以下两个方法是迭代器对象Iterator中的方法：                boolean hasNext()如果仍有元素可以迭代，则返回 true。                Object next() 返回迭代的下一个元素。         */        while(it.hasNext())&#123;            Object obj = it.next();            System.out.println(obj);        &#125;        // 一直取，不判断，会出现异常：java.util.NoSuchElementException        /*while(true)&#123;            Object obj = it.next();            System.out.println(obj);        &#125;*/        /*boolean hasNext = it.hasNext();        System.out.println(hasNext);        if(hasNext) &#123;            // 不管你当初存进去什么，取出来统一都是Object。            Object obj = it.next();            System.out.println(obj);        &#125;        hasNext = it.hasNext();        System.out.println(hasNext);        if(hasNext) &#123;            Object obj = it.next();            System.out.println(obj);        &#125;        hasNext = it.hasNext();        System.out.println(hasNext);        if(hasNext) &#123;            Object obj = it.next();            System.out.println(obj);        &#125;        hasNext = it.hasNext();        System.out.println(hasNext);        if(hasNext) &#123;            Object obj = it.next();            System.out.println(obj);        &#125;        hasNext = it.hasNext();        System.out.println(hasNext);        if(hasNext) &#123;            Object obj = it.next();            System.out.println(obj);        &#125;*/    &#125;&#125;\nimport java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;/*关于集合的迭代/遍历 */public class CollectionTest03 &#123;    public static void main(String[] args) &#123;        // 创建集合对象        Collection c1  = new ArrayList(); // ArrayList集合：有序可重复        // 添加元素        c1.add(1);        c1.add(2);        c1.add(3);        c1.add(4);        c1.add(1);        // 迭代集合        Iterator it = c1.iterator();        while(it.hasNext())&#123;            // 存进去是什么类型，取出来还是什么类型。            Object obj = it.next();            /*if(obj instanceof Integer)&#123;                System.out.println(&quot;Integer类型&quot;);            &#125;*/            // 只不过在输出的时候会转换成字符串。因为这里println会调用toString()方法。            System.out.println(obj);        &#125;        // HashSet集合：无序不可重复        Collection c2 = new HashSet();        // 无序：存进去和取出的顺序不一定相同。        // 不可重复：存储100，不能再存储100.        c2.add(100);        c2.add(200);        c2.add(300);        c2.add(90);        c2.add(400);        c2.add(50);        c2.add(60);        c2.add(100);        Iterator it2 = c2.iterator();        while(it2.hasNext())&#123;            System.out.println(it2.next());        &#125;    &#125;&#125;\n\ncontains方法 &amp; remove方法contains方法深入Collection集合的contains方法：    boolean contains(Object o)        判断集合中是否包含某个对象o        如果包含返回true， 如果不包含返回false。\ncontains方法是用来判断集合中是否包含某个元素的方法，    那么它在底层是怎么判断集合中是否包含某个元素的呢？        调用了equals方法进行比对。        equals方法返回true，就表示包含这个元素。\nimport java.util.ArrayList;import java.util.Collection;public class CollectionTest04 &#123;    public static void main(String[] args) &#123;        // 创建集合对象        Collection c = new ArrayList();        // 向集合中存储元素        String s1 = new String(&quot;abc&quot;); // s1 = 0x1111        c.add(s1); // 放进去了一个&quot;abc&quot;        String s2 = new String(&quot;def&quot;); // s2 = 0x2222        c.add(s2);        // 集合中元素的个数        System.out.println(&quot;元素的个数是：&quot; + c.size()); // 2        // 新建的对象String        String x = new String(&quot;abc&quot;); // x = 0x5555        // c集合中是否包含x？结果猜测一下是true还是false？        System.out.println(c.contains(x)); //判断集合中是否存在&quot;abc&quot; true    &#125;&#125;\n\n\nremove方法关于集合元素的remove    重点：当集合的结构发生改变时，迭代器必须重新获取，如果还是用以前老的迭代器，    会出现异常：java.util.ConcurrentModificationException\n重点：在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素c.remove(o); 迭代过程中不能这样。会出现：java.util.ConcurrentModificationException\n重点：在迭代元素的过程当中，一定要使用迭代器Iterator的remove方法，删除元素，不要使用集合自带的remove方法删除元素。\nimport java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class CollectionTest06 &#123;    public static void main(String[] args) &#123;        // 创建集合        Collection c = new ArrayList();        // 注意：此时获取的迭代器，指向的是那是集合中没有元素状态下的迭代器。        // 一定要注意：集合结构只要发生改变，迭代器必须重新获取。        // 当集合结构发生了改变，迭代器没有重新获取时，调用next()方法时：java.util.ConcurrentModificationException        Iterator it = c.iterator();        // 添加元素        c.add(1); // Integer类型        c.add(2);        c.add(3);        // 获取迭代器        //Iterator it = c.iterator();        /*while(it.hasNext())&#123;            // 编写代码时next()方法返回值类型必须是Object。            // Integer i = it.next();            Object obj = it.next();            System.out.println(obj);        &#125;*/        Collection c2 = new ArrayList();        c2.add(&quot;abc&quot;);        c2.add(&quot;def&quot;);        c2.add(&quot;xyz&quot;);        Iterator it2 = c2.iterator();        while(it2.hasNext())&#123;            Object o = it2.next();            // 删除元素            // 删除元素之后，集合的结构发生了变化，应该重新去获取迭代器            // 但是，循环下一次的时候并没有重新获取迭代器，所以会出现异常：java.util.ConcurrentModificationException            // 出异常根本原因是：集合中元素删除了，但是没有更新迭代器（迭代器不知道集合变化了）            //c2.remove(o); // 直接通过集合去删除元素，没有通知迭代器。（导致迭代器的快照和原集合状态不同。）            // 使用迭代器来删除可以吗？            // 迭代器去删除时，会自动更新迭代器，并且更新集合（删除集合中的元素）。            it2.remove(); // 删除的一定是迭代器指向的当前元素。            System.out.println(o);        &#125;        System.out.println(c2.size()); //0    &#125;&#125;\n\n测试import java.util.ArrayList;import java.util.Collection;/*测试contains方法测试remove方法。结论：存放在一个集合中的类型，一定要重写equals方法。 */public class CollectionTest05 &#123;    public static void main(String[] args) &#123;        // 创建集合对象        Collection c = new ArrayList();        // 创建用户对象        User u1 = new User(&quot;jack&quot;);        // 加入集合        c.add(u1);        // 判断集合中是否包含u2        User u2 = new User(&quot;jack&quot;);        // 没有重写equals之前：这个结果是false        //System.out.println(c.contains(u2)); // false        // 重写equals方法之后，比较的时候会比较name。        System.out.println(c.contains(u2)); // true        c.remove(u2);        System.out.println(c.size()); // 0        /*Integer x = new Integer(10000);        c.add(x);        Integer y = new Integer(10000);        System.out.println(c.contains(y)); // true*/        // 创建集合对象        Collection cc = new ArrayList();        // 创建字符串对象        String s1 = new String(&quot;hello&quot;);        // 加进去。        cc.add(s1);        // 创建了一个新的字符串对象        String s2 = new String(&quot;hello&quot;);        // 删除s2        cc.remove(s2); // s1.equals(s2) java认为s1和s2是一样的。删除s2就是删除s1。        // 集合中元素个数是？        System.out.println(cc.size()); // 0    &#125;&#125;class User&#123;    private String name;    public User()&#123;&#125;    public User(String name)&#123;        this.name = name;    &#125;    // 重写equals方法    // 将来调用equals方法的时候，一定是调用这个重写的equals方法。    // 这个equals方法的比较原理是：只要姓名一样就表示同一个用户。    public boolean equals(Object o) &#123;        if(o == null || !(o instanceof User)) return false;        if(o == this) return true;        User u = (User)o;        // 如果名字一样表示同一个人。（不再比较对象的内存地址了。比较内容。）        return u.name.equals(this.name);    &#125;&#125;\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——注解","url":"/2022/09/11/JavaSE%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3-javaseannotation/","content":"注解（注释类型）注解Annotation是一种引用数据类型。编译之后也是生成xxx.class文件\n自定义注解[修饰符列表] @interface 注解类型名{\n}\n// 默认情况下，注解可以出现在任意位置。@MyAnnotationpublic class AnnotationTest01 &#123;    @MyAnnotation    private int no;    @MyAnnotation    public AnnotationTest01()&#123;&#125;    @MyAnnotation    public static void m1()&#123;        @MyAnnotation        int i = 100;    &#125;    @MyAnnotation    public void m2(@MyAnnotation                   String name,                   @MyAnnotation                   int k)&#123;    &#125;&#125;@MyAnnotationinterface MyInterface &#123;&#125;@MyAnnotationenum Season &#123;    SPRING,SUMMER,AUTUMN,WINTER&#125;\n\nJDK内置的注解java.lang包下的注释类型：\n掌握：            Deprecated 用 @Deprecated 注释的程序元素，            不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。 \n掌握：            Override 表示一个方法声明打算重写超类中的另一个方法声明。 \n不用掌握：            SuppressWarnings 指示应该在注释元素（以及包含在该注释元素中的所有程序元素）中取消显示指定的编译器警告。 \n@Override源代码：public @interface Override {}\n标识性注解，给编译器做参考的。编译器看到方法上有这个注解的时候，编译器会自动检查该方法是否重写了父类的方法。如果没有重写，报错。  \n这个注解只是在编译阶段起作用，和运行期无关！\n@Override这个注解只能注解方法。@Override这个注解是给编译器参考的，和运行阶段没有关系。凡是java中的方法带有这个注解的，编译器都会进行编译检查，如果这个方法不是重写父类的方法，编译器报错。\npublic class AnnotationTest02 &#123;    //@Override    private int no;    @Override    public String toString() &#123;        return &quot;toString&quot;;    &#125;&#125;\n\n@DeprecatedDeprecated 用 @Deprecated 注释的程序元素，不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。\npackage com.bjpowernode.java.annotation;// 表示这个类已过时。@Deprecatedpublic class AnnotationTest03 &#123;    @Deprecated    private String s;    public static void main(String[] args) &#123;        AnnotationTest03 at = new AnnotationTest03();        at.doSome();    &#125;    @Deprecated    public void doSome()&#123;        System.out.println(&quot;do something!&quot;);    &#125;    // Deprecated这个注解标注的元素已过时。    // 这个注解主要是向其它程序员传达一个信息，告知已过时，有更好的解决方案存在。    @Deprecated    public static void doOther()&#123;        System.out.println(&quot;do other...&quot;);    &#125;&#125;class T &#123;    public static void main(String[] args) &#123;        AnnotationTest03 at = new AnnotationTest03();        at.doSome();        AnnotationTest03.doOther();        try &#123;            Class c = Class.forName(&quot;java.util.Date&quot;);            Object obj = c.newInstance();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n注解中定义属性public class MyAnnotationTest &#123;    // 报错的原因：如果一个注解当中有属性，那么必须给属性赋值。（除非该属性使用default指定了默认值。）    /*@MyAnnotation    public void doSome()&#123;    &#125;*/    //@MyAnnotation(属性名=属性值,属性名=属性值,属性名=属性值)    //指定name属性的值就好了。    @MyAnnotation(name = &quot;zhangsan&quot;, color = &quot;红色&quot;)    public void doSome()&#123;    &#125;&#125;\n\npublic @interface MyAnnotation &#123;    /**     * 我们通常在注解当中可以定义属性，以下这个是MyAnnotation的name属性。     * 看着像1个方法，但实际上我们称之为属性name。     * @return     */    String name();    /*    颜色属性     */    String color();    /*    年龄属性     */    int age() default 25; //属性指定默认值&#125;\n\n如果一个注解的属性的名字是value，并且只有一个属性的话，在使用的时候，该属性名可以省略。\npublic class MyAnnotationTest &#123;    // 报错原因：没有指定属性的值。    /*@MyAnnotation    public void doSome()&#123;    &#125;*/    @MyAnnotation(value = &quot;hehe&quot;)    public void doSome()&#123;    &#125;    @MyAnnotation(&quot;haha&quot;)    public void doOther()&#123;    &#125;&#125;\n\npublic @interface MyAnnotation &#123;    /*    指定一个value属性。     */    String value();    //String email();&#125;\n\n注解当中的属性可以是哪一种类型？属性的类型可以是：byte short int long float double boolean char String Class 枚举类型以及以上每一种的数组形式。\n元注解用来标注“注解类型”的“注解”，称为元注解。\n常见的元注解  TargetRetention\n关于Target注解：这是一个元注解，用来标注“注解类型”的“注解”这个Target注解用来标注“被标注的注解”可以出现在哪些位置上。\n@Target(ElementType.METHOD)：表示“被标注的注解”只能出现在方法上。            @Target(value&#x3D;{CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})                表示该注解可以出现在：                    构造方法上                    字段上                    局部变量上                    方法上                    ….                    类上…  \n关于Retention注解：这是一个元注解，用来标注“注解类型”的“注解”这个Retention注解用来标注“被标注的注解”最终保存在哪里。  \n@Retention(RetentionPolicy.SOURCE)：表示该注解只被保留在java源文件中。            @Retention(RetentionPolicy.CLASS)：表示该注解被保存在class文件中。            @Retention(RetentionPolicy.RUNTIME)：表示该注解被保存在class文件中，并且可以被反射机制所读取。\npackage com.bjpowernode.java.annotation5;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//只允许该注解可以标注类、方法@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)// 希望这个注解可以被反射@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123;    /*    value属性。     */    String value() default &quot;北京大兴区&quot;;&#125;\n\npublic class ReflectAnnotationTest &#123;    public static void main(String[] args) throws Exception&#123;        // 获取这个类        Class c = Class.forName(&quot;com.bjpowernode.java.annotation5.MyAnnotationTest&quot;);        // 判断类上面是否有@MyAnnotation        //System.out.println(c.isAnnotationPresent(MyAnnotation.class)); // true        if(c.isAnnotationPresent(MyAnnotation.class))&#123;            // 获取该注解对象            MyAnnotation myAnnotation = (MyAnnotation)c.getAnnotation(MyAnnotation.class);            //System.out.println(&quot;类上面的注解对象&quot; + myAnnotation); // @com.bjpowernode.java.annotation5.MyAnnotation()            // 获取注解对象的属性怎么办？和调接口没区别。            String value = myAnnotation.value();            System.out.println(value);        &#125;        // 判断String类上面是否存在这个注解        Class stringClass = Class.forName(&quot;java.lang.String&quot;);        System.out.println(stringClass.isAnnotationPresent(MyAnnotation.class)); // false    &#125;&#125;\n\n通过反射机制获取注解对象属性的值import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyAnnotation &#123;    /*    username属性     */    String username();    /*    password属性     */    String password();&#125;\n\nimport java.lang.reflect.Method;public class MyAnnotationTest &#123;    @MyAnnotation(username = &quot;admin&quot;, password = &quot;456456&quot;)    public void doSome()&#123;    &#125;    public static void main(String[] args) throws Exception&#123;        // 获取MyAnnotationTest的doSome()方法上面的注解信息。        Class c = Class.forName(&quot;com.bjpowernode.java.annotation6.MyAnnotationTest&quot;);        // 获取doSome()方法        Method doSomeMethod = c.getDeclaredMethod(&quot;doSome&quot;);        // 判断该方法上是否存在这个注解        if(doSomeMethod.isAnnotationPresent(MyAnnotation.class)) &#123;            MyAnnotation myAnnotation = doSomeMethod.getAnnotation(MyAnnotation.class);            System.out.println(myAnnotation.username());            System.out.println(myAnnotation.password());        &#125;    &#125;&#125;\n\n注解在开发中的作用需求：假设有这样一个注解，叫做：@Id这个注解只能出现在类上面，当这个类上有这个注解的时候，要求这个类中必须有一个int类型的id属性。如果没有这个属性就报异常。如果有这个属性则正常执行！\npublic class HasNotIdPropertyException extends RuntimeException &#123;    public HasNotIdPropertyException()&#123;    &#125;    public HasNotIdPropertyException(String s)&#123;        super(s);    &#125;&#125;\n\nimport java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;// 表示这个注解只能出现在类上面@Target(ElementType.TYPE)// 该注解可以被反射机制读取到@Retention(RetentionPolicy.RUNTIME)public @interface MustHasIdPropertyAnnotation &#123;&#125;// 这个注解@Id用来标注类，被标注的类中必须有一个int类型的id属性，没有就报异常。\n\n@MustHasIdPropertyAnnotationpublic class User &#123;    int id;    String name;    String password;&#125;\n\nimport java.lang.reflect.Field;public class Test &#123;    public static void main(String[] args) throws Exception&#123;        // 获取类        Class userClass = Class.forName(&quot;com.bjpowernode.java.annotation7.User&quot;);        // 判断类上是否存在Id注解        if(userClass.isAnnotationPresent(MustHasIdPropertyAnnotation.class))&#123;            // 当一个类上面有@MustHasIdPropertyAnnotation注解的时候，要求类中必须存在int类型的id属性            // 如果没有int类型的id属性则报异常。            // 获取类的属性            Field[] fields = userClass.getDeclaredFields();            boolean isOk = false; // 给一个默认的标记            for(Field field : fields)&#123;                if(&quot;id&quot;.equals(field.getName()) &amp;&amp; &quot;int&quot;.equals(field.getType().getSimpleName()))&#123;                    // 表示这个类是合法的类。有@Id注解，则这个类中必须有int类型的id                    isOk = true; // 表示合法                    break;                &#125;            &#125;            // 判断是否合法            if(!isOk)&#123;                throw new HasNotIdPropertyException(&quot;被@MustHasIdPropertyAnnotation注解标注的类中必须要有一个int类型的id属性！&quot;);            &#125;        &#125;    &#125;&#125;","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——集合（2)","url":"/2022/08/30/JavaSE%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%EF%BC%882)-2022-08-30-23-10-01/","content":"List接口List接口中常用方法    1、List集合存储元素特点：有序可重复        有序：List集合中的元素有下标。        从0开始，以1递增。        可重复：存储一个1，还可以再存储1.    2、List既然是Collection接口的子接口，那么肯定List接口有自己“特色”的方法：        以下只列出List接口特有的常用的方法：            void add(int index, Object element)            Object set(int index, Object element)            Object get(int index)            int indexOf(Object o)            int lastIndexOf(Object o)            Object remove(int index)\n3、迭代器迭代元素的过程中不能使用集合对象的remove方法删除元素，要使用迭代器Iterator的remove方法来删除元素，防止出现异常：    ConcurrentModificationException\n以上几个方法不需要死记硬背，可以自己编写代码测试一下，理解一下，        以后开发的时候，还是要翻阅帮助文档。\nimport java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;import java.util.List;public class ListTest01 &#123;    public static void main(String[] args) &#123;        // 创建List类型的集合。        //List myList = new LinkedList();        //List myList = new Vector();        List myList = new ArrayList();        // 添加元素        myList.add(&quot;A&quot;); // 默认都是向集合末尾添加元素。        myList.add(&quot;B&quot;);        myList.add(&quot;C&quot;);        myList.add(&quot;C&quot;);        myList.add(&quot;D&quot;);        //在列表的指定位置插入指定元素（第一个参数是下标）        // 这个方法使用不多，因为对于ArrayList集合来说效率比较低。        myList.add(1, &quot;KING&quot;);        // 迭代        Iterator it = myList.iterator();        while(it.hasNext())&#123;            Object elt = it.next();            System.out.println(elt);        &#125;        // 根据下标获取元素        Object firstObj = myList.get(0);        System.out.println(firstObj);        // 因为有下标，所以List集合有自己比较特殊的遍历方式        // 通过下标遍历。【List集合特有的方式，Set没有。】        for(int i = 0; i &lt; myList.size(); i++)&#123;            Object obj = myList.get(i);            System.out.println(obj);        &#125;        // 获取指定对象第一次出现处的索引。        System.out.println(myList.indexOf(&quot;C&quot;)); // 3        // 获取指定对象最后一次出现处的索引。        System.out.println(myList.lastIndexOf(&quot;C&quot;)); // 4        // 删除指定下标位置的元素        // 删除下标为0的元素        myList.remove(0);        System.out.println(myList.size()); // 5        System.out.println(&quot;====================================&quot;);        // 修改指定位置的元素        myList.set(2, &quot;Soft&quot;);        // 遍历集合        for(int i = 0; i &lt; myList.size(); i++)&#123;            Object obj = myList.get(i);            System.out.println(obj);        &#125;    &#125;&#125;\n\nArrayList集合1、默认初始化容量10（底层先创建了一个长度为0的数组，当添加第一个元素的时候，初始化容量10。）\n2、集合底层是一个Object[]数组。\n 3、构造方法：        new ArrayList();        new ArrayList(20);\n4、ArrayList集合的扩容：        增长到原容量的1.5倍。        ArrayList集合底层是数组，怎么优化？            尽可能少的扩容。因为数组扩容效率比较低，建议在使用ArrayList集合的时候预估计元素的个数，给定一个初始化容量。\n5、数组优点：        检索效率比较高。（每个元素占用空间大小相同，内存地址是连续的，知道首元素内存地址，然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高。）\n6、数组缺点：        随机增删元素效率比较低。        另外数组无法存储大数据量。（很难找到一块非常巨大的连续的内存空间。）\n  7、向数组末尾添加元素，效率很高，不受影响。\n  8、面试官经常问的一个问题？        这么多的集合中，你用哪个集合最多？            答：ArrayList集合。            因为往数组末尾添加元素，效率不受影响。            另外，我们检索&#x2F;查找某个元素的操作比较多。\n9、ArrayList集合是非线程安全的。（不是线程安全的集合。）\nimport java.util.ArrayList;import java.util.List;public class ArrayListTest01 &#123;    public static void main(String[] args) &#123;        // 默认初始化容量是10        // 数组的长度是10        List list1 = new ArrayList();        // 集合的size()方法是获取当前集合中元素的个数。不是获取集合的容量。        System.out.println(list1.size()); // 0        // 指定初始化容量        // 数组的长度是20        List list2 = new ArrayList(20);        // 集合的size()方法是获取当前集合中元素的个数。不是获取集合的容量。        System.out.println(list2.size()); // 0        list1.add(1);        list1.add(2);        list1.add(3);        list1.add(4);        list1.add(5);        list1.add(6);        list1.add(7);        list1.add(8);        list1.add(9);        list1.add(10);        System.out.println(list1.size());        // 再加一个元素        list1.add(11);        System.out.println(list1.size()); // 11个元素。        /*        int newCapacity = ArraysSupport.newLength(oldCapacity,minCapacity - oldCapacity,oldCapacity &gt;&gt; 1);         */        // 100 二进制转换成10进制： 00000100右移一位 00000010 （2）  【4 / 2】        // 原先是4、现在增长：2，增长之后是6，增长之后的容量是之前容量的：1.5倍。        // 6是4的1.5倍    &#125;&#125;\n\n集合ArrayList的构造方法:\nimport java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.List;/*集合ArrayList的构造方法 */public class ArrayListTest02 &#123;    public static void main(String[] args) &#123;        // 默认初始化容量10        List myList1 = new ArrayList();        // 指定初始化容量100        List myList2 = new ArrayList(100);        // 创建一个HashSet集合        Collection c = new HashSet();        // 添加元素到Set集合        c.add(100);        c.add(200);        c.add(900);        c.add(50);        // 通过这个构造方法就可以将HashSet集合转换成List集合。        List myList3 = new ArrayList(c);        for(int i = 0; i &lt; myList3.size(); i++)&#123;            System.out.println(myList3.get(i));        &#125;    &#125;&#125;\n二进制位运算/*位运算符 &gt;&gt; */public class BinaryTest &#123;    public static void main(String[] args) &#123;        // 5        // &gt;&gt; 1 二进制右移1位。        // &gt;&gt; 2 二进制右移2位。        // 10的二进制位是：00001010  【10】        // 10的二进制右移1位是：00000101  【5】        System.out.println(10 &gt;&gt; 1); // 右移1位就是除以2        // 二进制位左移1位        // 10的二进制位是：00001010  【10】        // 10的二进制左移1位：00010100 【20】        System.out.println(10 &lt;&lt; 1);    &#125;&#125;\n单向链表Link.java:\npublic class Link&lt;E&gt; &#123;    public static void main(String[] args) &#123;        Link&lt;String&gt; link = new Link&lt;&gt;();        link.add(&quot;abc&quot;);        // 类型不匹配。        //link.add(123);    &#125;    // 头节点    Node header;    int size = 0;    public int size()&#123;        return size;    &#125;    // 向链表中添加元素的方法（向末尾添加）    public void add(E data)&#123;    //public void add(Object data)&#123;        // 创建一个新的节点对象        // 让之前单链表的末尾节点next指向新节点对象。        // 有可能这个元素是第一个，也可能是第二个，也可能是第三个。        if(header == null)&#123;            // 说明还没有节点。            // new一个新的节点对象，作为头节点对象。            // 这个时候的头节点既是一个头节点，又是一个末尾节点。            header = new Node(data, null);        &#125;else &#123;            // 说明头不是空！            // 头节点已经存在了！            // 找出当前末尾节点，让当前末尾节点的next是新节点。            Node currentLastNode = findLast(header);            currentLastNode.next = new Node(data, null);        &#125;        size++;    &#125;    /**     * 专门查找末尾节点的方法。     */    private Node findLast(Node node) &#123;        if(node.next == null) &#123;            // 如果一个节点的next是null            // 说明这个节点就是末尾节点。            return node;        &#125;        // 程序能够到这里说明：node不是末尾节点。        return findLast(node.next); // 递归算法！    &#125;    // 删除链表中某个数据的方法    public void remove(Object obj)&#123;    &#125;    // 修改链表中某个数据的方法    public void modify(Object newObj)&#123;    &#125;    // 查找链表中某个元素的方法。    public int find(Object obj)&#123;        return 1;    &#125;&#125;\n\nNode.java:\npublic class Node &#123;    // 存储的数据    Object data;    // 下一个节点的内存地址    Node next;    public Node()&#123;    &#125;    public Node(Object data, Node next)&#123;        this.data = data;        this.next = next;    &#125;&#125;\n\n\nTest.java:\npublic class Test &#123;    public static void main(String[] args) &#123;        // 创建了一个集合对象        Link link = new Link();        // 往集合中添加元素        link.add(&quot;abc&quot;);        link.add(&quot;def&quot;);        link.add(&quot;xyz&quot;);        // 获取元素个数        System.out.println(link.size());    &#125;&#125;\n\n理解数据结构\n优缺点是重点！\n链表的优点：    由于链表上的元素在空间存储上内存地址不连续。    所以随机增删元素的时候不会有大量元素位移，因此随机增删效率较高。    在以后的开发中，如果遇到随机增删集合中元素的业务比较多时，建议使用LinkedList。\n链表的缺点：    不能通过数学表达式计算被查找元素的内存地址，每一次查找都是从头节点开始遍历，直到找到为止。所以LinkedList集合检索&#x2F;查找的效率较低。\nArrayList：把检索发挥到极致。（末尾添加元素效率还是很高的。）    LinkedList：把随机增删发挥到极致。    加元素都是往末尾添加，所以ArrayList用的比LinkedList多。\n\nimport java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class LinkedListTest01 &#123;    public static void main(String[] args) &#123;        // LinkedList集合底层也是有下标的。        // 注意：ArrayList之所以检索效率比较高，不是单纯因为下标的原因。是因为底层数组发挥的作用。        // LinkedList集合照样有下标，但是检索/查找某个元素的时候效率比较低，因为只能从头节点开始一个一个遍历。        List list = new LinkedList();        list.add(&quot;a&quot;);        list.add(&quot;b&quot;);        list.add(&quot;c&quot;);        for(int i = 0; i &lt;list.size(); i++)&#123;            Object obj = list.get(i);            System.out.println(obj);        &#125;        // LinkedList集合有初始化容量吗？没有。        // 最初这个链表中没有任何元素。first和last引用都是null。        // 不管是LinkedList还是ArrayList，以后写代码时不需要关心具体是哪个集合。        // 因为我们要面向接口编程，调用的方法都是接口中的方法。        //List list2 = new ArrayList(); // 这样写表示底层你用了数组。        List list2 = new LinkedList(); // 这样写表示底层你用了双向链表。        // 以下这些方法你面向的都是接口编程。        list2.add(&quot;123&quot;);        list2.add(&quot;456&quot;);        list2.add(&quot;789&quot;);        for(int i = 0; i &lt; list2.size(); i++)&#123;            System.out.println(list2.get(i));        &#125;    &#125;&#125;\n\n\n\nVector1、底层也是一个数组。    2、初始化容量：10    3、怎么扩容的？        扩容之后是原容量的2倍。        10–&gt; 20 –&gt; 40 –&gt; 80\n4、ArrayList集合扩容特点：        ArrayList集合扩容是原容量1.5倍。\n5、Vector中所有的方法都是线程同步的，都带有synchronized关键字，    是线程安全的。效率比较低，使用较少了。\n6、怎么将一个线程不安全的ArrayList集合转换成线程安全的呢？        使用集合工具类：            java.util.Collections;\njava.util.Collection 是集合接口。          java.util.Collections 是集合工具类。\nimport java.util.*;public class VectorTest &#123;    public static void main(String[] args) &#123;        // 创建一个Vector集合        List vector = new Vector();        //Vector vector = new Vector();        // 添加元素        // 默认容量10个。        vector.add(1);        vector.add(2);        vector.add(3);        vector.add(4);        vector.add(5);        vector.add(6);        vector.add(7);        vector.add(8);        vector.add(9);        vector.add(10);        // 满了之后扩容（扩容之后的容量是20.）        vector.add(11);        Iterator it = vector.iterator();        while(it.hasNext())&#123;            Object obj = it.next();            System.out.println(obj);        &#125;        // 这个可能以后要使用！！！！        List myList = new ArrayList(); // 非线程安全的。        // 变成线程安全的        Collections.synchronizedList(myList); // 这里没有办法看效果，因为多线程没学，你记住先！        // myList集合就是线程安全的了。        myList.add(&quot;111&quot;);        myList.add(&quot;222&quot;);        myList.add(&quot;333&quot;);    &#125;&#125;\n\n泛型1、JDK5.0之后推出的新特性：泛型\n2、泛型这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。（运行阶段泛型没用！）\n3、使用了泛型好处是什么？    第一：集合中存储的元素类型统一了。    第二：从集合中取出的元素类型是泛型指定的类型，不需要进行大量的“向下转型”！\n4、泛型的缺点是什么？    导致集合中存储的元素缺乏多样性！    大多数业务中，集合中元素的类型还是统一的。所以这种泛型特性被大家所认可。\nimport java.util.ArrayList;import java.util.Iterator;import java.util.List;public class GenericTest01 &#123;    public static void main(String[] args) &#123;        /*        // 不使用泛型机制，分析程序存在缺点        List myList = new ArrayList();        // 准备对象        Cat c = new Cat();        Bird b = new Bird();        // 将对象添加到集合当中        myList.add(c);        myList.add(b);        // 遍历集合，取出每个Animal，让它move        Iterator it = myList.iterator();        while(it.hasNext()) &#123;            // 没有这个语法，通过迭代器取出的就是Object            //Animal a = it.next();            Object obj = it.next();            //obj中没有move方法，无法调用，需要向下转型！            if(obj instanceof Animal)&#123;                Animal a = (Animal)obj;                a.move();            &#125;        &#125;         */        // 使用JDK5之后的泛型机制        // 使用泛型List&lt;Animal&gt;之后，表示List集合中只允许存储Animal类型的数据。        // 用泛型来指定集合中存储的数据类型。        List&lt;Animal&gt; myList = new ArrayList&lt;Animal&gt;();        // 指定List集合中只能存储Animal，那么存储String就编译报错了。        // 这样用了泛型之后，集合中元素的数据类型更加统一了。        //myList.add(&quot;abc&quot;);        Cat c = new Cat();        Bird b = new Bird();        myList.add(c);        myList.add(b);        // 获取迭代器        // 这个表示迭代器迭代的是Animal类型。        Iterator&lt;Animal&gt; it = myList.iterator();        while(it.hasNext())&#123;            // 使用泛型之后，每一次迭代返回的数据都是Animal类型。            //Animal a = it.next();            // 这里不需要进行强制类型转换了。直接调用。            //a.move();            // 调用子类型特有的方法还是需要向下转换的！            Animal a = it.next();            if(a instanceof Cat) &#123;                Cat x = (Cat)a;                x.catchMouse();            &#125;            if(a instanceof Bird) &#123;                Bird y = (Bird)a;                y.fly();            &#125;        &#125;    &#125;&#125;class Animal &#123;    // 父类自带方法    public void move()&#123;        System.out.println(&quot;动物在移动！&quot;);    &#125;&#125;class Cat extends Animal &#123;    // 特有方法    public void catchMouse()&#123;        System.out.println(&quot;猫抓老鼠！&quot;);    &#125;&#125;class Bird extends Animal &#123;    // 特有方法    public void fly()&#123;        System.out.println(&quot;鸟儿在飞翔！&quot;);    &#125;&#125;\n\n自动类型推断机制（又称为钻石表达式）:List list &#x3D; new ArrayList&lt;&gt;();\nimport java.util.ArrayList;import java.util.Iterator;import java.util.List;/*JDK之后引入了：自动类型推断机制。（又称为钻石表达式） */public class GenericTest02 &#123;    public static void main(String[] args) &#123;        // ArrayList&lt;这里的类型会自动推断&gt;()，前提是JDK8之后才允许。        // 自动类型推断，钻石表达式！        List&lt;Animal&gt; myList = new ArrayList&lt;&gt;();        myList.add(new Animal());        myList.add(new Cat());        myList.add(new Bird());        // 遍历        Iterator&lt;Animal&gt; it = myList.iterator();        while(it.hasNext())&#123;            Animal a = it.next();            a.move();        &#125;        List&lt;String&gt; strList = new ArrayList&lt;&gt;();        // 类型不匹配。        //strList.add(new Cat());        strList.add(&quot;http://www.126.com&quot;);        strList.add(&quot;http://www.baidu.com&quot;);        strList.add(&quot;http://www.bjpowernode.com&quot;);        // 类型不匹配。        //strList.add(123);        //System.out.println(strList.size());        // 遍历        Iterator&lt;String&gt; it2 = strList.iterator();        while(it2.hasNext())&#123;            // 如果没有使用泛型            /*            Object obj = it2.next();            if(obj instanceof String)&#123;                String ss = (String)obj;                ss.substring(7);            &#125;             */            // 直接通过迭代器获取了String类型的数据            String s = it2.next();            // 直接调用String类的substring方法截取字符串。            String newString = s.substring(7);            System.out.println(newString);        &#125;    &#125;&#125;\n自定义泛型\n/*自定义泛型可以吗？可以    自定义泛型的时候，&lt;&gt; 尖括号中的是一个标识符，随便写。    java源代码中经常出现的是：        &lt;E&gt;和&lt;T&gt;    E是Element单词首字母。    T是Type单词首字母。 */public class GenericTest03&lt;标识符随便写&gt; &#123;    public void doSome(标识符随便写 o)&#123;        System.out.println(o);    &#125;    public static void main(String[] args) &#123;        // new对象的时候指定了泛型是：String类型        GenericTest03&lt;String&gt; gt = new GenericTest03&lt;&gt;();        // 类型不匹配        //gt.doSome(100);        gt.doSome(&quot;abc&quot;);        // =============================================================        GenericTest03&lt;Integer&gt; gt2 = new GenericTest03&lt;&gt;();        gt2.doSome(100);        // 类型不匹配        //gt2.doSome(&quot;abc&quot;);        MyIterator&lt;String&gt; mi = new MyIterator&lt;&gt;();        String s1 = mi.get();        MyIterator&lt;Animal&gt; mi2 = new MyIterator&lt;&gt;();        Animal a = mi2.get();        // 不用泛型就是Object类型。        /*GenericTest03 gt3 = new GenericTest03();        gt3.doSome(new Object());*/    &#125;&#125;class MyIterator&lt;T&gt; &#123;    public T get()&#123;        return null;    &#125;&#125;\nforeach  对数组怎么遍历？        for(int i : arr){            System.out.println(i);        }    对集合怎么遍历？        for(String s : list){            System.out.println(s);        }\n/*JDK5.0之后推出了一个新特性：叫做增强for循环，或者叫做foreach */public class ForEachTest01 &#123;    public static void main(String[] args) &#123;        // int类型数组        int[] arr = &#123;432,4,65,46,54,76,54&#125;;        // 遍历数组（普通for循环）        for(int i = 0; i &lt; arr.length; i++) &#123;            System.out.println(arr[i]);        &#125;        // 增强for（foreach）        // 以下是语法        /*for(元素类型 变量名 : 数组或集合)&#123;            System.out.println(变量名);        &#125;*/        System.out.println(&quot;======================================&quot;);        // foreach有一个缺点：没有下标。在需要使用下标的循环中，不建议使用增强for循环。        for(int data : arr) &#123;            // data就是数组中的元素（数组中的每一个元素。）            System.out.println(data);        &#125;    &#125;&#125;\nimport java.util.ArrayList;import java.util.Iterator;import java.util.List;/*集合使用foreach */public class ForEachTest02 &#123;    public static void main(String[] args) &#123;        // 创建List集合        List&lt;String&gt; strList = new ArrayList&lt;&gt;();        // 添加元素        strList.add(&quot;hello&quot;);        strList.add(&quot;world!&quot;);        strList.add(&quot;kitty!&quot;);        // 遍历，使用迭代器方式        Iterator&lt;String&gt; it = strList.iterator();        while(it.hasNext())&#123;            String s = it.next();            System.out.println(s);        &#125;        // 使用下标方式（只针对于有下标的集合）        for(int i = 0; i &lt; strList.size(); i++)&#123;            System.out.println(strList.get(i));        &#125;        // 使用foreach        for(String s : strList)&#123; // 因为泛型使用的是String类型，所以是：String s            System.out.println(s);        &#125;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(100);        list.add(200);        list.add(300);        for(Integer i : list)&#123; // i代表集合中的元素            System.out.println(i);        &#125;    &#125;&#125;\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志1","url":"/2022/04/21/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%971-java1/","content":"今天开始正式规范地学Java了，希望暑假之前能搞完基本语法。。\n1.对程序进行解释：   需要记忆：        * public        * class        * static        * void        * System.out.println(“”); 向控制台输出消息        * 类体        * 方法体        * 类体中不能直接编写java语句【除声明变量之外】        * 一个java语句必须以“;”结束        * 方法体中可以编写多条java语句        * 主方法是程序的入口，固定写法，SUN规定的。\n2.public class 和 class的区别：* 一个java源文件当中可以定义多个class\n\n* 一个java源文件当中public的class不是必须的\n\n* 一个class会定义生成一个xxx.class字节码文件\n\n* 一个java源文件当中定义公开的类的话，只能有一个，并且该类名称必须和java源文件名称一致。\n\n* 每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class中的main方法：java B，\n想执行X.class当中的main方法：java X\n\n* 注意：当在命令窗口中执行java Hello，那么要求Hello.class当中必须有主方法。没有主方法会出现运行\n阶段的错误：\n    D:\\course\\JavaProjects\\02-JavaSE\\day02&gt;java Hello\n    错误: 在类 B 中找不到主方法, 请将主方法定义为:\n        public static void main(String[] args)\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"JavaSE——集合（3）与集合总结","url":"/2022/09/02/JavaSE%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%EF%BC%883%EF%BC%89%E4%B8%8E%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93-2022-09-02-17-03-49/","content":"HashSet与TreeSetHashSetimport java.util.HashSet;import java.util.Set;/*HashSet集合：    无序不可重复。 */public class HashSetTest01 &#123;    public static void main(String[] args) &#123;        // 演示一下HashSet集合特点        Set&lt;String&gt; strs = new HashSet&lt;&gt;();        // 添加元素        strs.add(&quot;hello3&quot;);        strs.add(&quot;hello4&quot;);        strs.add(&quot;hello1&quot;);        strs.add(&quot;hello2&quot;);        strs.add(&quot;hello3&quot;);        strs.add(&quot;hello3&quot;);        strs.add(&quot;hello3&quot;);        strs.add(&quot;hello3&quot;);        // 遍历        /*        hello1        hello4        hello2        hello3        1、存储时顺序和取出的顺序不同。        2、不可重复。        3、放到HashSet集合中的元素实际上是放到HashMap集合的key部分了。         */        for(String s : strs)&#123;            System.out.println(s);        &#125;    &#125;&#125;\n\nTreeSetTreeSet集合存储元素特点：1、无序不可重复的，但是存储的元素可以自动按照大小顺序排序！称为：可排序集合。\n2、无序：这里的无序指的是存进去的顺序和取出来的顺序不同。并且没有下标。\nimport java.util.Set;import java.util.TreeSet;public class TreeSetTest01 &#123;    public static void main(String[] args) &#123;        // 创建集合对象        Set&lt;String&gt; strs = new TreeSet&lt;&gt;();        // 添加元素        strs.add(&quot;A&quot;);        strs.add(&quot;B&quot;);        strs.add(&quot;Z&quot;);        strs.add(&quot;Y&quot;);        strs.add(&quot;Z&quot;);        strs.add(&quot;K&quot;);        strs.add(&quot;M&quot;);        // 遍历        /*            A            B            K            M            Y            Z        从小到大自动排序！         */        for(String s : strs)&#123;            System.out.println(s);        &#125;    &#125;&#125;\n\nMap接口中常用方法java.util.Map接口中常用的方法：\n1、Map和Collection没有继承关系。\n2、Map集合以key和value的方式存储数据：键值对 key和value都是引用数据类型。key和value都是存储对象的内存地址。key起到主导的地位，value是key的一个附属品。\n3、Map接口中常用方法：\nV put(K key, V value) 向Map集合中添加键值对\nV get(Object key) 通过key获取value\nvoid clear()    清空Map集合\nboolean containsKey(Object key) 判断Map中是否包含某个key\nboolean containsValue(Object value) 判断Map中是否包含某个value\nboolean isEmpty()   判断Map集合中元素个数是否为0\nV remove(Object key) 通过key删除键值对\nint size() 获取Map集合中键值对的个数。\nCollection &lt;V&gt; values() 获取Map集合 中所有的value，返回一个Collection\nSet&lt;K&gt; keySet() 获取Map集合所有的key（所有的键是一个set集合）\nSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 将Map集合转换成Set集合\n假设现在有一个Map集合，如下所示：map1集合对象key             value\n\n1               zhangsan2               lisi3               wangwu4               zhaoliu\nSet set &#x3D; map1.entrySet();\nset集合对象1&#x3D;zhangsan 【注意：Map集合通过entrySet()方法转换成的这个Set集合，Set集合中元素的类型是 Map.Entry&lt;K,V&gt;】2&#x3D;lisi     【Map.Entry和String一样，都是一种类型的名字，只不过：Map.Entry是静态内部类，是Map中的静态内部类】3&#x3D;wangwu4&#x3D;zhaoliu —&gt; 这个东西是个什么？Map.Entry\n\nimport java.util.Collection;import java.util.HashMap;import java.util.Map;  public class MapTest01 &#123;    public static void main(String[] args) &#123;        // 创建Map集合对象        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();        // 向Map集合中添加键值对        map.put(1, &quot;zhangsan&quot;); // 1在这里进行了自动装箱。        map.put(2, &quot;lisi&quot;);        map.put(3, &quot;wangwu&quot;);        map.put(4, &quot;zhaoliu&quot;);        // 通过key获取value        String value = map.get(2);        System.out.println(value);        // 获取键值对的数量        System.out.println(&quot;键值对的数量：&quot; + map.size());        // 通过key删除key-value        map.remove(2);        System.out.println(&quot;键值对的数量：&quot; + map.size());        // 判断是否包含某个key        // contains方法底层调用的都是equals进行比对的，所以自定义的类型需要重写equals方法。        System.out.println(map.containsKey(new Integer(4))); // true        // 判断是否包含某个value        System.out.println(map.containsValue(new String(&quot;wangwu&quot;))); // true        // 获取所有的value        Collection&lt;String&gt; values = map.values();        // foreach        for(String s : values)&#123;            System.out.println(s);        &#125;        // 清空map集合        map.clear();        System.out.println(&quot;键值对的数量：&quot; + map.size());        // 判断是否为空        System.out.println(map.isEmpty()); // true    &#125;&#125;\n\nMap集合的遍历方式  import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/*Map集合的遍历。【非常重要】 */public class MapTest02 &#123;    public static void main(String[] args) &#123;        // 第一种方式：获取所有的key，通过遍历key，来遍历value        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();        map.put(1, &quot;zhangsan&quot;);        map.put(2, &quot;lisi&quot;);        map.put(3, &quot;wangwu&quot;);        map.put(4, &quot;zhaoliu&quot;);        // 遍历Map集合        // 获取所有的key，所有的key是一个Set集合        Set&lt;Integer&gt; keys = map.keySet();        // 遍历key，通过key获取value        // 迭代器可以        /*Iterator&lt;Integer&gt; it = keys.iterator();        while(it.hasNext())&#123;            // 取出其中一个key            Integer key = it.next();            // 通过key获取value            String value = map.get(key);            System.out.println(key + &quot;=&quot; + value);        &#125;*/        // foreach也可以        for(Integer key : keys)&#123;            System.out.println(key + &quot;=&quot; + map.get(key));        &#125;        // 第二种方式：Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()        // 以上这个方法是把Map集合直接全部转换成Set集合。        // Set集合中元素的类型是：Map.Entry        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();        // 遍历Set集合，每一次取出一个Node        // 迭代器        /*Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it2 = set.iterator();        while(it2.hasNext())&#123;            Map.Entry&lt;Integer,String&gt; node = it2.next();            Integer key = node.getKey();            String value = node.getValue();            System.out.println(key + &quot;=&quot; + value);        &#125;*/        // foreach        // 这种方式效率比较高，因为获取key和value都是直接从node对象中获取的属性值。        // 这种方式比较适合于大数据量。        for(Map.Entry&lt;Integer,String&gt; node : set)&#123;            System.out.println(node.getKey() + &quot;---&gt;&quot; + node.getValue());        &#125;    &#125;&#125;\n\nHashMapHashMap集合HashMap集合：1、HashMap集合底层是哈希表&#x2F;散列表的数据结构。\n2、哈希表是一个怎样的数据结构呢？哈希表是一个数组和单向链表的结合体。数组：在查询方面效率很高，随机增删方面效率很低。单向链表：在随机增删方面效率较高，在查询方面效率很低。哈希表将以上的两种数据结构融合在一起，充分发挥它们各自的优点。\n3、HashMap集合底层的源代码：\npublic class HashMap&#123;// HashMap底层实际上就是一个数组。（一维数组）Node&lt;K,V&gt;[] table;// 静态的内部类HashMap.Nodestatic class Node&lt;K,V&gt; &#123;final int hash; // 哈希值（哈希值是key的hashCode()方法的执行结果。hash值通过哈希函数/算法，可以转换存储成数组的下标。）final K key; // 存储到Map集合中的那个keyV value; // 存储到Map集合中的那个valueNode&lt;K,V&gt; next; // 下一个节点的内存地址。    &#125;&#125;\n哈希表&#x2F;散列表：一维数组，这个数组中每一个元素是一个单向链表。（数组和链表的结合体。）\n4、最主要掌握的是：map.put(k,v)v &#x3D; map.get(k)以上这两个方法的实现原理，是必须掌握的。\n5、HashMap集合的key部分特点：无序，不可重复。为什么无序？ 因为不一定挂到哪个单向链表上。不可重复是怎么保证的？ equals方法来保证HashMap集合的key不可重复。如果key重复了，value会覆盖。\n放在HashMap集合key部分的元素其实就是放到HashSet集合中了。所以HashSet集合中的元素也需要同时重写hashCode()+equals()方法。\n6、哈希表HashMap使用不当时无法发挥性能！假设将所有的hashCode()方法返回值固定为某个值，那么会导致底层哈希表变成了纯单向链表。这种情况我们成为：散列分布不均匀。什么是散列分布均匀？假设有100个元素，10个单向链表，那么每个单向链表上有10个节点，这是最好的，是散列分布均匀的。假设将所有的hashCode()方法返回值都设定为不一样的值，可以吗，有什么问题？不行，因为这样的话导致底层哈希表就成为一维数组了，没有链表的概念了。也是散列分布不均匀。散列分布均匀需要你重写hashCode()方法时有一定的技巧。  \n7、重点：放在HashMap集合key部分的元素，以及放在HashSet集合中的元素，需要同时重写hashCode和equals方法。\n8、HashMap集合的默认初始化容量是16，默认加载因子是0.75这个默认加载因子是当HashMap集合底层数组的容量达到75%的时候，数组开始扩容。\n重点，记住：HashMap集合初始化容量必须是2的倍数，这也是官方推荐的， 这是因为达到散列均匀，为了提高HashMap集合的存取效率，所必须的。\nimport java.util.HashMap;import java.util.Map;import java.util.Set;  public class HashMapTest01 &#123;    public static void main(String[] args) &#123;        // 测试HashMap集合key部分的元素特点        // Integer是key，它的hashCode和equals都重写了。        Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;();        map.put(1111, &quot;zhangsan&quot;);        map.put(6666, &quot;lisi&quot;);        map.put(7777, &quot;wangwu&quot;);        map.put(2222, &quot;zhaoliu&quot;);        map.put(2222, &quot;king&quot;); //key重复的时候value会自动覆盖。        System.out.println(map.size()); // 4        // 遍历Map集合        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();        for(Map.Entry&lt;Integer,String&gt; entry : set)&#123;            // 验证结果：HashMap集合key部分元素：无序不可重复。            System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());        &#125;    &#125;&#125;\n\n\n同时重写hashCode和equals1、向Map集合中存，以及从Map集合中取，都是先调用key的hashCode方法，然后再调用equals方法！equals方法有可能调用，也有可能不调用。拿put(k,v)举例，什么时候equals不会调用？k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。拿get(k)举例，什么时候equals不会调用？k.hashCode()方法返回哈希值，哈希值经过哈希算法转换成数组下标。数组下标位置上如果是null，equals不需要执行。\n2、注意：如果一个类的equals方法重写了，那么hashCode()方法必须重写。并且equals方法返回如果是true，hashCode()方法返回的值必须一样。equals方法返回true表示两个对象相同，在同一个单向链表上比较。那么对于同一个单向链表上的节点来说，他们的哈希值都是相同的。所以hashCode()方法的返回值也应该相同。  \n3、hashCode()方法和equals()方法不用研究了，直接使用IDEA工具生成，但是这两个方法需要同时生成。\n4、终极结论：放在HashMap集合key部分的，以及放在HashSet集合中的元素，需要同时重写hashCode方法和equals方法。\n5、对于哈希表数据结构来说：如果o1和o2的hash值相同，一定是放到同一个单向链表上。当然如果o1和o2的hash值不同，但由于哈希算法执行结束之后转换的数组下标可能相同，此时会发生“哈希碰撞”。\nStudent.java:\nimport java.util.Objects;public class Student &#123;    private String name;    public Student() &#123;    &#125;    public Student(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    // hashCode    // equals（如果学生名字一样，表示同一个学生。）    /*public boolean equals(Object obj)&#123;        if(obj == null || !(obj instanceof Student)) return false;        if(obj == this) return true;        Student s = (Student)obj;        return this.name.equals(s.name);    &#125;*/    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Student student = (Student) o;        return Objects.equals(name, student.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(name);    &#125;&#125;\n\nHashMapTest02.java:\nimport java.util.HashSet;import java.util.Set;public class HashMapTest02 &#123;    public static void main(String[] args) &#123;        Student s1 = new Student(&quot;zhangsan&quot;);        Student s2 = new Student(&quot;zhangsan&quot;);        // 重写equals方法之前是false        //System.out.println(s1.equals(s2)); // false        // 重写equals方法之后是true        System.out.println(s1.equals(s2)); //true （s1和s2表示相等）        System.out.println(&quot;s1的hashCode=&quot; + s1.hashCode()); //284720968 (重写hashCode之后-1432604525)        System.out.println(&quot;s2的hashCode=&quot; + s2.hashCode()); //122883338 (重写hashCode之后-1432604525)        // s1.equals(s2)结果已经是true了，表示s1和s2是一样的，相同的，那么往HashSet集合中放的话，        // 按说只能放进去1个。（HashSet集合特点：无序不可重复）        Set&lt;Student&gt; students = new HashSet&lt;&gt;();        students.add(s1);        students.add(s2);        System.out.println(students.size()); // 这个结果按说应该是1. 但是结果是2.显然不符合HashSet集合存储特点。怎么办？    &#125;&#125;\n\nimport java.util.HashMap;import java.util.Map;/*HashMap集合key部分允许null吗？    允许    但是要注意：HashMap集合的key null值只能有一个。    有可能面试的时候遇到这样的问题。 */public class HashMapTest03 &#123;    public static void main(String[] args) &#123;        Map map = new HashMap();        // HashMap集合允许key为null        map.put(null, null);        System.out.println(map.size()); // 1        // key重复的话value是覆盖！        map.put(null, 100);        System.out.println(map.size()); //1        // 通过key获取value        System.out.println(map.get(null)); // 100    &#125;&#125;\n\nHashTableHashtable的key可以为null吗？Hashtable的key和value都是不能为null的。HashMap集合的key和value都是可以为null的。\nHashtable方法都带有synchronized：线程安全的。线程安全有其它的方案，这个Hashtable对线程的处理导致效率较低，使用较少了。\nHashtable和HashMap一样，底层都是哈希表数据结构。Hashtable的初始化容量是11，默认加载因子是：0.75fHashtable的扩容是：原容量 * 2 + 1\nHashMap和Hashtable的区别。HashMap：初始化容量16，扩容2倍。非线程安全key和value可以为null。  \nHashtable        初始化容量11，扩容2倍+1        线程安全        key和value都不能是null。\nProperties类的常用两个方法setPropertygetProperty目前只需要掌握Properties属性类对象的相关方法即可。Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。Properties被称为属性类对象。Properties是线程安全的。\nimport java.util.Properties;public class PropertiesTest01 &#123;    public static void main(String[] args) &#123;        // 创建一个Properties对象        Properties pro = new Properties();        // 需要掌握Properties的两个方法，一个存，一个取。        pro.setProperty(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/bjpowernode&quot;);        pro.setProperty(&quot;driver&quot;,&quot;com.mysql.jdbc.Driver&quot;);        pro.setProperty(&quot;username&quot;, &quot;root&quot;);        pro.setProperty(&quot;password&quot;, &quot;123&quot;);        // 通过key获取value        String url = pro.getProperty(&quot;url&quot;);        String driver = pro.getProperty(&quot;driver&quot;);        String username = pro.getProperty(&quot;username&quot;);        String password = pro.getProperty(&quot;password&quot;);        System.out.println(url);        System.out.println(driver);        System.out.println(username);        System.out.println(password);    &#125;&#125;\n\nTreeSet1、TreeSet集合底层实际上是一个TreeMap2、TreeMap集合底层是一个二叉树。3、放到TreeSet集合中的元素，等同于放到TreeMap集合key部分了。4、TreeSet集合中的元素：无序不可重复，但是可以按照元素的大小顺序自动排序。称为：可排序集合。\nimport java.util.TreeSet;public class TreeSetTest02 &#123;    public static void main(String[] args) &#123;        // 创建一个TreeSet集合        TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;();        // 添加String        ts.add(&quot;zhangsan&quot;);        ts.add(&quot;lisi&quot;);        ts.add(&quot;wangwu&quot;);        ts.add(&quot;zhangsi&quot;);        ts.add(&quot;wangliu&quot;);        // 遍历        for(String s : ts)&#123;            // 按照字典顺序，升序！            System.out.println(s);        &#125;        TreeSet&lt;Integer&gt; ts2 = new TreeSet&lt;&gt;();        ts2.add(100);        ts2.add(200);        ts2.add(900);        ts2.add(800);        ts2.add(600);        ts2.add(10);        for(Integer elt : ts2)&#123;            // 升序！            System.out.println(elt);        &#125;    &#125;&#125;/*数据库中有很多数据：    userid  name     birth    -------------------------------------    1       zs          1980-11-11    2       ls          1980-10-11    3       ww          1981-11-11    4       zl          1979-11-11    编写程序从数据库当中取出数据，在页面展示用户信息的时候按照生日升序或者降序。    这个时候可以使用TreeSet集合，因为TreeSet集合放进去，拿出来就是有顺序的。 */\n\n\n对自定义的类型来说，TreeSet可以排序吗？以下程序中对于Person类型来说，无法排序。因为没有指定Person对象之间的比较规则。谁大谁小并没有说明啊。\npublic class TreeSetTest03 &#123;    public static void main(String[] args) &#123;        Person p1 = new Person(32);        //System.out.println(p1);        Person p2 = new Person(20);        Person p3 = new Person(30);        Person p4 = new Person(25);        // 创建TreeSet集合        TreeSet&lt;Person&gt; persons = new TreeSet&lt;&gt;();        // 添加元素        persons.add(p1);        persons.add(p2);        persons.add(p3);        persons.add(p4);        // 遍历        for (Person p : persons)&#123;            System.out.println(p);        &#125;    &#125;&#125;class Person &#123;    int age;    public Person(int age)&#123;        this.age = age;    &#125;    // 重写toString()方法    public String toString()&#123;        return &quot;Person[age=&quot;+age+&quot;]&quot;;    &#125;&#125;\n\n以下程序运行的时候出现了这个异常：        java.lang.ClassCastException:            class com.bjpowernode.javase.collection.Person cannot be cast to class java.lang.Comparable    出现这个异常的原因是：        Person类没有实现java.lang.Comparable接口。\nimport java.util.TreeSet;public class TreeSetTest04 &#123;    public static void main(String[] args) &#123;        Customer c1 = new Customer(32);        Customer c2 = new Customer(20);        Customer c3 = new Customer(30);        Customer c4 = new Customer(25);        // 创建TreeSet集合        TreeSet&lt;Customer&gt; customers = new TreeSet&lt;&gt;();        // 添加元素        customers.add(c1);        customers.add(c2);        customers.add(c3);        customers.add(c4);        // 遍历        for (Customer c : customers)&#123;            System.out.println(c);        &#125;    &#125;&#125;// 放在TreeSet集合中的元素需要实现java.lang.Comparable接口。// 并且实现compareTo方法。equals可以不写。class Customer implements Comparable&lt;Customer&gt;&#123;    int age;    public Customer(int age)&#123;        this.age = age;    &#125;    // 需要在这个方法中编写比较的逻辑，或者说比较的规则，按照什么进行比较！    // k.compareTo(t.key)    // 拿着参数k和集合中的每一个k进行比较，返回值可能是&gt;0 &lt;0 =0    // 比较规则最终还是由程序员指定的：例如按照年龄升序。或者按照年龄降序。    @Override    public int compareTo(Customer c) &#123; // c1.compareTo(c2);        // this是c1        // c是c2        // c1和c2比较的时候，就是this和c比较。        /*int age1 = this.age;        int age2 = c.age;        if(age1 == age2)&#123;            return 0;        &#125; else if(age1 &gt; age2) &#123;            return 1;        &#125; else &#123;            return -1;        &#125;*/        //return this.age - c.age; // =0 &gt;0 &lt;0        return c.age - this.age;    &#125;    public String toString()&#123;        return &quot;Customer[age=&quot;+age+&quot;]&quot;;    &#125;&#125;\n\n比较规则的写法import java.util.TreeSet;/*先按照年龄升序，如果年龄一样的再按照姓名升序。 */public class TreeSetTest05 &#123;    public static void main(String[] args) &#123;        TreeSet&lt;Vip&gt; vips = new TreeSet&lt;&gt;();        vips.add(new Vip(&quot;zhangsi&quot;, 20));        vips.add(new Vip(&quot;zhangsan&quot;, 20));        vips.add(new Vip(&quot;king&quot;, 18));        vips.add(new Vip(&quot;soft&quot;, 17));        for(Vip vip : vips)&#123;            System.out.println(vip);        &#125;    &#125;&#125;class Vip implements Comparable&lt;Vip&gt;&#123;    String name;    int age;    public Vip(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Vip&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;    /*    compareTo方法的返回值很重要：        返回0表示相同，value会覆盖。        返回&gt;0，会继续在右子树上找。【10 - 9 = 1 ，1 &gt; 0的说明左边这个数字比较大。所以在右子树上找。】        返回&lt;0，会继续在左子树上找。     */    @Override    public int compareTo(Vip v) &#123;        // 写排序规则，按照什么进行比较。        if(this.age == v.age)&#123;            // 年龄相同时按照名字排序。            // 姓名是String类型，可以直接比。调用compareTo来完成比较。            return this.name.compareTo(v.name);        &#125; else &#123;            // 年龄不一样            return this.age - v.age;        &#125;    &#125;&#125;\n\n实现比较器接口TreeSet集合中元素可排序的第二种方式：使用比较器的方式。最终的结论：放到TreeSet或者TreeMap集合key部分的元素要想做到排序,包括两种方式：第一种：放在集合中的元素实现java.lang.Comparable接口。第二种：在构造TreeSet或者TreeMap集合的时候给它传一个比较器对象。Comparable和Comparator怎么选择呢？当比较规则不会发生改变的时候，或者说当比较规则只有1个的时候，建议实现Comparable接口。如果比较规则有多个，并且需要多个比较规则之间频繁切换，建议使用Comparator接口。Comparator接口的设计符合OCP原则。\nimport java.util.Comparator;import java.util.TreeSet;public class TreeSetTest06 &#123;    public static void main(String[] args) &#123;        // 创建TreeSet集合的时候，需要使用这个比较器。        // TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;();//这样不行，没有通过构造方法传递一个比较器进去。        // 给构造方法传递一个比较器。        //TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new WuGuiComparator());        // 大家可以使用匿名内部类的方式（这个类没有名字。直接new接口。）        TreeSet&lt;WuGui&gt; wuGuis = new TreeSet&lt;&gt;(new Comparator&lt;WuGui&gt;() &#123;            @Override            public int compare(WuGui o1, WuGui o2) &#123;                return o1.age - o2.age;            &#125;        &#125;);        wuGuis.add(new WuGui(1000));        wuGuis.add(new WuGui(800));        wuGuis.add(new WuGui(810));        for(WuGui wuGui : wuGuis)&#123;            System.out.println(wuGui);        &#125;    &#125;&#125;// 乌龟class WuGui&#123;    int age;    public WuGui(int age)&#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;小乌龟[&quot; +                &quot;age=&quot; + age +                &#x27;]&#x27;;    &#125;&#125;// 单独在这里编写一个比较器// 比较器实现java.util.Comparator接口。（Comparable是java.lang包下的。Comparator是java.util包下的。）/*class WuGuiComparator implements Comparator&lt;WuGui&gt; &#123;    @Override    public int compare(WuGui o1, WuGui o2) &#123;        // 指定比较规则        // 按照年龄排序        return o1.age - o2.age;    &#125;&#125; */\n\n自平衡二叉树\nCollections工具类import java.util.*;/*java.util.Collection 集合接口java.util.Collections 集合工具类，方便集合的操作。 */public class CollectionsTest &#123;    public static void main(String[] args) &#123;        // ArrayList集合不是线程安全的。        List&lt;String&gt; list = new ArrayList&lt;&gt;();        // 变成线程安全的        Collections.synchronizedList(list);        // 排序        list.add(&quot;abf&quot;);        list.add(&quot;abx&quot;);        list.add(&quot;abc&quot;);        list.add(&quot;abe&quot;);        Collections.sort(list);        for(String s : list)&#123;            System.out.println(s);        &#125;        List&lt;WuGui2&gt; wuGuis = new ArrayList&lt;&gt;();        wuGuis.add(new WuGui2(1000));        wuGuis.add(new WuGui2(8000));        wuGuis.add(new WuGui2(500));        // 注意：对List集合中元素排序，需要保证List集合中的元素实现了：Comparable接口。        Collections.sort(wuGuis);        for(WuGui2 wg : wuGuis)&#123;            System.out.println(wg);        &#125;        // 对Set集合怎么排序呢？        Set&lt;String&gt; set = new HashSet&lt;&gt;();        set.add(&quot;king&quot;);        set.add(&quot;kingsoft&quot;);        set.add(&quot;king2&quot;);        set.add(&quot;king1&quot;);        // 将Set集合转换成List集合        List&lt;String&gt; myList = new ArrayList&lt;&gt;(set);        Collections.sort(myList);        for(String s : myList) &#123;            System.out.println(s);        &#125;        // 这种方式也可以排序。        //Collections.sort(list集合, 比较器对象);    &#125;&#125;class WuGui2 implements Comparable&lt;WuGui2&gt;&#123;    int age;    public WuGui2(int age)&#123;        this.age = age;    &#125;    @Override    public int compareTo(WuGui2 o) &#123;        return this.age - o.age;    &#125;    @Override    public String toString() &#123;        return &quot;WuGui2&#123;&quot; +                &quot;age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\n集合总结ArrayListimport java.util.ArrayList;import java.util.Iterator;import java.util.LinkedList;/*    1.1、每个集合对象的创建（new）\t1.2、向集合中添加元素\t1.3、从集合中取出某个元素\t1.4、遍历集合 */public class ArrayListTest &#123;    public static void main(String[] args) &#123;        // 创建集合对象        //ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();        // 添加元素        list.add(&quot;zhangsan&quot;);        list.add(&quot;lisi&quot;);        list.add(&quot;wangwu&quot;);        // 从集合中取出某个元素        // List集合有下标        String firstElt = list.get(0);        System.out.println(firstElt);        // 遍历（下标方式）        for(int i = 0; i &lt; list.size(); i++)&#123;            String elt = list.get(i);            System.out.println(elt);        &#125;        // 遍历（迭代器方式，这个是通用的，所有Collection都能用）        Iterator&lt;String&gt; it = list.iterator();        while(it.hasNext())&#123;            System.out.println(it.next());        &#125;        // while循环修改为for循环        /*for(Iterator&lt;String&gt; it2 = list.iterator(); it2.hasNext(); )&#123;            System.out.println(&quot;====&gt;&quot; + it2.next());        &#125;*/        // 遍历（foreach方式）        for(String s : list)&#123;            System.out.println(s);        &#125;    &#125;&#125;\n\nHashSetimport java.util.HashSet;import java.util.Iterator;import java.util.Objects;import java.util.Set;/*    1.1、每个集合对象的创建（new）\t1.2、向集合中添加元素\t1.3、从集合中取出某个元素\t1.4、遍历集合\t1.5、测试HashSet集合的特点：无序不可重复。 */public class HashSetTest &#123;    public static void main(String[] args) &#123;        // 创建集合对象        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();        // 添加元素        set.add(&quot;abc&quot;);        set.add(&quot;def&quot;);        set.add(&quot;king&quot;);        // set集合中的元素不能通过下标取了。没有下标        // 遍历集合（迭代器）        Iterator&lt;String&gt; it = set.iterator();        while(it.hasNext())&#123;            System.out.println(it.next());        &#125;        // 遍历集合（foreach）        for(String s : set)&#123;            System.out.println(s);        &#125;        set.add(&quot;king&quot;);        set.add(&quot;king&quot;);        set.add(&quot;king&quot;);        System.out.println(set.size()); //3 （后面3个king都没有加进去。）        set.add(&quot;1&quot;);        set.add(&quot;10&quot;);        set.add(&quot;2&quot;);        for(String s : set)&#123;            System.out.println(&quot;---&gt;&quot; + s);        &#125;        // 创建Set集合，存储Student数据        Set&lt;Student&gt; students = new HashSet&lt;&gt;();        Student s1 = new Student(111, &quot;zhangsan&quot;);        Student s2 = new Student(222, &quot;lisi&quot;);        Student s3 = new Student(111, &quot;zhangsan&quot;);        students.add(s1);        students.add(s2);        students.add(s3);        System.out.println(students.size()); // 2        // 遍历        for(Student stu : students)&#123;            System.out.println(stu);        &#125;    &#125;&#125;class Student &#123;    int no;    String name;    public Student() &#123;    &#125;    public Student(int no, String name) &#123;        this.no = no;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;no=&quot; + no +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Student student = (Student) o;        return no == student.no &amp;&amp;                Objects.equals(name, student.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(no, name);    &#125;&#125;\n\nTreeSetimport java.util.Comparator;import java.util.Iterator;import java.util.TreeSet;/*    1.1、每个集合对象的创建（new）\t1.2、向集合中添加元素\t1.3、从集合中取出某个元素\t1.4、遍历集合\t1.5、测试TreeSet集合中的元素是可排序的。\t1.6、测试TreeSet集合中存储的类型是自定义的。\t1.7、测试实现Comparable接口的方式\t1.8、测试实现Comparator接口的方式（最好测试以下匿名内部类的方式） */public class TreeSetTest &#123;    public static void main(String[] args) &#123;        // 集合的创建（可以测试以下TreeSet集合中存储String、Integer的。这些类都是SUN写好的。）        //TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();        // 编写比较器可以改变规则。        TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Integer&gt;() &#123;            @Override            public int compare(Integer o1, Integer o2) &#123;                return o2 - o1; // 自动拆箱            &#125;        &#125;);        // 添加元素        ts.add(1);        ts.add(100);        ts.add(10);        ts.add(10);        ts.add(10);        ts.add(10);        ts.add(0);        // 遍历（迭代器方式）        Iterator&lt;Integer&gt; it = ts.iterator();        while(it.hasNext()) &#123;            Integer i = it.next();            System.out.println(i);        &#125;        // 遍历（foreach）        for(Integer x : ts)&#123;            System.out.println(x);        &#125;        // TreeSet集合中存储自定义类型        TreeSet&lt;A&gt; atree = new TreeSet&lt;&gt;();        atree.add(new A(100));        atree.add(new A(200));        atree.add(new A(500));        atree.add(new A(300));        atree.add(new A(400));        atree.add(new A(1000));        // 遍历        for(A a : atree)&#123;            System.out.println(a);        &#125;        //TreeSet&lt;B&gt; btree = new TreeSet&lt;&gt;(new BComparator());        // 匿名内部类方式。        TreeSet&lt;B&gt; btree = new TreeSet&lt;&gt;(new Comparator&lt;B&gt;() &#123;            @Override            public int compare(B o1, B o2) &#123;                return o1.i - o2.i;            &#125;        &#125;);        btree.add(new B(500));        btree.add(new B(100));        btree.add(new B(200));        btree.add(new B(600));        btree.add(new B(300));        btree.add(new B(50));        for(B b : btree)&#123;            System.out.println(b);        &#125;    &#125;&#125;// 第一种方式：实现Comparable接口class A implements Comparable&lt;A&gt;&#123;    int i;    public A(int i)&#123;        this.i = i;    &#125;    @Override    public String toString() &#123;        return &quot;A&#123;&quot; +                &quot;i=&quot; + i +                &#x27;&#125;&#x27;;    &#125;    @Override    public int compareTo(A o) &#123;        //return this.i - o.i;        return o.i - this.i;    &#125;&#125;class B &#123;    int i;    public B(int i)&#123;        this.i = i;    &#125;    @Override    public String toString() &#123;        return &quot;B&#123;&quot; +                &quot;i=&quot; + i +                &#x27;&#125;&#x27;;    &#125;&#125;// 比较器class BComparator implements Comparator&lt;B&gt; &#123;    @Override    public int compare(B o1, B o2) &#123;        return o1.i - o2.i;    &#125;&#125;\n\nHashMapimport java.util.HashMap;import java.util.Map;import java.util.Set;/*    1.1、每个集合对象的创建（new）\t1.2、向集合中添加元素\t1.3、从集合中取出某个元素\t1.4、遍历集合 */public class HashMapTest &#123;    public static void main(String[] args) &#123;        // 创建Map集合        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();        // 添加元素        map.put(1, &quot;zhangsan&quot;);        map.put(9, &quot;lisi&quot;);        map.put(10, &quot;wangwu&quot;);        map.put(2, &quot;king&quot;);        map.put(2, &quot;simth&quot;); // key重复value会覆盖。        // 获取元素个数        System.out.println(map.size());        // 取key是2的元素        System.out.println(map.get(2)); // smith        // 遍历Map集合很重要，几种方式都要会。        // 第一种方式：先获取所有的key，遍历key的时候，通过key获取value        Set&lt;Integer&gt; keys = map.keySet();        for(Integer key : keys)&#123;            System.out.println(key + &quot;=&quot; + map.get(key));        &#125;        // 第二种方式：是将Map集合转换成Set集合，Set集合中每一个元素是Node        // 这个Node节点中有key和value        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; nodes = map.entrySet();        for(Map.Entry&lt;Integer,String&gt; node : nodes)&#123;            System.out.println(node.getKey() + &quot;=&quot; + node.getValue());        &#125;    &#125;&#125;\n\nPropertiesimport java.util.Properties;public class PropertiesTest &#123;    public static void main(String[] args) &#123;        // 创建对象        Properties pro = new Properties();        // 存        pro.setProperty(&quot;username&quot;, &quot;test&quot;);        pro.setProperty(&quot;password&quot;, &quot;test123&quot;);        // 取        String username = pro.getProperty(&quot;username&quot;);        String password = pro.getProperty(&quot;password&quot;);        System.out.println(username);        System.out.println(password);    &#125;&#125;\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志10","url":"/2022/05/02/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%9710-java10/","content":"final关键字1、final修饰的类无法继承。2、final修饰的方法无法覆盖。3、final修饰的变量只能赋一次值。4、final修饰的引用一旦指向某个对象，则不能再重新指向其它对象，但该引用指向的对象内部的数据是可以修改的。5、final修饰的实例变量必须手动初始化，不能采用系统默认值。这个手动初始化赋值，在变量后面赋值可以，在构造方法中赋值也可以。6、final修饰的实例变量一般和static联合使用，称为常量。public static final double PI &#x3D; 3.1415926;\nJVM中的体现：\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志2","url":"/2022/04/22/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%972-java2/","content":"今天基本从头到尾复习了下C的语法（与Java通用）\n面向对象的新输入方式：\n/** * @author OliverChen */public class KeyIn &#123;    public static void main(String[] args) &#123;        java.util.Scanner s = new java.util.Scanner(System.in);        System.out.println(&quot;请输入一个数字&quot;);        int i = s.nextInt();        System.out.println(&quot;您输入的数字为&quot; + i);        System.out.println(&quot;请输入您的名字&quot;);        String str = s.next();        System.out.println(&quot;您好!&quot; + str);    &#125;&#125;\n\n或者是\nimport java.util.Scanner;/** * @author OliverChen */public class KeyIn &#123;    public static void main(String[] args) &#123;        Scanner s = new Scanner(System.in);        System.out.println(&quot;请输入一个数字&quot;);        int i = s.nextInt();        System.out.println(&quot;您输入的数字为&quot; + i);        System.out.println(&quot;请输入您的名字&quot;);        String str = s.next();        System.out.println(&quot;您好!&quot; + str);    &#125;&#125;\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志3","url":"/2022/04/24/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%973-java3/","content":"一.方法Java里的方法约等于C中的函数,只不过多了一个跨类调用的说法\n以下为实例\n/** * @author OliverChen */public class MethodTest &#123;    public static void main(String[] args)    &#123;        int a=3;        int b=4;        int c,d,e;        c = Plus.plus(a,b);        d = Plus.minus(a,b);        e = Plus2.plus2(a,b);        System.out.println(c);        System.out.println(d);        System.out.println(e);    &#125;&#125;class Plus&#123;    public static int plus(int a, int b)    &#123;        int c;        c = a + b;        return c;    &#125;    public static int minus(int a, int b)    &#123;        int c;        c = a - b;        return c;    &#125;&#125;class Plus2&#123;    public static int plus2(int a, int b)    &#123;        int c;        c = a*b;        return c;    &#125;&#125;\n\nJVM内存结构:方法区与栈栈数据结构示意图:\n\n方法区最先有数据,存放代码片段,存放class字节码.\n方法只有在调用时才会在栈中分配空间,调用时入栈,调用后释放内存,发生出栈.\n\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志4","url":"/2022/04/24/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%974-java4/","content":"方法重载方法重载可用于功能相似，类型不同的方法，能使方法名相同，优化代码质量。\n重载前：\n/** * @author OliverChen */public class OverloadTeat1 &#123;    public static void main(String[] args)    &#123;        int a = 10;        int b = 20;\tlong c = 10;\tlong d = 20;\tdouble e = 10;\tdouble f = 20;        System.out.println(sumInt(a,b));        System.out.println(sumLong(c,d));        System.out.println(sumDouble(e,f));    &#125;    public static int sumInt(int x,int y)    &#123;        return x + y;    &#125;    public static long sumLong(long x,long y)    &#123;        return x + y;    &#125;    public static double sumDouble(double x,double y)    &#123;        return x + y;    &#125;&#125;\n\n重载后：\n/** * @author OliverChen */public class OverloadTeat1 &#123;    public static void main(String[] args)    &#123;        int a = 10;        int b = 20;        long c = 10;        long d = 20;        double e = 10;        double f = 20;        System.out.println(sum(a,b));        System.out.println(sum(c,d));        System.out.println(sum(e,f));    &#125;    public static int sum(int x,int y)    &#123;        return x + y;    &#125;    public static long sum(long x,long y)    &#123;        return x + y;    &#125;    public static double sum(double x,double y)    &#123;        return x + y;    &#125;&#125;\n\n\n什么时候代码会发生重载？条件一：在同一类中条件二：方法名相同条件三：参数列表（个数&#x2F;类型&#x2F;顺序）不同隐藏条件：方法功能相似\n同时满足以上条件就可认为发生了方法重载\n方法重载与返回值的类型无关，也与修饰符列表无关。\nSystem.out.println 方法就是方法重载最常用的例子\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志5","url":"/2022/04/25/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%975-java5/","content":"利用方法重载进行包装先上代码\n/** * @author OliverChen */public class O &#123;    public static void p()    &#123;        System.out.println();    &#125;    public static void p(byte b)    &#123;        System.out.println(b);    &#125;    public static void p(short s)    &#123;        System.out.println(s);    &#125;    public static void p(int i)    &#123;        System.out.println(i);    &#125;    public static void p(long l)    &#123;        System.out.println(l);    &#125;    public static void p(float f)    &#123;        System.out.println(f);    &#125;    public static void p(double d)    &#123;        System.out.println(d);    &#125;    public static void p(boolean b)    &#123;        System.out.println(b);    &#125;    public static void p(char c)    &#123;        System.out.println(c);    &#125;    public static void p(String s)    &#123;        System.out.println(s);    &#125;&#125;\n\n在代码文件夹内运行以上代码生成class文件后，即可完成对println的二次包装，以后可利用改包装简写println命令，例如：\n/** * @author OliverChen */public class Hello &#123;    public static void main(String[] args)    &#123;        O.p(&quot;Hello,World!&quot;);    &#125;&#125;\n\n方法递归的原理\n\n所以当递归时程序没有结束条件时，一定会发生栈内存溢出错误（StackOverflowError）\n面向过程与面向对象\n面向过程和面向对象的区别\n\n- 面向过程：主要关注点是：实现的具体过程，因果关系- 【集成显卡的开发思路】【炒饭】* 优点：对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低。* 缺点：采用面向过程的方式开发很难解决非常复杂的业务逻辑       另外面向过程的方式导致软件元素之间的“耦合度”非常高       只要其中一环出问题，整个系统受到影响，导致最终的软件“扩展力”差。       另外，由于没有独立体的概念，所以无法达到组件复用。- 面向对象：主要关注点是：主要关注对象【独立体】能完成哪些功能。- 【独立显卡的开发思路】【盖饭】* 优点：耦合度低，扩展力强。更容易解决现实世界当中更复杂的业务逻辑。组件复用性强。* 缺点：前期投入成本较高，需要进行独立体的抽取，大量的系统分析与设计。\t\t- C语言是纯面向过程的、C++半面向对象、Java纯面向对象- 现在出现的一些新的编程语言多数都是面向对象的。- 人在认识现实世界的时候以面向对象的方式。- 面向对象更符合人的思维方式。\n\n面向对象的三大特征  - 封装  - 继承  - 多态\n\n所有面向对象的编程语言都有这三大特征。\n采用面向对象的方式开发一个软件，生命周期当中：【整个生命周期中贯穿使用OO面向对象方式】\n\n面向对象的分析：OOA\n面向对象的设计：OOD\n面向对象的编程：OOP\n\n类和对象\n类和对象的概念\n\n什么是类？      - 类在现实世界当中是不存在的，是一个模板，是一个概念。是人类大脑思考抽象的结果。      - 类代表了一类事物。      - 在现实世界当中，对象A与对象B之间具有共同特征，进行抽象总结出一个模板，这个模板被称为类。\n\n什么是对象？      - 对象是实际存在的个体。现实世界当中实际存在。  * 描述一下整个软件开发的过程：      * 程序员先观察现实世界，从现实世界当中寻找对象      * 寻找了N多个对象之后，发现所有的对象都有共同特征      * 程序员在大脑中形成了一个模板【类】      * Java程序员可以通过java代码来表述一个类      * Java程序中有了类的定义      * 然后通过类就可以创建对象      * 有了对象之后，可以让对象直接协作起来形成一个系统。\n  \n\n类–【实例化】-&gt;对象\n\n对象又被称为实例\n\n对象–【抽象】–&gt;类\n\n\n\n重点：类描述的是对象的共同特征。共同特征例如：身高特征这个身高特征在访问的时候，必须先创建对象，通过对象去访问这个特征。因为这个特征具体的某个对象上之后，值不同。有的对象身高1.80，有的对象身高2.80。\n\n一个类主要描述的是 状态 + 动作。      状态信息：名字、身高、性别、年龄      动作信息：吃、唱歌、跳舞、学习  状态–&gt; 一个类的属性      动作–&gt; 一个类的方法\n  \n\n类 &#x3D; 属性 + 方法\n  类{\n\n\n属性; &#x2F;&#x2F;描述对象的状态信息，由于属性对应数据，所以以变量的方式存在                方法; &#x2F;&#x2F;描述对象的动作信息            }\n注意：状态和动作当具体到某个对象上之后，发现最终的结果可能不一样。对象和对象之间有共同特征，但是具体到对象之后有数据的差异。\n\n方法体当中声明的变量：局部变量\n方法体外声明的变量：成员变量（即属性）\n\n对象的创建创建对象的语法：new 类名();类是模板，通过一个类可以创造N多个对象。new是一个运算符，专门负责对象的创建。\nJava中所有的“类”都属于引用数据类型。\n对象和引用的概念：        * 对象：目前在使用new运算符在堆内存中开辟的内存空间称为对象。        * 引用：是一个储存了对象内存地址的变量，可以是局部变量，也可以是方法变量        * 所有访问实例相关的数据，都需要通过引用的方式访问，因为只有通过引用才能找到对象。故实例变量必须先创建对象，通过“引用”来访问。        * 只有一个空的引用，访问对象的实例相关的数据会出现空指针异常。\nclass Student&#123;\t\tComputer com; //com是一个引用【实例变量】\t\tpublic static void doSome()&#123;\t\t\tComputer cc; //cc是一个引用【局部变量】\t\t&#125;\t&#125;\n\n\n下图为以上在JVM中的体现：\n\n多次调用对象的JVM体现：\n\n最后给一下代码示例：\n/** * @author OliverChen */public class OOTtest &#123;    public static void main(String[] args) &#123;//创建一个对象        Student zhangsan = new Student();        //与int i=10;意义相同        zhangsan.id = 1001;        zhangsan.name = &quot;张三&quot;;        zhangsan.sex = true;        zhangsan.address = &quot;北京&quot;;        zhangsan.age = 20;        System.out.println(&quot;id=&quot; + zhangsan.id);        System.out.println(&quot;name=&quot; + zhangsan.name);        System.out.println(&quot;sex=&quot; + zhangsan.sex);        System.out.println(&quot;address=&quot; + zhangsan.address);        System.out.println(&quot;age=&quot; + zhangsan.age);    &#125;&#125;class Student &#123;    int id;    String name;    boolean sex;    String address;    int age;&#125;\n\n\n\n\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志6","url":"/2022/04/26/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%976-java6/","content":"空指针异常出现空指针异常的前提条件是：“空引用”访问实例对象相关的数据时，都会出现空指针异常。\nJVM中体现如下：\n\n参数传递Java中关于方法调用时的参数传递实际上只有一个规则：不管你是基本数据类型，还是引用数据类型，实际上在传递的时候都是将变量中保存的那个“值”复制一份，传过去\nint i = 10;int j = i; //i传递给j，实际上只是将i变量中保存的10传递给j了，//j实际上是一块全新的内存空间。User u = 0x1234;User u2 = u; //u传递给u2，实际上是将0x1234这个值赋值给u2了，//u和u2实际上是两个不同的局部变量，//但是它们这两个变量指向堆内存中同一个java对象。\n\n\n\n构造方法1.当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。这个无参数的构造方法叫做缺省构造器。\n2.当一个类中手动的提供了构造方法，那么系统将不再提供无参数的构造方法。\n3.无参数构造方法和有参数构造方法都可以调用。\nStudent x = new Student();Student y = new Student(123);\n\n4.构造方法支持方法重载。在一个类当中构造方法可以有多个，并且所有的构造方法名字都是一样的。(与类名一致）\n代码示例：\nStudent.java:\n/** * @author OliverChen */public class Student &#123;    int id;    String name;    boolean sex;    String address;    int age;    public Student()    &#123;        System.out.println(&quot;无参数的构造方法执行了！&quot;);    &#125;    public Student(int i)    &#123;        System.out.println(i);    &#125;&#125;\n\nConstructorTest.java:\n/** * @author OliverChen */public class ConstructorTest &#123;    public static void main(String[] args) &#123;        new Student();        //调用Student类的无参数构造方法        ConstructorTest.doSome();        doSome();        //调用普通方法        Student s1 = new Student();        System.out.println(s1);        //输出“引用”        //只要输出结果不是null，说明这个对象一定是创建完成了        Student s2 = new Student(100);        System.out.println(s2);        //这是调用另一个有参数的构造方法    &#125;    public static void doSome()    &#123;        System.out.println(&quot;Do some!!!!&quot;);    &#125;&#125;\n\n综上，构造方法是用来创建对象，并且同时给对象的属性赋值（注意：实例变量没有手动赋值时，系统会使用默认值）\n封装\n封装的作用：1.保证内部结构的安全2.屏蔽复杂，暴露简单\n\n如何进行封装？第一步：属性私有化（使用private关键字进行修饰）第二步:对外提供简单的操作入口:1个属性对外提供两个set和get方法。外部程序只能通过set方法修改，只能通过get方法读取，可以在set方法中设立关卡来保证数据的安全性。\n\n\nset和get方法都是实例方法，不能带static。\n不带static的方法称为实例方法，实例方法的调用必须先new对象。\n以下为代码示例：\nPerson.java:\n/** * @author OliverChen */public class Person &#123;    private int age;    //private表示私有的，被这个关键字修饰之后，该数据只能在本类中访问。    //出了这个类，age就无法访问了。    public int getAge() &#123;        return age;    &#125;    //get方法    /*    格式要求：public 返回值类型 get+属性名首字母大写(无参)&#123;        return xxx;    &#125;    */    public boolean setAge(int nianLing) &#123;        int nianLingMax = 150;        if(nianLing &lt; 0 || nianLing &gt; nianLingMax)        &#123;            System.out.println(&quot;年龄不合法！&quot;);            return false;        &#125;        age = nianLing;        return true;    &#125;    //set方法    /*    格式要求：public 返回值类型 set+属性名首字母大写(有一个参数)&#123;        xxx = 参数;    &#125;    */    //对外提供简单的访问入口    //外部程序只能通过调用以上代码来完成访问&#125;\n\nPersonTest.java\n/** * @author OliverChen */import java.util.Scanner;public class PersonTest &#123;    public static void main(String[] args) &#123;        Person p1= new Person();        Scanner s = new Scanner(System.in);        //创建对象        //若仅有private int age;        //则此时person的age彻底在外部不能访问，未免有些过于安全了        //age不能访问，此程序意义不大        int i;        boolean found;        do&#123;        i = s.nextInt();        found = p1.setAge(i);&#125;        while(!found);        System.out.println(p1.getAge());    &#125;&#125;\n\nstatic关键字1、static修饰的统一都是静态的，都是类相关的，不需要new对象。直接采用“类名.”访问。2、当一个属性是类级别的属性，所有对象的这个属性的值是一样的，建议定义为静态变量。3、static修饰的变量：静态变量（在类加载的时候执行）4、static修饰的方法：静态方法\n变量根据声明的位置进行划分：\n\n在方法体当中声明的变量叫做：局部变量\n在方法体外声明的变量叫做：成员变量\n\n成员变量又可分为：\n\n实例变量\n静态变量\n\nclass VarTest&#123;\t// 以下实例的，都是对象相关的，访问时采用“引用.”的方式访问。需要先new对象。\t// 实例相关的，必须先有对象，才能访问，可能会出现空指针异常。\t// 成员变量中的实例变量\tint i;\t// 实例方法\tpublic void m2()&#123;\t\t// 局部变量\t\tint x = 200;\t&#125;\t// 以下静态的，都是类相关的，访问时采用“类名.”的方式访问。不需要new对象。\t// 不需要对象的参与即可访问。没有空指针异常的发生。\t// 成员变量中的静态变量\tstatic int k;\t// 静态方法\tpublic static void m1()&#123;\t\t// 局部变量\t\tint m = 100;\t&#125;\t&#125;\n\n什么时候变量声明为实例的，什么时候声明为静态的？如果这个类型的所有对象的某个属性值都是一样的，不建议定义为实例变量，浪费内存空间。建议定义为类级别特征，定义为静态变量，在方法区中只保留一份，节省内存开销。\n一个对象一份的是实例变量。所有对象一份的是静态变量。\n实例相关的都是需要new对象的。\n代码示例：\npublic class StaticTest&#123;\tpublic static void main(String[] args)&#123;\t\t// 访问中国人的国籍\t\t// 静态变量应该使用类名.的方式访问\t\tSystem.out.println(Chinese.country);\t\tChinese c1 = new Chinese(&quot;1231456456456456&quot;,&quot;张三&quot;);\t\tSystem.out.println(c1.idCard);\t\tSystem.out.println(c1.name);\t\tChinese c2 = new Chinese(&quot;7897897896748564&quot;,&quot;李四&quot;);\t\tSystem.out.println(c2.idCard);\t\tSystem.out.println(c2.name);\t\t// idCard是实例变量，必须先new对象，通过“引用.” 访问\t&#125;&#125;// 定义一个类：中国人class Chinese&#123;\t// 身份证号\t// 每一个人的身份证号不同，所以身份证号应该是实例变量，一个对象一份。\tString idCard; \t// 姓名\t// 姓名也是一个人一个姓名，姓名也应该是实例变量。\tString name;\t// 国籍\t// 加static的变量叫做静态变量\t// 静态变量在类加载时初始化，不需要new对象，静态变量的空间就开出来了。\t// 静态变量存储在方法区。\tstatic String country = &quot;中国&quot;;\t// 无参数\tpublic Chinese()&#123;\t\t&#125;\t// 有参数\tpublic Chinese(String s1,String s2)&#123;\t\tidCard = s1;\t\tname = s2;\t&#125;&#125;\n\nJVM体现：\n\n\n静态代码块1、使用static关键字可以定义：静态代码块\n2、什么是静态代码块，语法是什么？static {            java语句;            java语句;        }\n3、static静态代码块在什么时候执行呢？        类加载时执行。并且只执行一次。        静态代码块有这样的特征&#x2F;特点。\n4、注意：静态代码块在类加载时执行，并且在main方法执行之前执行。\n5、静态代码块一般是按照自上而下的顺序执行。\n6、静态代码块有啥作用，有什么用？        第一：静态代码块不是那么常用。（不是每一个类当中都要写的东西。）        第二：静态代码块这种语法机制实际上是SUN公司给我们java程序员的一个特殊的时刻&#x2F;时机。        这个时机叫做：类加载时机。\n具体的业务：        项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM当中了）。        思考：这些记录日志的代码写到哪里呢？            写到静态代码块当中。\n代码示例：\npublic class StaticTest&#123;\t// 静态代码块（特殊的时机：类加载时机。）\tstatic &#123;\t\tSystem.out.println(&quot;A&quot;);\t&#125;\t// 一个类当中可以编写多个静态代码块\tstatic &#123;\t\tSystem.out.println(&quot;B&quot;);\t&#125;\t// 入口\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(&quot;Hello World!&quot;);\t&#125;\t// 编写一个静态代码块\tstatic&#123;\t\tSystem.out.println(&quot;C&quot;);\t&#125;&#125;/*ABCHello World!*/\n\n实例语句块1、实例语句在类加载时并没有执行。2、实例语句语法    {        java语句;        java语句;        java语句;    }3、实例语句块在什么时候执行？    只要是构造方法执行，必然在构造方法执行之前，自动执行“实例语句块”中的代码。    实际上这也是SUN公司为java程序员准备一个特殊的时机，叫做对象构建时机。若每个构造方法中前几行语句均相同，则可以使用实例语句块进行简化\n代码示例：\npublic class InstanceCode&#123;\t//入口\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(&quot;main begin&quot;);\t\tnew InstanceCode();\t\tnew InstanceCode();\t\tnew InstanceCode(&quot;abc&quot;);\t\tnew InstanceCode(&quot;xyz&quot;);\t&#125;\t//实例语句块\t&#123;\t\tSystem.out.println(&quot;实例语句块执行！&quot;);\t\t&#125;\t// Constructor\tpublic InstanceCode()&#123;\t\tSystem.out.println(&quot;无参数构造方法&quot;);\t&#125;\t// Constructor\tpublic InstanceCode(String name)&#123;\t\tSystem.out.println(&quot;有参数的构造方法&quot;);\t&#125;&#125;\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志7","url":"/2022/04/27/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%977-java7/","content":"this关键字1.1、this是一个关键字，是一个引用，保存内存地址指向自身。    1.2、this可以使用在实例方法中，也可以使用在构造方法中。    1.3、this出现在实例方法中其实代表的是当前对象。    1.4、this不能使用在静态方法中。    1.5、this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。    1.6、this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。\nJVM中的体现\n\n代码示例：\n/*1、this可以使用在实例方法中，不能使用在静态方法中。2、this关键字大部分情况下可以省略，什么时候不能省略呢？\t在实例方法中，或者构造方法中，为了区分局部变量和实例变量，\t这种情况下：this. 是不能省略的。*/public class ThisTest03&#123;\tpublic static void main(String[] args)&#123;\t\tStudent s = new Student();\t\ts.setNo(111);\t\ts.setName(&quot;张三&quot;);\t\tSystem.out.println(&quot;学号：&quot; + s.getNo());\t\tSystem.out.println(&quot;姓名：&quot; + s.getName());\t\tStudent s2 = new Student(2222, &quot;李四&quot;);\t\tSystem.out.println(&quot;学号：&quot; + s2.getNo());\t\tSystem.out.println(&quot;姓名：&quot; + s2.getName());\t&#125;&#125;// 分析一下：以下代码哪里写的不好。// 学生类class Student&#123;\t//学号\tprivate int no;\t//姓名\tprivate String name;\t//构造方法无参\tpublic Student()&#123;\t\t&#125;\t//构造方法有参\t/*\tpublic Student(int i, String s)&#123;\t\tno = i;\t\tname = s;\t&#125;\t*/\t// 上面的构造方法也增强以下可读性\tpublic Student(int no, String name)&#123;\t\tthis.no = no;\t\tthis.name = name;\t&#125;\t// setter and getter方法\t/*\tpublic void setNo(int i)&#123;\t\tno = i;\t&#125;\t*/\t/*\tpublic void setNo(int no)&#123; // 就近原则。\t\tno = no; //这两个no都是局部变量no，和实例变量no没关系。\t&#125;\t*/\tpublic void setNo(int no)&#123; \t\t//no是局部变量\t\t//this.no 是指的实例变量。\t\tthis.no = no; // this. 的作用是：区分局部变量和实例变量。\t&#125;\tpublic int getNo()&#123;\t\treturn no;\t\t//return this.no;\t&#125;\t/*\tpublic void setName(String s)&#123;\t\tname = s;\t&#125;\t*/\t/*\tpublic void setName(String name)&#123; // 就近原则\t\tname = name; //这两个name都是局部变量name，和实例变量name没关系。\t&#125;\t*/\tpublic void setName(String name)&#123;\t\tthis.name = name;\t&#125;\t/*\tpublic String getName()&#123;\t\treturn name;\t&#125;\t*/\tpublic String getName()&#123; // getName实际上获取的是“当前对象”的名字。\t\t//return this.name; // 严格来说，这里是有一个 this. 的。只不过这个 this. 是可以省略的。\t\treturn name;\t&#125;&#125;\n\n/*\t1、this除了可以使用在实例方法中，还可以用在构造方法中。\t2、新语法：通过当前的构造方法去调用另一个本类的构造方法，可以使用以下语法格式：\t\tthis(实际参数列表);\t\t\t通过一个构造方法1去调用构造方法2，可以做到代码复用。\t\t\t但需要注意的是：“构造方法1”和“构造方法2” 都是在同一个类当中。\t3、this() 这个语法作用是什么？\t\t代码复用。\t\t4、死记硬背：\t\t对于this()的调用只能出现在构造方法的第一行。*/public class ThisTest04&#123;\tpublic static void main(String[] args)&#123;\t\t// 调用无参数构造方法\t\tDate d1 = new Date();\t\td1.detail();\t\t// 调用有参数构造方法\t\tDate d2 = new Date(2008, 8, 8);\t\td2.detail();\t&#125;&#125;/*需求：\t1、定义一个日期类，可以表示年月日信息。\t2、需求中要求：\t\t如果调用无参数构造方法，默认创建的日期为：1970年1月1日。\t\t当然，除了调用无参数构造方法之外，也可以调用有参数的构造方法来创建日期对象。*/class Date&#123; // 以后写代码都要封装，属性私有化，对外提供setter and getter\t//年\tprivate int year;\t//月\tprivate int month;\t//日\tprivate int day;\t// 构造方法无参\t// 调用无参数构造方法，初始化的日期是固定值。\tpublic Date()&#123;\t\t//错误: 对this的调用必须是构造器中的第一个语句\t\t//System.out.println(11);\t\t/*\t\tthis.year = 1970;\t\tthis.month = 1;\t\tthis.day = 1;\t\t*/\t\tthis(1970, 1, 1);\t&#125;\t// 构造方法有参数\tpublic Date(int year, int month, int day)&#123;\t\tthis.year = year;\t\tthis.month = month;\t\tthis.day = day;\t&#125;\t// 提供一个可以打印日期的方法\tpublic void detail()&#123;\t\t//System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;);\t\tSystem.out.println(this.year + &quot;年&quot; + this.month + &quot;月&quot; + this.day + &quot;日&quot;);\t&#125;\t//setter and getter\tpublic void setYear(int year)&#123;\t\t// 设立关卡（有时间可以设立关卡）\t\tthis.year = year;\t&#125;\tpublic int getYear()&#123;\t\treturn year;\t&#125;\tpublic void setMonth(int month)&#123;\t\t// 设立关卡（有时间可以设立关卡）\t\tthis.month = month;\t&#125;\tpublic int getMonth()&#123;\t\treturn month;\t&#125;\tpublic void setDay(int day)&#123;\t\t// 设立关卡（有时间可以设立关卡）\t\tthis.day = day;\t&#125;\tpublic int getDay()&#123;\t\treturn day;\t&#125;&#125;\n\n继承(上)1、什么是继承，有什么用？        继承：在现实世界当中也是存在的，例如：父亲很有钱，儿子不用努力也很有钱。        继承的作用：            基本作用：子类继承父类，代码可以得到复用。（这个不是重要的作用，是基本作用。）            主要(重要)作用：因为有了继承关系，才有了后期的方法覆盖和多态机制。\n2、继承的相关特性        ① B类继承A类，则称A类为超类(superclass)、父类、基类，        B类则称为子类(subclass)、派生类、扩展类。            class A{}            class B extends A{}            我们平时聊天说的比较多的是：父类和子类。            superclass 父类            subclass 子类\n② java 中的继承只支持单继承，不支持多继承，C++中支持多继承，        这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码：            class B extends A,C{ } 这是错误的。\n③ 虽然 java 中不支持多继承，但有的时候会产生间接继承的效果，        例如：class C extends B，class B extends A，也就是说，C 直接继承 B，        其实 C 还间接继承 A。\n④ java 中规定，子类继承父类，除构造方法不能继承之外，剩下都可以继承。但是私有的属性无法在子类中直接访问。(父类中private修饰的不能在子类中直接访问。可以通过间接的手段来访问。)\n⑤ java 中的类没有显示的继承任何类，则默认继承 Object类，Object类是        java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有        Object类型中所有的特征。\n⑥ 继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它们之间的耦合度非常高，Account 类发生改变之后会马上影响CreditAccount 类\n代码示例:\n// 使用继承机制来解决代码复用问题。// 继承也是存在缺点的：耦合度高，父类修改，子类受牵连。public class ExtendsTest02&#123;\tpublic static void main(String[] args)&#123;\t\t// 创建普通账户\t\tAccount act = new Account();\t\tact.setActno(&quot;1111111&quot;);\t\tact.setBalance(10000);\t\tSystem.out.println(act.getActno() + &quot;,余额&quot; + act.getBalance());\t\t// 创建信用账户\t\tCreditAccount ca = new CreditAccount();\t\tca.setActno(&quot;2222222&quot;);\t\tca.setBalance(-10000);\t\tca.setCredit(0.99);\t\tSystem.out.println(ca.getActno() + &quot;,余额&quot; + ca.getBalance() + &quot;,信誉度&quot; + ca.getCredit());\t&#125;&#125;// 银行账户类// 账户的属性：账号、余额class Account&#123; // 父类\t// 属性\tprivate String actno;\tprivate double balance;\t// 构造方法\tpublic Account()&#123;\t\t&#125;\tpublic Account(String actno, double balance)&#123;\t\tthis.actno = actno;\t\tthis.balance = balance;\t&#125;\t// setter and getter\tpublic void setActno(String actno)&#123;\t\tthis.actno = actno;\t&#125;\tpublic String getActno()&#123;\t\treturn actno;\t&#125;\tpublic void setBalance(double balance)&#123;\t\tthis.balance = balance;\t&#125;\tpublic double getBalance()&#123;\t\treturn balance;\t&#125;&#125;// 其它类型的账户：信用卡账户// 账号、余额、信誉度class CreditAccount extends Account&#123; //子类\t// 属性\tprivate double credit;\t// 构造方法\tpublic CreditAccount()&#123;\t\t&#125;\tpublic void doSome()&#123;\t\t//错误: actno 在 Account 中是 private 访问控制\t\t//System.out.println(actno);\t\t// 间接访问\t\t//System.out.println(this.getActno());\t\tSystem.out.println(getActno());\t&#125;\t// setter and getter方法\tpublic void setCredit(double credit)&#123;\t\tthis.credit = credit;\t&#125;\tpublic double getCredit()&#123;\t\treturn credit;\t&#125;\t&#125;\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志8","url":"/2022/04/28/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%978-java8/","content":"继承(下)在实际开发中，满足什么条件的时候，我可以使用继承呢？        凡是采用“is a”能描述的，都可以继承。        例如：            Cat is a Animal：猫是一个动物            Dog is a Animal：狗是一个动物            CreditAccount is a Account：信用卡账户是一个银行账户            ….\n假设以后的开发中有一个A类，有一个B类，A类和B类确实也有重复的代码，那么他们两个之间就可以继承吗？不一定，还是要看一看它们之间是否能够使用is a来描述。\nclass Customer&#123;\tString name; // 名字\t// setter and getter&#125;class Product&#123;\tString name; // 名字\t// setter and getter&#125;class Product extends Customer&#123;\t\t\t&#125;\n\n\n以上的继承就属于很失败的。因为：Product is a Customer，是有违伦理的。\n方法覆盖2.1、什么时候考虑使用方法覆盖？        父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。\n2.2、什么条件满足的时候构成方法覆盖？        第一：有继承关系的两个类        第二：具有相同方法名、返回值类型、形式参数列表        第三：访问权限不能更低。        第四：抛出异常不能更多。\n2.3、关于Object类中toString()方法的覆盖？        toString()方法存在的作用就是：将java对象转换成字符串形式。        大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()        方法输出的是一个java对象的内存地址。至于toString()方法具体怎么进行覆盖？            格式可以自己定义，或者听需求的。（听项目要求的。）\n2.4、方法重载和方法覆盖有什么区别？\n\n方法重载发生在同一个类当中。\n\n方法覆盖是发生在具有继承关系的父子类之间。\n\n方法重载是一个类中，方法名相同，参数列表不同。\n\n方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：方法名一致、参数列表一致、返回值类型一致。\n\n\n代码示例：\n/** * @author OliverChen */public class OverrideTest &#123;    public static void main(String[] args) &#123;        Animals.doSomething();        Bird b = new Bird();        b.move();        Cat c = new Cat();        c.move();    &#125;&#125;class Animals&#123;    public static void doSomething()    &#123;        O.p(&quot;Do something!&quot;);    &#125;    public void move()    &#123;        O.p(&quot;动物在移动!!!&quot;);    &#125;&#125;class Bird extends Animals&#123;    public void move()    &#123;        O.p(&quot;鸟儿在飞翔！&quot;);    &#125;&#125;class Cat extends Animals&#123;    public void move()    &#123;        O.p(&quot;猫在走猫步！&quot;);    &#125;&#125;\n多态（非常重要!!!)向上转型、向下转型与instanceof运算符两种类型间必须有继承关系！！！\n向上转型：子—&gt;父 (upcasting)            又被称为自动类型转换：Animal a &#x3D; new Cat();\n向下转型：父—&gt;子 (downcasting)又被称为强制类型转换：Cat c &#x3D; (Cat)a; 需要添加强制类型转换符。\n什么时候需要向下转型？需要调用或者执行子类对象中特有的方法。必须进行向下转型，才可以调用。\n向下转型有风险吗？容易出现ClassCastException（类型转换异常）\n怎么避免这个风险？instanceof运算符，可以在程序运行阶段动态的判断某个引用指向的对象是否为某一种类型。养成好习惯，向下转型之前一定要使用instanceof运算符进行判断。不管是向上转型还是向下转型，首先他们之间必须有继承关系，这样编译器就不会报错。\n代码示例：（非常重要的示例！！！）\npublic class Test01&#123;\tpublic static void main(String[] args)&#123;\t\tAnimal a1 = new Animal();\t\ta1.move(); //动物在移动！！！\t\tCat c1 = new Cat();\t\tc1.move(); //cat走猫步！\t\tBird b1 = new Bird();\t\tb1.move(); //鸟儿在飞翔！！！\t\t// 代码可以这样写吗？\t\t/*\t\t\t1、Animal和Cat之间有继承关系吗？有的。\t\t\t2、Animal是父类，Cat是子类。\t\t\t3、Cat is a Animal，这句话能不能说通？能。\t\t\t4、经过测试得知java中支持这样的一个语法：\t\t\t\t父类型的引用允许指向子类型的对象。\t\t\t\tAnimal a2 = new Cat();\t\t\t\ta2就是父类型的引用。\t\t\t\tnew Cat()是一个子类型的对象。\t\t\t\t允许a2这个父类型引用指向子类型的对象。\t\t*/\t\tAnimal a2 = new Cat();\t\tAnimal a3 = new Bird();\t\t// 没有继承关系的两个类型之间存在转型吗？\t\t// 错误: 不兼容的类型: Dog无法转换为Animal\t\t// Animal a4 = new Dog();\t\t// 调用a2的move()方法\t\t/*\t\t\t什么是多态？\t\t\t\t多种形态，多种状态。\t\t\t分析：a2.move();\t\t\t\tjava程序分为编译阶段和运行阶段。\t\t\t\t先来分析编译阶段：\t\t\t\t\t对于编译器来说，编译器只知道a2的类型是Animal，\t\t\t\t\t所以编译器在检查语法的时候，会去Animal.class\t\t\t\t\t字节码文件中找move()方法，找到了，绑定上move()\t\t\t\t\t方法，编译通过，静态绑定成功。（编译阶段属于静态绑定。）\t\t\t\t再来分析运行阶段：\t\t\t\t\t运行阶段的时候，实际上在堆内存中创建的java对象是\t\t\t\t\tCat对象，所以move的时候，真正参与move的对象是一只猫，\t\t\t\t\t所以运行阶段会动态执行Cat对象的move()方法。这个过程\t\t\t\t\t属于运行阶段绑定。（运行阶段绑定属于动态绑定。）\t\t\t多态表示多种形态：\t\t\t\t编译的时候一种形态。\t\t\t\t运行的时候另一种形态。\t\t*/\t\ta2.move(); //cat走猫步！\t\t\t\t// 调用a3的move()方法\t\ta3.move(); //鸟儿在飞翔！！！\t\t// ======================================================================\t\tAnimal a5 = new Cat(); // 底层对象是一只猫。\t\t// 分析这个程序能否编译和运行呢？\t\t// 分析程序一定要分析编译阶段的静态绑定和运行阶段的动态绑定。\t\t// 只有编译通过的代码才能运行。没有编译，根本轮不到运行。\t\t// 错误: 找不到符号\t\t// why??? 因为编译器只知道a5的类型是Animal，去Animal.class文件中找catchMouse()方法\t\t// 结果没有找到，所以静态绑定失败，编译报错。无法运行。（语法不合法。）\t\t//a5.catchMouse(); \t\t\t\t// 假设代码写到了这里，我非要调用catchMouse()方法怎么办？\t\t// 这个时候就必须使用“向下转型”了。（强制类型转换）\t\t// 以下这行代码为啥没报错？？？？\t\t// 因为a5是Animal类型，转成Cat，Animal和Cat之间存在继承关系。所以没报错。\t\tCat x = (Cat)a5;\t\tx.catchMouse(); //猫正在抓老鼠！！！！\t\t// 向下转型有风险吗？\t\tAnimal a6 = new Bird(); //表面上a6是一个Animal，运行的时候实际上是一只鸟儿。\t\t/*\t\t\t分析以下程序，编译报错还是运行报错？？？\t\t\t\t编译器检测到a6这个引用是Animal类型，\t\t\t\t而Animal和Cat之间存在继承关系，所以可以向下转型。\t\t\t\t编译没毛病。\t\t\t\t运行阶段，堆内存实际创建的对象是：Bird对象。\t\t\t\t在实际运行过程中，拿着Bird对象转换成Cat对象\t\t\t\t就不行了。因为Bird和Cat之间没有继承关系。\t\t\t\t\t\t运行是出现异常，这个异常和空指针异常一样非常重要，也非常经典：\t\t\t\tjava.lang.ClassCastException：类型转换异常。\t\t\t\t\t\tjava.lang.NullPointerException：空指针异常。这个也非常重要。\t\t*/\t\t//Cat y = (Cat)a6;\t\t//y.catchMouse();\t\t// 怎么避免ClassCastException异常的发生？？？\t\t/*\t\t\t\t新的内容，运算符：\t\t\t\tinstanceof （运行阶段动态判断）\t\t\t第一：instanceof可以在运行阶段动态判断引用指向的对象的类型。\t\t\t第二：instanceof的语法：\t\t\t\t(引用 instanceof 类型)\t\t\t第三：instanceof运算符的运算结果只能是：true/false\t\t\t第四：c是一个引用，c变量保存了内存地址指向了堆中的对象。\t\t\t\t假设(c instanceof Cat)为true表示:\t\t\t\t\tc引用指向的堆内存中的java对象是一个Cat。\t\t\t\t假设(c instanceof Cat)为false表示:\t\t\t\t\tc引用指向的堆内存中的java对象不是一个Cat。\t\t\t\t\t\t程序员要养成一个好习惯：\t\t\t\t任何时候，任何地点，对类型进行向下转型时，一定要使用\t\t\t\tinstanceof 运算符进行判断。（java规范中要求的。）\t\t\t\t这样可以很好的避免：ClassCastException\t\t*/\t\tSystem.out.println(a6 instanceof Cat); //false\t\tif(a6 instanceof Cat)&#123; // 如果a6是一只Cat\t\t\tCat y = (Cat)a6;  // 再进行强制类型转换\t\t\ty.catchMouse();\t\t&#125;\t&#125;&#125;\n\n多态的概念多种形态，多种状态，编译和运行有两个不同的状态。        编译期叫做静态绑定。        运行期叫做动态绑定。\nAnimal a = new Cat();\t\t// 编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move()方法\t\t// 找到了，绑定，编译通过。但是运行的时候和底层堆内存当中的实际对象有关\t\t// 真正执行的时候会自动调用“堆内存中真实对象”的相关方法。\t\ta.move();\n\n多态在开发中的应用（非常重要！！！）多态在开发中的作用是：        降低程序的耦合度，提高程序的扩展力。\n代码示例（非常重要！！！！！！！）\nMaster.java：// 主人类public class Master&#123;\t/*\t// 假设主人起初的时候只是喜欢养宠物狗狗\t// 喂养宠物狗狗\tpublic void feed(Dog d)&#123;\t\td.eat();\t&#125;\t// 由于新的需求产生，导致我们“不得不”去修改Master这个类的代码\tpublic void feed(Cat c)&#123;\t\tc.eat();\t&#125;\t*/\t\t// 能不能让Master主人这个类以后不再修改了。\t// 即使主人又喜欢养其它宠物了，Master也不需要修改。\t// 这个时候就需要使用：多态机制。\t// 最好不要写具体的宠物类型，这样会影响程序的扩展性。\tpublic void feed(Pet pet)&#123; \t\t// 编译的时候，编译器发现pet是Pet类，会去Pet类中找eat()方法，结果找到了，编译通过\t\t// 运行的时候，底层实际的对象是什么，就自动调用到该实际对象对应的eat()方法上。\t\t// 这就是多态的使用。\t\tpet.eat();\t&#125;&#125;/*\t注意这里的分析：\t\t主人起初的时候只喜欢养宠物狗狗\t\t随着时间的推移，主人又喜欢上养“猫咪”\t\t在实际的开发中这就表示客户产生了新的需求。\t\t作为软件的开发人员来说，必须满足客户的需求。\t\t我们怎么去满足客户的需求呢？\t\t\t在不使用多态机制的前提下，目前我们只能在Master类中添加一个新的方法。\t\t思考：软件在扩展新需求过程当中，修改Master这个类有什么问题？\t\t一定要记住：软件在扩展过程当中，修改的越少越好。\t\t修改的越多，你的系统当前的稳定性就越差，未知的风险就越多。\t\t其实这里涉及到一个软件的开发原则：\t\t\t软件开发原则有七大原则（不属于java，这个开发原则属于整个软件业）：\t\t\t\t其中有一条最基本的原则：OCP（开闭原则）\t\t什么是开闭原则？\t\t\t对扩展开放（你可以额外添加，没问题），对修改关闭（最好很少的修改现有程序）。\t\t\t在软件的扩展过程当中，修改的越少越好。\t\t高手开发项目不是仅仅为了实现客户的需求，还需要考虑软件的扩展性。\t什么是软件扩展性？\t\t假设电脑中的内存条部件坏了，我们可以买一个新的插上，直接使用。\t\t这个电脑的设计就考虑了“扩展性”。内存条的扩展性很好。\t\t面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。\t因为面向具体编程会让软件的扩展力很差。*/// 所有宠物的父类class Pet&#123;\t// 吃的行为（这个方法可以不给具体的实现。）\tpublic void eat()&#123;\t\t&#125;&#125;// 宠物狗狗类class Dog extends Pet&#123;\t// 吃\tpublic void eat()&#123;\t\tSystem.out.println(&quot;狗狗喜欢啃骨头，吃的很香。&quot;);\t&#125;&#125;class Cat extends Pet&#123;\t// 吃\tpublic void eat()&#123;\t\tSystem.out.println(&quot;猫咪喜欢吃鱼，吃的很香！！！&quot;);\t&#125;&#125;\n\nTest.java:/*\t测试多态在开发中的作用*/public class Test&#123;\tpublic static void main(String[] args)&#123;\t\t// 创建主人对象\t\tMaster zhangsan = new Master();\t\t// 创建宠物对象\t\tDog zangAo = new Dog();\t\t// 主人喂\t\tzhangsan.feed(zangAo);\t\t// 创建宠物对象\t\tCat xiaoHua = new Cat();\t\t// 主人喂\t\tzhangsan.feed(xiaoHua);\t\t// 创建宠物对象\t\t\t&#125;&#125;\n\n一些补充面向对象的三大特征：封装、继承、多态真的是一环扣一环。\n有了封装，有了这种整体的概念之后。        对象和对象之间产生了继承。        有了继承之后，才有了方法的覆盖和多态。\n这里提到了一个软件开发原则：        七大原则最基本的原则：OCP（对扩展开放，对修改关闭）        目的是：降低程序耦合度，提高程序扩展力。        面向抽象编程，不建议面向具体编程。\n私有方法无法覆盖。\n方法覆盖只是针对于“实例方法”，“静态方法覆盖”没有意义。（这是因为方法覆盖通常和多态联合起来）\n总结两句话：        私有不能覆盖。静态不谈覆盖。\n在方法覆盖中，关于方法的返回值类型。        什么条件满足之后，会构成方法的覆盖呢？            1、发生具有继承关系的两个类之间。            2、父类中的方法和子类重写之后的方法：具有相同的方法名、相同的形式参数列表、相同的返回值类型。\n","categories":["技术类","JavaSE学习日志"]},{"title":"Java学习日志9","url":"/2022/04/29/Java%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%979-java9/","content":"super关键字super能出现在实例方法和构造方法中。\nsuper的语法是：“super.”、“super()”\nsuper不能使用在静态方法中。\nsuper. 大部分情况下是可以省略的。\nsuper.什么时候不能省略呢？        父类和子类中有同名属性，或者说有同样的方法，想在子类中访问父类的，super. 不能省略。\nsuper() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中    的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。\nsuper的使用：        super.属性名\t\t\t\t【访问父类的属性】        super.方法名(实参)\t\t【访问父类的方法】        super(实参)\t\t\t\t\t【调用父类的构造方法】\n代码示例1：\n/*\t1、super是一个关键字，全部小写。\t2、super和this对比着学习。\t\tthis:\t\t\tthis能出现在实例方法和构造方法中。\t\t\tthis的语法是：“this.”、“this()”\t\t\tthis不能使用在静态方法中。\t\t\tthis. 大部分情况下是可以省略的。\t\t\tthis.什么时候不能省略呢？ 在区分局部变量和实例变量的时候不能省略。\t\t\t\tpublic void setName(String name)&#123;\t\t\t\t\tthis.name = name;\t\t\t\t&#125;\t\t\tthis() 只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中\t\t\t其它的构造方法，目的是：代码复用。\t\tsuper:\t\t\tsuper能出现在实例方法和构造方法中。\t\t\tsuper的语法是：“super.”、“super()”\t\t\tsuper不能使用在静态方法中。\t\t\tsuper. 大部分情况下是可以省略的。\t\t\tsuper.什么时候不能省略呢？ ？？？？？？？\t\t\tsuper() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中\t\t\t的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。\t3、super()\t\t表示通过子类的构造方法调用父类的构造方法。\t\t模拟现实世界中的这种场景：要想有儿子，需要先有父亲。\t\t4、重要的结论：\t\t当一个构造方法第一行：\t\t\t既没有this()又没有super()的话，默认会有一个super();\t\t\t表示通过当前子类的构造方法调用父类的无参数构造方法。\t\t\t所以必须保证父类的无参数构造方法是存在的。\t\t5、注意：\t\tthis()和super() 不能共存，它们都是只能出现在构造方法第一行。\t\t6、无论是怎样折腾，父类的构造方法是一定会执行的。（百分百的。）\t*/public class SuperTest01&#123;\tpublic static void main(String[] args)&#123;\t\t// 创建子类对象\t\t/*\t\t\tA类的无参数构造方法！\t\t\tB类的无参数构造方法！\t\t*/\t\tnew B();\t&#125;&#125;class A extends Object&#123;\t// 建议手动的将一个类的无参数构造方法写出来。\tpublic A()&#123;\t\t//super(); // 这里也是默认有这一行代码的。\t\tSystem.out.println(&quot;A类的无参数构造方法！&quot;);\t&#125;\t// 一个类如果没有手动提供任何构造方法，系统会默认提供一个无参数构造方法。\t// 一个类如果手动提供了一个构造方法，那么无参数构造系统将不再提供。\tpublic A(int i)&#123;\t\t//super();\t\tSystem.out.println(&quot;A类的有参数构造方法(int)&quot;);\t&#125;&#125;class B extends A&#123;\t/*\tpublic B()&#123;\t\tsuper();\t\tSystem.out.println(&quot;B类的无参数构造方法！&quot;);\t&#125;\t*/\tpublic B()&#123;\t\tthis(&quot;zhangsan&quot;);\t\t// 调用父类中有参数的构造方法\t\t//super(123);\t\tSystem.out.println(&quot;B类的无参数构造方法！&quot;);\t&#125;\tpublic B(String name)&#123;\t\tsuper();\t\tSystem.out.println(&quot;B类的有参数构造方法(String)&quot;);\t&#125;&#125;\n\n代码示例2：\n/*\t1、举个例子：在恰当的时间使用：super(实际参数列表);\t2、注意：在构造方法执行过程中一连串调用了父类的构造方法，\t父类的构造方法又继续向下调用它的父类的构造方法，但是实际上\t对象只创建了一个。\t3、思考：“super(实参)”到底是干啥的？\t\tsuper(实参)的作用是：初始化当前对象的父类型特征。\t\t并不是创建新对象。实际上对象只创建了1个。\t\t4、super关键字代表什么呀？\t\tsuper关键字代表的就是“当前对象”的那部分父类型特征。\t\t我继承了我父亲的一部分特征：\t\t\t例如：眼睛、皮肤等.\t\t\tsuper代表的就是“眼睛、皮肤等”。\t\t\t“眼睛、皮肤等”虽然是继承了父亲的，但这部分是在我身上呢。*/// 测试程序public class SuperTest03&#123;\tpublic static void main(String[] args)&#123;\t\tCreditAccount ca1 = new CreditAccount();\t\tSystem.out.println(ca1.getActno() + &quot;,&quot; + ca1.getBalance() + &quot;,&quot; + ca1.getCredit());\t\tCreditAccount ca2 = new CreditAccount(&quot;1111&quot;, 10000.0, 0.999);\t\tSystem.out.println(ca2.getActno() + &quot;,&quot; + ca2.getBalance() + &quot;,&quot; + ca2.getCredit());\t&#125;&#125;// 账户class Account extends Object&#123;\t// 属性\tprivate String actno;\tprivate double balance;\t// 构造方法\tpublic Account()&#123;\t\t//super();\t\t//this.actno = null;\t\t//this.balance = 0.0;\t&#125;\tpublic Account(String actno, double balance)&#123;\t\t// super();\t\tthis.actno = actno;\t\tthis.balance = balance;\t&#125;\t// setter and getter\tpublic void setActno(String actno)&#123;\t\tthis.actno = actno;\t&#125;\tpublic String getActno()&#123;\t\treturn actno;\t&#125;\tpublic void setBalance(double balance)&#123;\t\tthis.balance = balance;\t&#125;\tpublic double getBalance()&#123;\t\treturn balance;\t&#125;&#125;// 信用账户class CreditAccount extends Account&#123;\t// 属性：信誉度（诚信值）\t// 子类特有的一个特征，父类没有。\tprivate double credit;\t// 构造方法\t// 分析以下程序是否存在编译错误？？？？\tpublic CreditAccount(String actno, double balance, double credit)&#123;\t\t// 私有的属性，只能在本类中访问。\t\t/*\t\tthis.actno = actno;\t\tthis.balance = balance;\t\t*/\t\t// 以上两行代码在恰当的位置，正好可以使用：super(actno, balance);\t\t// 通过子类的构造方法调用父类的构造方法。\t\tsuper(actno, balance);\t\tthis.credit = credit;\t&#125;\t// 提供有参数的构造方法\tpublic CreditAccount()&#123;\t\t//super();\t\t//this.credit = 0.0;\t&#125;\t// setter and getter方法\tpublic void setCredit(double credit)&#123;\t\tthis.credit = credit;\t&#125;\tpublic double getCredit()&#123;\t\treturn credit;\t&#125;\t&#125;\n\n代码示例2的JVM体现：\n\nsuper不能省略时的JVM体现：\n\n分享几道作业题猜数字：/*猜数字游戏一个类A有一个实例变量v，从键盘接收一个正整数作为实例变量v的初始值。另外再定义一个类B，对A类的实例变量v进行猜测。\t如果大了则提示大了\t小了则提示小了\t等于则提示猜测成功*/import java.util.Scanner;public class HomeWork4GuessNumber &#123;    public static void main(String[] args)    &#123;        A a = new A(100);        B b = new B(a);        Scanner s = new Scanner(System.in);        while(true)        &#123;            O.p(&quot;请输入要猜测的数字：&quot;);            int num = s.nextInt();            b.guess(num);        &#125;    &#125;&#125;class A &#123;    public int getV() &#123;        return v;    &#125;    private int v;    public A() &#123;&#125;    public A(int v) &#123;        this.v = v;    &#125;&#125;class B&#123;   private A a;    public B() &#123;&#125;    public B(A a) &#123;        this.a = a;    &#125;    public void guess(int num)    &#123;        int realNum = a.getV();        if(realNum == num)        &#123;            O.p(&quot;猜对啦！&quot;);            System.exit(0);        &#125;        else if(realNum &gt; num)        &#123;            O.p(&quot;猜小了&quot;);        &#125;        else&#123;            O.p(&quot;猜大了&quot;);        &#125;    &#125;&#125;\n\n加减速：/*请定义一个交通工具(Vehicle)的类        其中有属性：        速度(speed)        体积(size)等等        方法移动(move())        设置速度(setSpeed(int speed))        加速speedUp(),        减速speedDown()等等.        最后在测试类Vehicle中的main()中实例化一个交通工具对象        并通过方法给它初始化speed,size的值并且打印出来。        另外调用加速减速的方法对速度进行改变。*/import java.util.Scanner;public class HomeWork5Transport &#123;    public static void main(String[] args) &#123;        Vehicle v = new Vehicle();        Scanner s = new Scanner(System.in);        O.p(&quot;请输入初始速度&quot;);        v.setSpeed(s.nextInt());        O.p(&quot;请输入初始体积&quot;);        v.setSize(s.nextInt());        O.p(&quot;初始速度为&quot; + v.getSpeed());        O.p(&quot;初始体积为&quot; + v.getSize());        int i,u=1;        while(u == 1) &#123;            O.p(&quot;输入1进行加速，输入2进行减速&quot;);            i = s.nextInt();            if (i == 1) &#123;                v.setSpeed(v.speedUp(v.getSpeed()));            &#125; else &#123;                v.setSpeed(v.speedDown(v.getSpeed()));            &#125;            O.p(&quot;此时的速度为&quot; + v.getSpeed());            O.p(&quot;输入1将继续加/减速，输入2将自动结束程序&quot;);            u = s.nextInt();        &#125;    &#125;&#125;class Vehicle&#123;    public int getSpeed() &#123;        return speed;    &#125;    public void setSpeed(int speed) &#123;        this.speed = speed;    &#125;    private int speed;    public int getSize() &#123;        return size;    &#125;    public void setSize(int size) &#123;        this.size = size;    &#125;    private int size ;    public int speedUp(int v) &#123;        v++;        return v;    &#125;    public int speedDown(int v) &#123;        v--;        return v;    &#125;&#125;\n\n增减时间:/*在程序中经常要对时间进行操作但是并没有时间类型的数据。那么我们可以自己实现一个时间类来满足程序中的需要。定义名为MyTime的类其中应有三个整型成员时hour分minute秒second为了保证数据的安全性这三个成员变量应声明为私有。为MyTime类定义构造方法以方便创建对象时初始化成员变量。再将时间信息打印出来。*/import java.util.Scanner;public class HomeWork6Time &#123;    public static void main(String[] args)&#123;        MyTime t = new MyTime();        Scanner s = new Scanner(System.in);        O.p(&quot;请输入初始小时&quot;);        t.setHour(s.nextInt());        O.p(&quot;请输入初始分钟&quot;);        t.setMinute(s.nextInt());        O.p(&quot;请输入初始秒数&quot;);        t.setSecond(s.nextInt());        O.p(&quot;您输入为&quot; + t.getHour() + &quot;小时&quot; + t.getMinute() + &quot;分钟&quot; + t.getSecond() + &quot;秒数&quot;);        int i=1;        while(i &gt; 0 &amp;&amp; i &lt;7) &#123;            O.p(&quot;增加1s请输入1，增加1min请输入2，增加1h请输入3&quot;);            O.p(&quot;减少1s请输入4，减少1min请输入5，减少1h请输入6，输入其他数字退出程序&quot;);            i = s.nextInt();            if (i == 1)                t.setSecond(t.addSecond(t.getSecond(),t.getMinute(),t.getHour()));            else if (i == 2)                t.setMinute(t.addMinute(t.getMinute(),t.getHour()));            else if (i == 3)                t.setHour(t.addHour(t.getHour()));            else if (i == 4)                t.setSecond(t.subSecond(t.getSecond(),t.getMinute(),t.getHour()));            else if (i == 5)                t.setMinute(t.subMinute(t.getMinute(),t.getHour()));            else if (i == 6)                t.setHour(t.subHour(t.getHour()));            O.p(&quot;时间为&quot; + t.getHour() + &quot;小时&quot; + t.getMinute() + &quot;分钟&quot; + t.getSecond() + &quot;秒数&quot;);        &#125;    &#125;&#125;class MyTime&#123;    public int getHour() &#123;        return hour;    &#125;    public void setHour(int hour) &#123;        this.hour = hour;    &#125;    private int hour;    public int getMinute() &#123;        return minute;    &#125;    public void setMinute(int minute) &#123;        this.minute = minute;    &#125;    private int minute;    public int getSecond() &#123;        return second;    &#125;    public void setSecond(int second) &#123;        this.second = second;    &#125;    private int second;    public int addSecond(int s,int m,int h) &#123;        s++;        if (s == 60)        &#123;            s = 0;            this.setMinute(addMinute(m,h));        &#125;        return s;    &#125;    public int addMinute(int m,int h) &#123;        m++;        if (m == 60)        &#123;            m = 0;            this.setHour(addHour(h));        &#125;        return m;    &#125;    public int addHour(int h) &#123;        h++;        return h;    &#125;    public int subHour(int h) &#123;        h--;        return h;    &#125;    public int subMinute(int m,int h)    &#123;        m--;        if(m&lt;0)        &#123;            m=59;            this.setHour(subHour(h));        &#125;        return m;    &#125;    public int subSecond(int s,int m,int h)    &#123;        s--;        if(s&lt;0)        &#123;            s=59;            this.setMinute(subMinute(m,h));        &#125;        return s;    &#125;&#125;\n","categories":["技术类","JavaSE学习日志"]},{"title":"LeetCode——31.下一个排列","url":"/2022/09/27/LeetCode%E2%80%94%E2%80%9431.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","content":"整数数组的一个排列 就是将其所有成员以序列或线性顺序排列。   \n例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的下一个排列就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。给你一个整数数组 nums ，找出 nums 的下一个排列。\n必须原地修改，只允许使用额外常数空间。\n算法推导如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：\n1.我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如123456，将 5 和 6 交换就能得到一个更大的数123465。2.我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：a.在尽可能靠右的低位进行交换，需要从后向前查找b.将一个 尽可能小的「大数」 与前面的「小数」交换。比如123465，下一个排列应该把5和4交换而不是把6 和4交换c.将「大数」换到前面后，需要将「大数」后面的所有数重置为逆置，逆置排列就是最小的排列。以123465为例：首先按照上一步，交换5和4，得到 123564；然后需要将5之后的数逆置，得到123546。显然123546比 123564更小，123546就是123465的下一个排列以上就是求“下一个排列”的分析过程。\n代码实现class Solution &#123;    public void nextPermutation(int[] nums) &#123;        int i = nums.length - 2;        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;            i--;        &#125;        if (i &gt;= 0) &#123;            int j = nums.length - 1;            while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123;                j--;            &#125;            swap(nums, i, j);        &#125;        reverse(nums, i + 1);    &#125;    public void swap(int[] nums, int i, int j) &#123;        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;    public void reverse(int[] nums, int start) &#123;        int left = start, right = nums.length - 1;        while (left &lt; right) &#123;            swap(nums, left, right);            left++;            right--;        &#125;    &#125;&#125;\n\n\n\n","categories":["技术类","LeetCode"]},{"title":"LeetCode——19. 删除链表的倒数第N个节点","url":"/2022/09/25/LeetCode%E2%80%94%E2%80%9419.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/","content":"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。  \n\n\n示例 ：\n输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2输出：[1,2,3,5]\n题解————双指针法\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    //通过快慢指针来解决，类似于你要删除中间元素的题    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        //定义一个伪节点，用于返回结果        ListNode dumpy = new ListNode(0);        dumpy.next = head;        //定义一个快指针,指向伪节点，用于遍历链表        ListNode prev = dumpy;        //定一个慢指针，        ListNode tail = dumpy;        //让快指针先移动 n 步        while(n &gt;0)&#123;            prev = prev.next;            n--;        &#125;        //只要快指针不指向空，就继续循环        while(prev.next !=null)&#123;            //让快慢指针同时移动            tail = tail.next;            prev = prev.next;        &#125;        //这时慢指针移动到的位置就是，要删除节点的前一个节点        //所以只要删除当前节点的下一个节点        tail.next = tail.next.next;        //返回为指针指向的头节点        return dumpy.next;    &#125;&#125;\n","categories":["技术类","LeetCode"]},{"title":"Windows字体大改造！","url":"/2022/03/07/Windows%E5%AD%97%E4%BD%93%E5%A4%A7%E6%94%B9%E9%80%A0%EF%BC%81-windowstype/","content":"事情的起因是我用的1080p屏幕实在是过于刺眼（尤其跟室友的2k，4k屏幕相比），在同为1080p的hxd室友的推荐下，全局换了个新微软雅黑的字体，又改成了Mactype字体渲染方式，VS里面的字体也换成了Consola。。\n体验简直翻了100倍！1080p屏幕我还能用4年！所以接下来就给大家介绍下Windows字体如何改造（又名如何让1080p冲焕生机）\n新微软雅黑以下是字体替换工具以及新微软雅黑字体的资源\n链接：https://pan.baidu.com/s/1NrE89heuX1HV7ByFchS37Q?pwd=z3pw提取码：z3pw \n下载解压后直接使用字体替换工具，选中字体替换即可，msyh.ttc是标准的新微软雅黑，其他的是加长&#x2F;light&#x2F;加粗版本，各位可以自己点开查看并选择最适合自己的字体\nMactypehttps://www.mactype.net/\n基本就是下载，然后跟着提示无脑操作就完事了。。\nVS Consola在VS的 ‘工具’——‘设置’——‘字体’ 里就可以选择啦，比默认的新宋体要柔和且清晰很多！\n后记果然，win系统只要想折腾，大部分的问题都能得以解决，之前还在考虑要不要换个屏幕更好的本子或者直接买外接4k的显示屏，现在看来已经不需要了。。windows，我的超人！\n","categories":["技术类"]},{"title":"歌词分享！","url":"/2022/04/03/%E6%AD%8C%E8%AF%8D%E5%88%86%E4%BA%AB%EF%BC%81-lyricsshare/","content":"昨天晚上听到了KB翻唱的中文版群青（其实yousa昨天也唱了，但是歌词跟原版比较接近），填词真的惊艳到我了，给大家分享下\n啊 雨落在了肩膀时间又在假装 睡着了的模样没咖啡的糖 化在了窗台上阳光它却不会为了谁而躲藏\n啊 泪落在了手掌还要逆风飞翔 换来如梦一场希望那么长 同样那么惆怅脚乱手忙只为了追逐理想\n打开窗 却看不到过往漂浮着的微凉 我还不懂欣赏只努力微笑着不忙 不慌 情绪被隐藏嘴角沉默了迷惘突然决定天一亮  就飞往陌生的机场\n放下杂念 用直觉去改变去实验 去表演逃避过的从前\n沉睡了 清醒了 想起了那一天 那一年跟自己说好的 那一句誓言\n不要回头 走到尽头我都不会认输所有让我失落过的只会变得更执着迷失的难过不过是一瞬间的忘我\n现在的我 不会再错放下杂念 用直觉去改变这一刻 全世界我就是 独一无二的烟火\n","categories":["所感"]},{"title":"数据结构与算法——基本概念","url":"/2022/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-shu-ju-jie-gou-yu-suan-fa--ji-ben-gai-nian/","content":"主要学习了数据结构与算法的基本概念，时间复杂度等\n以下为求最大子序列和的两种优化方法：\n分而治之：（NlogN）\nint Max3( int A, int B, int C )&#123;   /* 返回3个整数中的最大值 */\treturn A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;&#125;int DivideAndConquer( int List[], int left, int right )&#123;   /* 分治法求List[left]到List[right]的最大子列和 */\tint MaxLeftSum, MaxRightSum; /* 存放左右子问题的解 */\tint MaxLeftBorderSum, MaxRightBorderSum; /*存放跨分界线的结果*/\tint LeftBorderSum, RightBorderSum;\tint center, i;\tif( left == right )  /* 递归的终止条件，子列只有1个数字 */\t\tif( List[left] &gt; 0 )  return List[left];\telse return 0;    /* 下面是&quot;分&quot;的过程 */\tcenter = ( left + right ) / 2; /* 找到中分点 */\t/* 递归求得两边子列的最大和 */\tMaxLeftSum = DivideAndConquer( List, left, center );\tMaxRightSum = DivideAndConquer( List, center+1, right );    /* 下面求跨分界线的最大子列和 */\tMaxLeftBorderSum = 0; LeftBorderSum = 0;\tfor( i = center; i &gt;= left; i-- ) &#123; /* 从中线向左扫描 */\t\tLeftBorderSum += List[i];\t\tif( LeftBorderSum &gt; MaxLeftBorderSum )\t\t\tMaxLeftBorderSum = LeftBorderSum;\t&#125; /* 左边扫描结束 */\tMaxRightBorderSum = 0; RightBorderSum = 0;\tfor( i = center + 1; i &lt;= right; i++ ) &#123; /* 从中线向右扫描 */\t\tRightBorderSum += List[i];\t\tif( RightBorderSum &gt; MaxRightBorderSum )\t\t\tMaxRightBorderSum = RightBorderSum;\t&#125; /* 右边扫描结束 */    /* 下面返回&quot;治&quot;的结果 */\treturn Max3( MaxLeftSum, MaxRightSum,\t\t         MaxLeftBorderSum + MaxRightBorderSum );&#125;int MaxSubseqSum3( int List[], int N )&#123;   /* 保持与前2种算法相同的函数接口 */\treturn  DivideAndConquer( List, 0, N-1 );&#125;\n\n在线处理：（N）\nint MaxSubseqSum4( int List[], int N )&#123;   int ThisSum, MaxSum;\tint i;\tThisSum = MaxSum = 0;\tfor( i = 0; i &lt; N; i++ ) &#123;\t\tThisSum += List[i]; /* 向右累加 */\t\tif( ThisSum &gt; MaxSum )\t\t\tMaxSum = ThisSum; /* 发现更大和则更新当前结果 */\t\telse if( ThisSum &lt; 0 ) /* 如果当前子列和为负 */\t\t\tThisSum = 0; /* 则不可能使后面的部分和增大，抛弃之 */   &#125; \treturn MaxSum;&#125;","categories":["技术类","数据结构与算法学习日志"]},{"title":"第一篇Blog！","url":"/2022/03/06/%E7%AC%AC%E4%B8%80%E7%AF%87Blog%EF%BC%81-%E7%AC%AC%E4%B8%80%E7%AF%87blog/","content":"动态个人Blog搭建教程第一次的Blog，就分享下我的这个动态Blog如何搭建的吧！\nStep 1  准备工作下载MobaXterm  （这软件简直是ssh神器！）https://mobaxterm.mobatek.net/download-home-edition.html\n动态Blog类型有很多，我的建议是用halo的jar包进行搭建，因为halo官方一直在进行更新，而且社区内资源丰富，各种主题等都能比较方便的找到。\n下载halo.jar 与 nginx链接：https://pan.baidu.com/s/1t1lA9-Wn132x_x8z-BQgAg?pwd=fndh提取码：fndh \n链接内也包含了常用的blog主题，供各位自取\n购置云服务器构建动态blog，需要买一个云服务器，我的网站服务器是在百度智能云上购买的，最近在打折，搭建blog的话ic4，centos 7.x就足够了，38元&#x2F;年的价格还挺良心的，搭建后别忘了重置服务器密码。\n百度智能云服务器：http://mke.cn/1gc0\nStep 2  开始搭建！服务器创建完成后，我们就可以开始正式搭建了\n首先，在MobaXterm里点击session，添加一个SSH，remote host一栏填的就是我们刚才准备的云服务器IP，username可以自定义，也可以不填，完成后输入云服务器的密码，就可以进入控制台了。\n然后，在MobaXterm里点击session，添加一个SFTP，填写方式与SSH相同。\n本次搭建需要的一个环境就是Java环境JDK，只需在SSH里输入一行命令即可安装\n\nyum install java-11-openjdk -y\n\n安装完成后我们就可以上传jar包了\n将下好的halo.jar拖到SFTP里面，然后在SSH里面输入以下命令运行jar包就可以了\n\nnohup java -jar halo-1.4.17.jar &amp;\n\n此时jar包就能在后台进行安装了\n等待一段时间后，在浏览器中进入以下网址\n\n你的云服务器IP:8090例如：180.76.160.104:8090\n\n就能进入halo的安装向导了，完成向导后即可进入后台管理系统，此时你就已经拥有一个高度自定义的动态Blog啦！同时在“主题”中，可以将下好的主题上传哦！\nStep 3  后续操作一般而言，我们不会让这个jar包启动的8090的这个后台服务去直面用户，而是在中间再加一层代理服务器做转发，最常用的就是Nginx服务器啦，所以我们需要到SSH中安装Nginx服务器，关于如何安装，这篇文章里有详细的教程（PCRE其实无需安装）https://www.runoob.com/linux/nginx-install-setup.html前面的压缩包里也有下好的Nginx供各位使用！\n最后的最后，就是定制一个自己的域名了（我暂时还没实现）在刚才百度智能云的购买界面里就有1元&#x2F;年的域名供大家选择，购买后点击“解析”，链接到目前博客的网站就可以了。不过购买后还需要实名，备案等一系列复杂操作。。所以我的域名暂时还在进行备案审核。。。祝各位顺利吧!\n后记不知不觉写了一个小时了，也算是把昨晚搭建的过程又复盘了一遍，准备去干午饭啦，祝各位搭建顺利,有任何疑问都可以在留言区询问哦！拜拜ヾ(•ω•&#96;)o\n","categories":["技术类"]},{"title":"诗！","url":"/2022/03/29/%E8%AF%97%EF%BC%81-poetry/","content":"没关系 没问题我还能继续前行散落下来的是 温暖的水滴散发光芒的未来再次遇见梦想吧光阴的山涧里 现实的海洋中就算会有迷茫的时候但以那闪光的地方为目的地在这个世界的每一隅抬起头尽情仰望吧\n","categories":["所感"]},{"title":"软件构造Lab1记录","url":"/2023/03/22/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0lab1%E8%AE%B0%E5%BD%95-sclab1record/","content":"软件构造Lab1记录实验目标概述本次实验通过求解三个问题，训练基本 Java 编程技能，能够利用 Java OO开发基本的功能模块，能够阅读理解已有代码框架并根据功能需求补全代码，能够为所开发的代码编写基本的测试程序并完成测试，初步保证所开发代码的正确性。另一方面，利用 Git 作为代码配置管理的工具，学会 Git 的基本使用方法。*\t基本的 Java OO 编程*\t基于 Eclipse IDE 进行 Java 编程*\t基于 JUnit 的测试*\t基于 Git 的代码配置管理。\n实验环境配置\nIntelliJ IDEA 2022.1\nJDK11\nMaven 4.0.0\nJunit 4.12 \nURL:https://github.com/ComputerScienceHIT/HIT-Lab1-2021112107.git\n\n实验过程Magic Squares第一，设计算法来识别输入的矩阵是否是幻方，要保持正确性和健壮性；第二，分析所给代码，画流程图，找出偶数负数报错的原因，并且把输入的矩阵保存为 6.txt，再用第一个问题中所设计的矩阵进行测试。\nisLegalMagicSquare()过程：\n\n读取文件，如果找不到文件，提示错误信息，返回 false\n判断文件中的元素是否用\\t 分开，如果不是，提示错误信息，返回 false\n判断元素是否全是正整数，如果不是，提示错误信息，返回 false\n判断矩阵行列数是否相等，如果不相等，提示错误信息，返回 false\n判断矩阵是否完整，如果缺项，提示错误信息，返回 false\n累加各个行、列、对角线的所有元素和，比较是否相等：如果其中两个不相等，提示错误信息，返回 false；如果全相等，提示是幻方，返回 true\n\nsrc/P1/txt/1.txt中的矩阵是幻方src/P1/txt/2.txt中的矩阵是幻方src/P1/txt/3.txt中的第19行未被\\t分割为21部分故其不是幻方src/P1/txt/4.txt中的-35&lt;0故其不是幻方src/P1/txt/5.txt中的第121行未被\\t分割为121部分故其不是幻方请输入正奇数n，用以生成一个n*n的幻方\n\n\ngenerateMagicSquare()过程：\n\n解释该函数如何生成 n×n 的幻方\n给出注释\n\n\n分析为何输入负数或者偶数时，会提示错误\n\n\n在输入负数或者偶数时，提示错误信息，并返回 false\n\n\n将生成的矩阵保存为 6.txt，并用 3.1.1 设计的函数中测试它。\n\n\n\n请输入正奇数n，用以生成一个n*n的幻方11幻方生成成功！生成的幻方为:68\t81\t94\t107\t120\t1\t14\t27\t40\t53\t6680\t93\t106\t119\t11\t13\t26\t39\t52\t65\t6792\t105\t118\t10\t12\t25\t38\t51\t64\t77\t79104\t117\t9\t22\t24\t37\t50\t63\t76\t78\t91116\t8\t21\t23\t36\t49\t62\t75\t88\t90\t1037\t20\t33\t35\t48\t61\t74\t87\t89\t102\t11519\t32\t34\t47\t60\t73\t86\t99\t101\t114\t631\t44\t46\t59\t72\t85\t98\t100\t113\t5\t1843\t45\t58\t71\t84\t97\t110\t112\t4\t17\t3055\t57\t70\t83\t96\t109\t111\t3\t16\t29\t4256\t69\t82\t95\t108\t121\t2\t15\t28\t41\t54正在生成文件6.txt以储存幻方幻方储存成功！已写入6.txt！src/P1/txt/6.txt中的矩阵是幻方\n\nTurtle Graphics该任务分为几个部分：首先要求学会从 github 上下载代码，然后要求利用已有的方法来绘画，包括画正方形，画正多边形，已知当前角度、起点、终点判断需要转过的角度，凸包问题，画出自己想画的图形。最后要求提交代码到 github上。\nProblem 1: Clone and import\n从 GitHub 获取该任务的代码：通过实验指导手册找到该任务的网站然后点击 Clone or download 后，再点击Download ZIP 即可\n\n\n在本地创建 git 仓库、使用 IDEA 集成的 git 管理本地开发。\n\n\n\n\n\nProblem 3: Turtle graphics and drawSquare利 用 Turtle 类 中 给 的 forward(units)\t和 turn(degrees)\t方 法 ， 来 完 成 drawSquare(Turtle turtle, int sideLength)方法，最后的输出要是一个正方形。实现方法很容易，先走 sideLength，顺时针转向 90，再走 sideLength，顺时针转向 90，然后走 sideLength，顺时针转向 90，最后走 sideLength 即可。\nProblem 5: Drawing polygons\ndouble calculateRegularPolygonAngle(int sides)；\n这个方法是根据正多边形的边数计算出多边形的内角公式是 double angle = 360 – 180/sides;\n\n\nint calculatePolygonSidesFromAngle(double angle)；这个方法是根据正多边形的内角计算出边数\n公式是 int sides = Math.rint(180/(360 – angle));\n\n\nvoid drawRegularPolygon(Turtle turtle, int sides, int sideLength)；这个方法是根据给定的多边形边数与边长画出一个正多边形\n\n\n\nProblem 6: Calculating Bearings\n实现 calculateBearingToPoint 方法题意是：给定当前的转角（与 y 轴正向夹角，顺时针为正），当前位置，目标位置，求出到目标位置所需要的转角。\n\n\n实现 calculateBearings 方法 题意是：给定一个 x 坐标的列表，y 坐标的列表，组合为一些坐标位置，求出从上一个坐标位置到下一个坐标位置所需要的转角。\n\n\n\n\n\nProblem 7: Convex Hulls给定一些点的集合，求出这些点的凸包。通俗来讲，就是求出包围所有点的最小点集合。\nProblem 8: Personal art题目要求是：画一个自己想要的图形\nSubmitting将本地项目文件连接到 github 指定仓库后，通过 IDEA 的提交与推送上传至github。\nSocial Network建立一个图，来搭建社交网络，能实现添加点、边、求最短路径等操作。设计并实现 java 程序，包括 FriendshipGraph 类，Person 类，main()以及测试用例。\n设计&#x2F;实现 FriendshipGraph 类\naddvertex 函数：需要注意的是重复添加人名要返回错误信息；在此函数中扩展人名列表；图的矩阵要扩展，新的一列和新的一行除了对角线为 0，其他全为-1。\n\n\naddEdge 函数：需要注意自身不能与自身建边；两个人重复建边以最新的为准；不能与不存在的人建边。\n\n\ngetDistance 函数：需要用 bfs（宽度优先搜索）来对两个人之间求距离，注意与不存在的人之间距离为-1；不可达的两个人之间距离为-1；自身到达自身距离为 0；\n\n\n\n设计&#x2F;实现 Person 类public class Person &#123;    private final String Name;    public Person (String Name) &#123;        this.Name = Name;    &#125;    public String getName() &#123;        return this.Name;    &#125;    public boolean isSameName(String Name) &#123;        return this.Name.equals(Name);    &#125;&#125;\n\n设计&#x2F;实现客户端代码 main()public class FriendshipGraph &#123;    public static void main(String[] args) &#123;        FriendshipGraph graph = new FriendshipGraph();        Person rachel = new Person(&quot;Rachel&quot;);        //Person ross = new Person(&quot;Rachel&quot;);        Person ross = new Person(&quot;Ross&quot;);        Person ben = new Person(&quot;Ben&quot;);        Person kramer = new Person(&quot;Kramer&quot;);        graph.addVertex(rachel);        graph.addVertex(ross);        graph.addVertex(ben);        graph.addVertex(kramer);        graph.addEdge(rachel, ross);        graph.addEdge(ross, rachel);        graph.addEdge(ross, ben);        graph.addEdge(ben, ross);        System.out.println(graph.getDistance(rachel, ross));  //should print 1        System.out.println(graph.getDistance(rachel, ben));  //should print 2        System.out.println(graph.getDistance(rachel, rachel));  //should print 0        System.out.println(graph.getDistance(rachel, kramer));  //should print -1    &#125;&#125;\n\n设计&#x2F;实现测试用例\n对于 addvertex 函数要测试正常添加一个人（true）与重复添加一个人（false）；\n\n\n对于 addEdge 函数要测试两个人正常建立关系（true）、一个人与自己建立关系（false）、两个人重复建立关系（以最新关系为准）、不存在的人名(false)；\n\n\n对于 getDistance 函数要测试不可达关系、自身到达自身的距离、一个可达关系的距离、不存在的人名(false)。\n\n\n\n实验过程中收获的经验和教训\n学习新的编程语言时候，要学会与之前学过的语言进行类比\n遇到不会的英文单词一定要立马查，不要靠猜词义，很容易理解错误\n\n","categories":["技术类","软件构造"]},{"title":"��������Lab2��¼","url":"/2023/05/10/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0lab3%E8%AE%B0%E5%BD%95-sclab3record/","content":"��������Lab3��¼ʵ��Ŀ�����Ŀ���Ǳ�д���пɸ����ԺͿ�ά���Ե���������Ҫʹ�������������켼����  \n\n�����͡����͡���̬����д������\n�̳С�ί�ɡ�CRP\n�﷨�����ı�̡��������ʽ\n���ģʽ����ʵ������˶������Ӧ�ã�ѧ������ֱ�����ÿ��Ӧ�÷ֱ���ʵ�֣�����ͨ�� ADT �ͷ��͵ȳ�����������һ�׿ɸ��õ� ADT ����ʵ�֣���ֿ�����ЩӦ��֮��������ԺͲ����ԣ�ʹ ADT �и���̶ȵĸ��ã��ɸ����ԣ��͸�����������ֱ仯����ά���ԣ���\n\nʵ�����������������Ӧ�ó����������г���Ҫ��ɵľ���Ӧ�ó���������3����1��2��ѡһ��3��ѡ��4��5��ѡһ��������ɸ����Ӧ�ó�������\n\nTrackGame\n\n\nAtomStructure\n\n\nSocialNetworkCircle  \n\n��������ѡ���Ķ��Ӧ�ó�������ͬ������������������Щ�����й��ԡ���Щ�����в��졣���ȣ����Ƕ��Ƕ����ṹ�����ǵĹ��ʮ�����ƣ������Կ���һ��ֻ�����ֺͰ뾶���Ե�Բ�����ǵĹ������Ҳ��һЩ����֮�������綼Ҫ�������֡����Ƕ�Ҫ���ж��ڹ��������ϵ������һϵ����ɾ�Ĳ�Ĳ�����Ҫ����֮ͬ�����е�Ҫ���������֮��������������ϵ���еĸ�������֮��û�����������ӣ��е�����������˶�Ա�� ��\n\n�����õ���ƣ�CircularOrbit&lt;L,E&gt;\nsetCentralObject(L centralObject);\t������������\ngetCentralObject();\t������������\naddTrack(Track t);\t����һ�����\nremoveTrack(Track t);\tɾ��һ�����\ngetTrackNum();\t���ع����Ŀ\ngetObjectNumonTrack(Track t);\tͳ��һ������ж�������\naddObjectToTrack(Track t, E object);\t��������������\nremoveObjectOnTrack(Track t, E object);\tɾȥһ������ϵ�ĳ������\naddtrackRelation(E object1, E object2, double distance)\t�������������֮��������ϵ\naddcentralRelation(E object, double distance);\t�ڹ���������������֮��������ϵ\ngetObjectDistributionEntropy();\t������ϵͳ����Ϣ��\ngetLogicalDistance(E e1, E e2);\t�����������߼�����\ngetDifference(CircularOrbit&lt;L, E&gt; c);\t�Ƚϵ�ǰorbit��Ŀ��orbit�Ĳ�ͬ\nreturn һ��different���󣬼�¼����orbit������\ngetSortedTracks();\t��õ�ǰorbit���������й�����뾶���гɵ�����\ndrawpicture();\t���ӻ�����\ncontains(E e);\t�жϵ�ǰOrbit�Ƿ����ĳ��Ԫ��e\ngetObjectTrack(E e);\t����ĳ��Ԫ��e���ڵ�Object����\ngetCentralConnectedObject();\t�������������ӵ����幹�ɵļ���\ngetTrackConnectedObject(E object)\t������ĳ������������ӵ���������\ncheckRep(){\t���Ϸ���\n\n�����õ���ƣ�Track�������� name���� ��radius�뾶��ʵ��Comparable�����뾶����\n�����õ���ƣ�Lֻ��һ�������֣�������Name��getter������CentralObject(String name) ���췽���Լ�checkRep() ����������ַǿա�\n�����õ���ƣ�PhysicalObjectֻ��һ�������֣�������Name��getter������PhysicalObject (String name) ���췽���Լ�checkRep() ����������ַǿա�\n���ģʽӦ��3.9.1 �������ģʽ����ÿ������Object����ʵ��һ����̬��getInstance����������Ҫʵ����Athlete���ɵ���\nBuilder���ģʽ����Ƴ���CircularOrbitBuilder����Ϊ����builder��ĸ��࣬����һ��concreteCircularOrbit��������build�����е�Orbit\n\ngetConcreteCircularOrbit() {\t���ع�����ɵĶ���\nabstract void createCircularOrbit();\t���󷽷���ʵ��ʱ�����������͵�Orbit\nbulidPhysicalObjects(L centralObj, Map&lt;Track, List&gt; ObjectMap)\t���ݴ����centralObj��ObjectMap��ʼ��concreteCircularOrbit�еĹ�ϵMap\nbulidTracks(List trackList) {\t���ݴ����trackList����concreteCircularOrbit\n\n֮���ٸ��ݾ���Ӧ��ʵ����builder�ࡣ\nIterator���ģʽ���OrbitIterator��ʵ��Iterator�ӿڡ�\nObjectList�Ǳ������������list��ÿ��ȡnext��ObjectListȡֵ��Index�ǵ���ָ�롣\n\nOrbitIterator(Map&lt;Track, List&gt; orbitMap)\t���캯�������ݹ�ϵMap orbitMap����һ��ObjectList��Ϊ���������\nhasNext()\t�жϵ���ָ���Ƿ����size���������û����һ����\nnext()\tȡԪ�أ�Index++\n\nstrategy���ģʽ��TrackGame�����һ��strategy�ӿں���������ʵ�ֵ�strategy�࣬�ֱ���ִ���������Ͱ��ɼ�����\nӦ������뿪������������ƺ�ʵ�ֵ�ADT��ʵ���ֲ���Ҫ��ĸ���ܡ����¸�С�ڣ�ֻ�豣�����������ѡ����Ӧ�ü��ɡ�\nTrackGameAthlete��̳���PhysicalObject��Ϊ������壬����������������\nTrackCircularOrbit��̳���ConcreteCircularOrbit��Ϊ�������ṹ��д��toString������������ṹ��д��checkRep()������Ҫ����������\nTrackCircularOrbitBuilder��̳���CircularOrbitBuilder��Ҫ����д��createCircularOrbit����������TrackCircularOrbit��\nGameType������ͣ�trackNum���������athleteList�˶�Ա�б�\ntrackOrbitList��һ��TrackCircularOrbit��list�ṹ����Ϊÿ�ΰ��ű������ɶ������ṹ�������list������ɵ�����TrackCircularOrbit��\ntrackBuilder��TrackCircularOrbitBuilder��һ��ʵ��������buildÿһ��TrackCircularOrbit����\n\nGameMenu() {\t�˵�\ngameMain\t�������壬��ȡ�ļ�������ÿ��TrackCircularOrbit��ʵ�ֲ˵��е�ÿ�����ܡ�\narrangeOrbit(Strategy strategy)\t���԰��ŷ���������athleteList��trackNum�͹�����ԣ����ɹ��췽��\n\nAtomStructureParticle��̳���PhysicalObject��Ϊ������壬���������·�����\ngetElectron����һ��û������ĵ��ӣ�getNucleus����һ�������������ԭ�Ӻ�\nAtomCircularOrbit��̳���ConcreteCircularOrbit��Ϊ�������ṹ��Ҫ����д��toString�����������������£�����\t����transit(Track t1, Track t2) {\t����ԾǨ����removeElectron(Track t)\t��ĳ�����ɾȥһ�����ӣ���Ϊ���ӻ���֮��û����������ֻ��һ�������������дtoString\t�������ṹ\nAtomCircularOrbitBuilder��̳���CircularOrbitBuilder��Ҫ����д��createCircularOrbit����������AtomCircularOrbit��AtomGame�ࣺ����������\ntrackNum���������Nucleusԭ�Ӻ�\ntransitCareTaker��TransitCareTaker��һ��ʵ��������ʵ�ֱ���¼ģʽ�������ǰ�ÿ��ԾǨ��¼��Memento�����������ָ�ʱ������һ��Memento��\natomCircularOrbit���ǵ�ǰʹ�õĹ��ϵͳʵ����\nSocialNetworkCirclePerson��̳���PhysicalObject��Ϊ�������\nAge�������䣬gender���Ա�\nrelationKeeper�����һ�����������ļ�������࣬��Ϊ��ȡ�ļ�����Ĺ���û������ȡ�������� ������ʵ����Ӧ���������Թ���relationKeeper����ÿ����ϵ������string��\nSocialNetCircularOrbit��̳���ConcreteCircularOrbit��Ϊ�������ṹ\n\nreArrange\t������ϵ����\n��дdrawpicture����\tʵ�ֿ��ӻ����������ṹҪ����ӻ���ϵ�����Լ��ϻ��ߵĹ��ܡ�\n��дtoString\t�������ṹ\n\nSocialNetCircularOrbitBuilder��̳���CircularOrbitBuilder��Ҫ����д��createCircularOrbit����������SocialNetCircularOrbit������bulidRelations���Ӷ�ȡ���ļ����빹���˼ʹ�ϵͼ�����ͨ��reArrange��������ϵͼ��\npersonList���б���centralUser�������� ��keeperList��һ����ϵ��ȡ�Ĵ���socialCircularOrbit�ǵ�ǰ������SocialNetCircularOrbit����socialCircularOrbitBuilder��SocialNetCircularOrbitBuilder��һ��ʵ��������buildÿһ��SocialNetCircularOrbit����\n������Ϣ��ɢ�ȣ�˼·����Ҫ���ö���+BFS�㷨��������ʼ�㣺����mapΪ&lt;��ʼ�㣬���ĵ㵽��ʼ���Ȩ��&gt;������BFS�㷨�ҵ���ÿ���㣬����mapΪ&lt;��һ���㣬��һ�����Ȩx��һ���㵽���һ����Ĺ�ϵ��Ȩ&gt;������ͼ�д��ڹ�ϵa-&gt;b-&gt;c, aΪ���ĵ㣬�����ܶ�Ϊ��value(a,b)+ value(a,b) x value(b,c)\nGit�ֿ�ṹ�������ȫ��ʵ��Ҫ��֮������Git logָ���Gitͼ�λ��ͻ��˻�GitHub����Ŀ�ֿ��Insightҳ�棬������Ĳֿ⵽ĿǰΪֹ��Object Graph���������������312change��֧��master��֧��ָ���λ�á�\nʵ���ܽ�ʵ��������ջ�ľ���ͽ�ѵ����ɸ����Խϵͣ����ģʽ���䲻��\n������·���ĸ���\n����˼��Lab2�е����⣺����ADT�ı�̺�ֱ������Ӧ�ó�����̣�����ᵽ�����кβ��죿��ʵ����Ƶ�ADT�������ͬ��Ӧ�ó�����ʹ�ã����Ƿ���ᵽ���õĺô���\n����˼��Lab2�е����⣺ΪADT׫д���ӵ�specification, invariants, RI, AF��ʱ��ע��ADT�Ƿ���rep exposure����Щ������������ʲô�����Ƿ�Ը�����Ժ�ı���м����ô����\n֮ǰ�㽫�����ṩ��API�����Լ��ĳ��򿪷��У�����ʵ���㳢���ſ���������ʹ�õ�API���Ƿ��ܹ���ᵽ���е��Ѵ�����Ȥ��\n�ڱ����ʹ�����ģʽ�������˺ܶ��࣬���ڸ��úͿ�ά���Է�����������档����ο������ģʽ��\n\n\n��֮ǰ��ʹ����������ʱ��Ӧ�������������������ϵͳ����ָ�����ʵ���㿪����һ����������ʹ���﷨���������ʽȥ���������ļ����ݴ˹����������﷨��������кθ��ܣ�\nLab1��Lab2�Ĵ󲿷ֹ��������Ǵ�0��ʼ�����ǻ������˸�������Ʒ����ͳ�ʼ���롣����ʵ��������ȫ��0��ʼ����ADT����Ʋ���OOPʵ�֣���������֮����о������ADT�����Ѷ���Ҫ��������Щ�ط���������ο˷��ģ�\n\n\n������ɱ�ʵ��ʱ���Ƿ��вο�Lab4��Lab5��ʵ���ֲ᣿���У�������ڱ���ʵ����ͬʱȥ���Ǻ�������ʵ���Ҫ��ģ�\n\n\n���ڱ�ʵ��Ĺ��������Ѷȡ�deadline��\n��ĿǰΪֹ��ԡ��������졷�γ̵����ۡ�\n\n\n\n�ش�1.\t���ü�С�˹���������������˼������2.\tʱ�������Լ�ע���Լ�����ƣ�ע���ֹй¶3.\tʹ�ñ��˵�API��ͼ�ܷ��㡣4.\t�����������ģʽʮ��������ô�����Բ�ͬ��ADTʹ��ǡ�������ģʽ����Ҫ5.\t�������Լ�����ķ������̡�6.\t������ĳ���7.\t���ֲ�8.\t�Ѷ��е� �������ܴ� ddl����ĩ�����غϵ���ʱ���������9.\t�������ܴ��ջ��ķᡣ\n","categories":["������","��������"]},{"title":"软件构造Lab2记录","url":"/2023/04/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0lab2%E8%AE%B0%E5%BD%95-sclab2record/","content":"软件构造Lab2记录实验目标概述本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说：\n\n针对给定的应用问题，从问题描述中识别所需的ADT；\n设计ADT规约（pre-condition、post-condition）并评估规约的质量；\t\n根据ADT的规约设计测试用例；\nADT的泛型化；\n根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）\n使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；\n测试ADT的实现并评估测试的覆盖度；\n使用ADT及其实现，为应用问题开发程序；\n在测试代码中，能够写出testing strategy并据此设计测试用例。\n\n实验环境配置由于IDEA中集成了jacoco，故直接在配置界面开启即可\n实验过程Poetic Walks该任务主要是实验一个图的模块，并基于此使用。\n\n完善Graph接口类，并运用泛型的思想，将String拓展为泛型L类；\n\n\n实现Graph类的方法：add、set、remove、vertices、sources、targets；\n\n\n利用实现的Graph类，应用图的思想，实现GraphPoet类，如果输入的文本的两个单词之间存在桥接词，则插入该桥接词；若存在多个单一桥接词，则选取边权重较大者。\n\n\n\nGet the code and prepare Git repositorygit clone即可\nProblem 1: Test Graph 测试静态方法生成String类型的Graph。\nProblem 2: Implement Graph 该部分要求重写Graph里的方法，分别以点为基础的图和以边为基础的图。两种类型的图都经过同一个实例测试。\nImplement ConcreteVerticesGraphVertex是点的抽象类，包含3个信息：点的标识、指向该点的边、由该点引出的边。Vertex需要能访问这3个信息，以及增加&#x2F;删除进边&#x2F;出边。ConcreteVerticesGraph是以点为基础的图，每个点通过唯一的标识进行区分，set和remove都依赖与Vertex类中的添加和删除操作，sources和targets也调用了Vertex类的方法。\nProblem 3: Implement generic GraphMake the implementations generic在程序中选择选择“String”并选择更改所有匹配项，即可实现泛化类型。\nImplement Graph.empty()使Graph.empty()能返回一个新的空实例即可。\nProblem 4: Poetic walks给定一个语料库corpus，根据corpus中的文本生成一个单词图，然后给定一条语句输入，在图中搜索词之间的关系，自动补全语句中可能可以完善的部分。图的构建规则是，在corpus中，对每一个不一样的单词看作一个顶点，相邻的单词之间，建立一条有向边，相邻单词对出现的次数，作为这条有向边的权值。在输入信息补全时，对相邻单词A和B做检查，如果存在一个单词C，在图中可以由前一个单词A通过这个单词C到达单词B，那么就在A和B之间补全C，补全的优先级按照权值越大者优先。\nImplement GraphPoetpublic GraphPoet(File corpus) throws IOException &#123;    BufferedReader reader = new BufferedReader(new FileReader(corpus));    String line = &quot;&quot;;    String[] words;    while ((line = reader.readLine()) != null) &#123;        line = line.replace(&quot;.&quot;, &quot; &quot;);        words = line.split(&quot; &quot;);        for (int i = 0; i &lt; words.length; i++) &#123;            graph.add(words[i].toLowerCase());            if (i &gt; 0) &#123;                int lastEdgeWeight = graph.set(words[i - 1].toLowerCase(), words[i].toLowerCase(), 1);                if (lastEdgeWeight != 0)                    graph.set(words[i - 1].toLowerCase(), words[i].toLowerCase(), lastEdgeWeight + 1);            &#125;        &#125;    &#125;    reader.close();    checkRep();&#125;\n\nRe-implement the Social Network in Lab1这部分任务就是用我们在3.1中写的ADT，把第一次实验中的FriendshipGraph重新实现一遍，图中的节点仍然是Person类型，所以泛型L一律为Person.\t 而对于已经写好的FriendshipGraph中的方法，要用3.1中的Graph ADT中的方法来实现它们。\nFriendshipGraph类import graph.*;import java.util.*;import java.util.LinkedList;import java.util.Queue;public class FriendshipGraph &#123;    private final Graph&lt;Person&gt; graph = Graph.empty();    public boolean addVertex(Person newPerson) &#123;        return graph.add(newPerson);    &#125;    public int addEdge(Person a, Person b) &#123;        int lastEdgeWeight;        lastEdgeWeight = graph.set(a, b, 1);        lastEdgeWeight = graph.set(b, a, 1);        return lastEdgeWeight;    &#125;        public int getDistance(Person sta, Person end) &#123;        if (sta.equals(end))            return 0;        Map&lt;Person, Integer&gt; dis = new HashMap&lt;&gt;();        Map&lt;Person, Boolean&gt; vis = new HashMap&lt;&gt;();        Queue&lt;Person&gt; qu = new LinkedList&lt;Person&gt;();        Set&lt;Person&gt; persons = graph.vertices();        for (Person person : persons) &#123;            dis.put(person, 0);            vis.put(person, false);        &#125;        vis.remove(sta);        vis.put(sta, true);        for (qu.offer(sta); !qu.isEmpty();) &#123;            Person person = qu.poll();            for (Map.Entry&lt;Person, Integer&gt; edge : graph.targets(person).entrySet()) &#123;                Person target = edge.getKey();                if (!vis.get(target)) &#123;                    qu.offer(target);                    vis.remove(target);                    vis.put(target, true);                    dis.remove(target);                    dis.put(target, dis.get(person) + 1);                    if (target.equals(end))                        return dis.get(target);                &#125;            &#125;        &#125;        return -1;    &#125;&#125;\nPerson类public class Person &#123;    private final String Name;    public Person(String PersonName) &#123;        this.Name = PersonName;    &#125;    public String getName() &#123;        return this.Name;    &#125;&#125;\n客户端main()package poet;import java.io.File;import java.io.IOException;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        final GraphPoet nimoy = new GraphPoet(new File(&quot;src/P1/poet/mugar-omni-theater.txt&quot;));        final String input = &quot;Test the system.&quot;;        System.out.println(input + &quot;\\n&gt;&gt;&gt;\\n&quot; + nimoy.poem(input));    &#125;&#125;\n\n实验过程中收获的经验和教训\n设计一个完整的软件，需要从底层的ADT设计起\n\n\n检验ADT的正确性后才能检测软件的正确性\n\n\n\n\n\n","categories":["技术类","软件构造"]}]